<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Eco.Shared</name>
    </assembly>
    <members>
        <member name="T:Eco.Shared.Authentication.AuthResult">
            <summary>
            A mirror of AuthSucceedResult and AuthFailedResult from AuthServer combined
            </summary>
        </member>
        <member name="T:Eco.Shared.Authentication.VoiceJoinTokenRequest">
            <summary>
            Used to group together voice paramters when requesting a token.
            </summary>
        </member>
        <member name="T:Eco.Shared.Blueprints.Blueprint">
            <summary>
            A combination of blocks to be placed or modified.
            </summary>
        </member>
        <member name="M:Eco.Shared.Blueprints.Blueprint.SetValue(Eco.Shared.Math.Vector3i,System.UInt16)">
            <summary> Set the block ID of a relative position, overwriting any existing block ID. </summary>
        </member>
        <member name="M:Eco.Shared.Blueprints.Blueprint.RemoveValue(Eco.Shared.Math.Vector3i)">
            <summary> Clear the block from the given position if it is set.</summary>
        </member>
        <member name="M:Eco.Shared.Blueprints.Blueprint.TryGetValue(Eco.Shared.Math.Vector3i,System.UInt16@)">
            <summary> Gets the block ID for the given position if it exists. </summary>
        </member>
        <member name="M:Eco.Shared.Blueprints.Blueprint.Clear">
            <summary> Clear all block IDs from the blueprint. </summary>
        </member>
        <member name="M:Eco.Shared.Blueprints.Blueprint.GetEnumerator">
            <summary> Gets a enumerator of all the set block IDs with their positions. </summary>
        </member>
        <member name="M:Eco.Shared.Blueprints.Blueprint.System#Collections#IEnumerable#GetEnumerator">
            <summary> Gets a enumerator of all the set block IDs with their positions. </summary>
        </member>
        <member name="M:Eco.Shared.Blueprints.Blueprint.SetFromRangeAndBlockId(System.Collections.Generic.IEnumerable{Eco.Shared.Math.Vector3i},System.UInt16)">
            <summary> Sets the blueprint to all the blocks of the range, relative to WorldRange.min, set to the given block ID. </summary>
        </member>
        <member name="T:Eco.Shared.Blueprints.BlueprintBlock">
            <summary>
            A block from a blueprint, consisting of a position and a block ID.
            </summary>
        </member>
        <member name="T:Eco.Shared.Blueprints.BlueprintInstance">
            <summary>
            An instance of a blueprint in the world, given a blueprint and a world position.
            </summary>
        </member>
        <member name="M:Eco.Shared.Blueprints.BlueprintInstance.TryGetValue(Eco.Shared.Math.Vector3i,System.UInt16@)">
            <summary> Gets the block ID from the bluprint relative to the world position of the instance. </summary>
        </member>
        <member name="M:Eco.Shared.Blueprints.BlueprintInstance.GetEnumerator">
            <summary> Gets a enumerator of all the set block IDs with their world positions. </summary>
        </member>
        <member name="M:Eco.Shared.Blueprints.BlueprintInstance.System#Collections#IEnumerable#GetEnumerator">
            <summary> Gets a enumerator of all the set block IDs with their world positions. </summary>
        </member>
        <member name="T:Eco.Shared.Collections.BatchedSet`1">
            <summary>
            Batched queue which allows to process queued objects by batches of max size <see cref="F:Eco.Shared.Collections.BatchedSet`1.batchSize"/>.
            It should be provided with <see cref="F:Eco.Shared.Collections.BatchedSet`1.fetcher"/> which will perform fetching of new objects to the queue either incremental or with full re-fetch way.
            In case of full re-fetch it will replace current queue content with new data. For incremental fetch it will add fetched items to end of the queue.
            You can use <see cref="M:Eco.Shared.Collections.BatchedSet`1.Fetch(System.Boolean)"/> and <see cref="M:Eco.Shared.Collections.BatchedSet`1.GetNextBatch"/> separate or you can use <see cref="M:Eco.Shared.Collections.BatchedSet`1.FetchNextBatch(System.Boolean)"/> which combines these two methods calls.
            This class isn't thread-safe!
            </summary>
        </member>
        <member name="M:Eco.Shared.Collections.BatchedSet`1.FetchNextBatch(System.Boolean)">
            <summary> Combines call to <see cref="M:Eco.Shared.Collections.BatchedSet`1.Fetch(System.Boolean)"/> and <see cref="M:Eco.Shared.Collections.BatchedSet`1.GetNextBatch"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Collections.BatchedSet`1.GetNextBatch">
            <summary> Returns next batch of max size <see cref="F:Eco.Shared.Collections.BatchedSet`1.batchSize"/> from pre-fetched objects. </summary>
        </member>
        <member name="M:Eco.Shared.Collections.BatchedSet`1.Fetch(System.Boolean)">
            <summary>
            Fetches data using <see cref="F:Eco.Shared.Collections.BatchedSet`1.fetcher"/> and adds it to end of the queue.
            If <paramref name="incremental"/> is <c>false</c> then it will clear the queue and replace it with fetched data.
            </summary>
        </member>
        <member name="T:Eco.Shared.Collections.EquatableArray`1">
            <summary>Equatable Array is a way to create equatable version of array which may be used as Dictionary key or for other hash/equals aware collections or operations.</summary>
        </member>
        <member name="T:Eco.Shared.Collections.RandomAccessQueue`1">
            <summary>
            RandomAccessQueue class is re-implementation of standard .NET Queue class, but with few additions for random access:
            <see cref="M:Eco.Shared.Collections.RandomAccessQueue`1.Remove(`0)"/> allows to remove element from queue (for standard queue you can only remove first element with Dequeue)
            <see cref="M:Eco.Shared.Collections.RandomAccessQueue`1.EnqueueFirst(`0)"/> allows to add element at beginning of queue (not possible in standard queue).
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.Enqueue(`0)">
            <summary>
            Add element to the end of queue.
            </summary>
            <param name="el">element to add.</param>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.EnqueueFirst(`0)">
            <summary>
            Add element before first element in the queue.
            </summary>
            <param name="el">element to add.</param>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.Dequeue">
            <summary>
            Remove and return first element from queue.
            </summary>
            <returns>First element in queue.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if queue is empty.</exception>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.TryDequeue(`0@)">
            <summary>
            Tries to <see cref="M:Eco.Shared.Collections.RandomAccessQueue`1.Dequeue"/> element from queue. Safe version which returns <c>false</c> if no element instead of throwing exception.
            </summary>
            <param name="value">first element of queue if operation succeed, default value otherwise.</param>
            <returns><code>true</code> if element exists and outputted in <c>value</c>.</returns>
        </member>
        <member name="T:Eco.Shared.Collections.UnboundedSPSCQueue`1">
            <summary>
            Unbounded Single Producer Single Consumer Queue.
            </summary>
            <remarks>
            It is safe to use in multi-threaded environment as long as only one thread is consuming and only one thead is producing.
            It may lead to unpredictable results otherwise.
            </remarks>
        </member>
        <member name="T:Eco.Shared.Items.InteractionInfo">
            <summary> Information about an interaction, calculated on the client. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.ID">
            <summary> ID used to rewind bad predictions. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.Method">
            <summary> Method used to start the interaction. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.Modifier">
            <summary> Any modifier key held down while triggering the interaction. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.TargetObject">
            <summary> The object being interacted with, if set. If this is set BlockPosition will be null. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.BlockPosition">
            <summary> The targeted block, if set. Will not be set at the same time as TargetObject. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.Parameters">
            <summary> Custom interaction parameters. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.Distance">
            <summary> Distance to the interaction target. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.Position">
            <summary> When TargetObject is not null, the position the interaction ray intersected with the target object. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.Normal">
            <summary> The facing direction of the side of the selected block. This is the side any placed block will be. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.FacingDirection">
            <summary> The facing direction of the player when performing the action. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionQueryInfo.TargetObject">
            <summary> Target object, if set. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionQueryInfo.HitPosition">
            <summary> If TargetObject is set, the position the ray interacted with the object. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionQueryInfo.Parameters">
            <summary> Custom parameters. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionQueryInfo.BlockPosition">
            <summary> The targeted blocks position, if TargetObject is not set. </summary>
        </member>
        <member name="F:Eco.Shared.Items.ItemInfo.InteractDistance">
            <summary> For IInteractingItem, the distance that it can be interacted with. </summary>
        </member>
        <member name="F:Eco.Shared.Items.ItemInfo.HighlightBlockIDs">
            <summary> For IInteractingItems, the block IDs that will get highlighted. </summary>
        </member>
        <member name="T:Eco.Shared.Localization.LocalizedEnumConverter">
            <summary>
            Used to enable localized enum values in PropertyGrids.
            Can also be manually added to any enum to override the default behaviour when casting to a string.
            </summary>
        </member>
        <member name="M:Eco.Shared.Localization.DescriptionLoc.MutualTag(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.String}})">
            <summary> Searches for the rarest tag that is present in every collection. </summary>
        </member>
        <member name="M:Eco.Shared.Localization.DescriptionLoc.MutualTag(System.Collections.Generic.IEnumerable{System.ValueTuple{System.String,System.Collections.Generic.IEnumerable{System.String}}},System.Collections.Generic.IEnumerable{System.ValueTuple{System.String,System.Collections.Generic.IEnumerable{System.String}}},System.Collections.Generic.HashSet{System.String})">
            <summary> Searches for the rarest tag that is present in every selected element. Can also determine if all elements of this tag have been selected. </summary>
        </member>
        <member name="M:Eco.Shared.Localization.DescriptionLoc.DescribeViews(System.Collections.Generic.IEnumerable{System.Object},System.Collections.Generic.IEnumerable{System.Object},System.Collections.Generic.HashSet{System.String},System.String)">
            <summary> Tries to combine entries into groups. See SearchableListUI.UpdateSlots on the client side for a demo. </summary> // Handy converter for the client side.
        </member>
        <member name="M:Eco.Shared.Localization.DescriptionExtensinons.GetNamesAndTags(Eco.Shared.View.ViewClassInfo)">
            <summary> Gets ViewClassInfo's display name and tags. </summary>
        </member>
        <member name="M:Eco.Shared.Localization.DescriptionExtensinons.GetNamesAndTagsFromViews(System.Collections.Generic.IEnumerable{System.Object})">
            <summary> Gets display name and tags of every ViewClassInfo in the collection. </summary>
        </member>
        <member name="T:Eco.Shared.Localization.LocDescriptionCloneAttribute">
            <summary> Clones <see cref="T:Eco.Shared.Localization.LocDescriptionAttribute"/> of the provided property. </summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocDescriptionAttribute.LocDescription">
            <summary> Non-resolved <see cref="T:Eco.Shared.Localization.LocString"/> value for the description. </summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocDescriptionAttribute.Description">
            <summary> Localized description. </summary>
        </member>
        <member name="T:Eco.Shared.Localization.NotLocalizedDisplayNameAttribute">
            <summary>
            The standard DisplayNameAttribute doesn't support Enums + other types, so this is a useful extension.
            </summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocCategoryDescription.LocDescription">
            <summary> Non-resolved <see cref="T:Eco.Shared.Localization.LocString"/> value for the display name. </summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocCategoryDescription.Description">
            <summary> Localized description. </summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocDisplayNameAttribute.LocDisplayName">
            <summary> Non-resolved <see cref="T:Eco.Shared.Localization.LocString"/> value for the display name. </summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocDisplayNameAttribute.Name">
            <summary> Not localized display name. </summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocDisplayNameAttribute.DisplayName">
            <summary> Localized display name. </summary>
        </member>
        <member name="M:Eco.Shared.Localization.LocExtensions.InsertLineLoc(Eco.Shared.Localization.LocStringBuilder,System.FormattableString)">
            <summary> Inserts the line at the beginning of the builder. </summary>
        </member>
        <member name="M:Eco.Shared.Localization.LocStringBuilder.TrimFormat">
            <summary> Trims format string. </summary>
        </member>
        <member name="M:Eco.Shared.Mathf.Round(System.Single)">
            <summary>
            Rounds half using standard rounding algorithm (to even or bank rounding)!
            I.e. -0.5 -> 0; 0.5 -> 0; 1.5 -> 2.
            </summary>
            <param name="value">value to round.</param>
            <returns>rounded value, tie rounded to closest even number.</returns>
        </member>
        <member name="M:Eco.Shared.Mathf.RoundToMultiple(System.Single,System.Int32)">
            <summary> Rounds value so it will be multiple of some value. Sample: 11, 5 => 10 </summary>
        </member>
        <member name="M:Eco.Shared.Mathf.RoundUp(System.Single)">
            <summary>
            Rounds half up. I.e. -0.5 -> 0; 0.5 -> 1; 1.5 -> 2.
            We should prefer this way of rounding for coordinates,
            because for voxel we always subtracting 0.5 (i.e. voxel with position [0,0,0] will have [-0.5,-0.5,-0.5] coordinates).
            </summary>
            <param name="value">value to round.</param>
            <returns>rounded value, tie rounded to closest greater int number.</returns>
        </member>
        <member name="M:Eco.Shared.Mathf.RoundUpToInt(System.Single)">
            <summary>
            Rounds half up. I.e. -0.5 -> 0; 0.5 -> 1; 1.5 -> 2.
            We should prefer this way of rounding for coordinates,
            because for voxel we always subtracting 0.5 (i.e. voxel with position [0,0,0] will have [-0.5,-0.5,-0.5] coordinates).
            </summary>
            <param name="value">value to round.</param>
            <returns>rounded value, tie rounded to closest greater int number.</returns>
        </member>
        <member name="M:Eco.Shared.Mathf.ClampTop(System.Single,System.Single)">
            <summary> Clamps to max value. Same as Clamp(current, float.MinValue, max). </summary>
        </member>
        <member name="M:Eco.Shared.Mathf.PercentageOf(System.Single,System.Single)">
            <summary> Calculates percentage [0; 1] of <paramref name="total"/> for specified <paramref name="value"/>. </summary>
            <sample> percentage of <c>5</c> for <c>100</c> is <c>0.05</c>. </sample>
        </member>
        <member name="M:Eco.Shared.Mathf.PercentageComplementOf(System.Single,System.Single)">
            <summary> Calculates complement of the percentage [0; 1] of the <paramref name="value"/> for the <paramref name="total"/> (1 - percentage). </summary>
            <sample> percentage of <c>5</c> for <c>100</c> is <c>0.05</c>; complement of the percentage of <c>5</c> for <c>100</c> is <c>0.95</c>. </sample>
        </member>
        <member name="M:Eco.Shared.Mathf.CeilingToInt(System.Single,System.Single)">
            <summary>
            Performs <see cref="M:System.Math.Ceiling(System.Double)"/> for <paramref name="num"/> with specified <paramref name="epsilon"/> and converts value to int.
            If previous integer value is within <paramref name="epsilon"/> of <paramref name="num"/> then it will use previous value instead.
            <paramref name="num"/> should be >= 0 and <paramref name="epsilon"/> should be > 0 and &lt;=0.5. Otherwise you will get undetermined result.
            </summary>
            <sample>
            <code>CeilingToInt(0.01f, 0.001f) // 1</code>
            <code>CeilingToInt(0.001f, 0.001f) // 0</code>
            </sample>
        </member>
        <member name="M:Eco.Shared.Mathf.FloorToInt(System.Single,System.Single)">
            <summary>
            Performs <see cref="M:System.Math.Floor(System.Double)"/> for <paramref name="num"/> with specified <paramref name="epsilon"/> and converts value to int.
            If next integer value is within <paramref name="epsilon"/> of <paramref name="num"/> then it will use next value instead.
            <paramref name="num"/> should be >= 0 and <paramref name="epsilon"/> should be > 0 and &lt;= 0.5. Otherwise you will get undetermined result.
            </summary>
            <sample>
            <code>FloorToInt(0.99f, 0.001f) // 0</code>
            <code>FloorToInt(0.999f, 0.001f) // 1</code>
            </sample>
        </member>
        <member name="M:Eco.Shared.Math.DoubleExtensions.TryConvertToLong(System.Double,System.Int64@)">
            <summary>Tries to convert <paramref name="value"/> to <see cref="T:System.Int64"/>. It will fail if the value out of long value range, NaN or infinity.</summary>
        </member>
        <member name="M:Eco.Shared.Math.FloatExtensions.Sign(System.Single,System.Single)">
            <summary> Returns <paramref name="value"/> sing with specified <paramref name="tolerance"/>. If absolute <paramref name="value"/> less than <paramref name="tolerance"/> then sign will be assumed to <c>0</c>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.FloatExtensions.Wrap(System.Single,System.Single)">
             <summary>
             Wraps value to a range starting with 0 and ending with wrapTo.
             It ensures value in this range and if value is negative it will start from end of range.
            
             For wrapped range we means a some range starting with 0 and ended with concrete end value. I.e. [0, 100)
             When value wrapped it should be enclosed in this range:
              - reduce it to length of this range with "modulo" operation.
              - if it negative then it should be aligned at the end of range
              Some examples for range [0, 100):
                250     ->   250 % 100 = 50   | -                -> 50
                -175    ->   -175 % 100 = -75 | 100 - 75 = 25    -> 25.
             </summary>
             <param name="value">Value to wrap.</param>
             <param name="wrapTo">Ending value of range.</param>
             <returns>Value wrapped to range.</returns>
        </member>
        <member name="M:Eco.Shared.Math.FloatExtensions.SetWhenLess(System.Single@,System.Single)">
            <summary>
            Replaces <paramref name="value"/> with <paramref name="candidate"/> if it is less than <paramref name="value"/>.
            Shorthand for
            <code>
            var candidate = someFunc();
            if (candidate &lt; value)
            {
               value = candidate;
               doSomethingElse();
            }
            </code>
            may be shortened to
            <code>
            if (value.SetWhenLess(someFunc())) doSomethingElse();
            </code>
            </summary>
            <returns><c>true</c> if value was set.</returns>
        </member>
        <member name="M:Eco.Shared.Math.IntExtensions.Wrap(System.Int32,System.Int32)">
             <summary>
             Wraps value to a range starting with 0 and ending with wrapTo.
             It ensures value in this range and if value is negative it will start from end of range.
            
             For wrapped range we means a some range starting with 0 and ended with concrete end value. I.e. [0, 100)
             When value wrapped it should be enclosed in this range:
              - reduce it to length of this range with "modulo" operation.
              - if it negative then it should be aligned at the end of range
              Some examples for range [0, 100):
                250     ->   250 % 100 = 50   | -                -> 50
                -175    ->   -175 % 100 = -75 | 100 - 75 = 25    -> 25.
             </summary>
             <param name="value">Value to wrap.</param>
             <param name="wrapTo">Ending value of range.</param>
             <returns>Value wrapped to range.</returns>
        </member>
        <member name="M:Eco.Shared.Math.IntExtensions.InWrappedRange(System.Int32,System.Int32,System.Int32,System.Int32)">
             <summary>
             Checks if value is in a range which enclosed in wrapped range. <see cref="M:Eco.Shared.Math.IntExtensions.Wrap(System.Int32,System.Int32)"/>
            
             It means that "wrappedStart" and "wrappedEnd" values defines a range [wrappedStart, wrappedEnd),
             but this range itself is wrapped to [0, wrappedTo).
            
             So it may create situation when we have initial values: "start" = 80, "end" = 150,
             but after wrapping to [0, 100) they become: "wrappedStart" = 80 and "wrappedEnd" = 50.
            
             And in this case we have "wrappedStart" > "wrappedEnd", because of wrapping. It may be represented as:
             <para>
             xxxxxxx*********************xxxxxxx.
             </para>
             where "x" belongs to wrappedStart to wrappedEnd range.
            
             And for this kind of range we have to make special check where "value" contained in [min, max) range when
             it either contained in [wrappedStart, wrappedTo) or [0, wrappedEnd).
            
             If min &lt;= max, then standard check will be used.
             </summary>
             <param name="value">value to check if it contains in range.</param>
             <param name="wrappedStart">start range value (wrapped).</param>
             <param name="wrappedEnd">end range value (open, wrapped).</param>
             <param name="wrappedTo">end of wrapping range.</param>
             <returns>True if value contained in wrappedStart to wrappedEnd range, False otherwise.</returns>
             <seealso cref="M:Eco.Shared.Math.IntExtensions.Wrap(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Eco.Shared.Math.IntExtensions.WrappedRangeTo(System.Int32,System.Int32,System.Int32)">
             <summary>
             Creates enumerable which enumerates all values contained in range defined by "wrappedStart" and "wrappedEnd". <see cref="M:Eco.Shared.Math.IntExtensions.Wrap(System.Int32,System.Int32)"/>
             These values enclosed in wrapping range [0, wrappedTo), so it may create situation where "wrappedStart"
             greater than "wrappedEnd" because of overlapping start or end bound.
            
             I.e. for wrapping range [0, 100): [-50, 10) => [50, 10), [50, 120) => [50, 20)
            
             In this case we have to iterate over two ranges: [wrappedStart, wrappedTo) and [0, wrappedEnd).
             If wrappedStart less or equal to wrappedEnd then we go to standard iteration over [wrappedStart, wrappedEnd).
             </summary>
             <param name="wrappedStart">start range value (wrapped).</param>
             <param name="wrappedEnd">end range value (open, wrapped).</param>
             <param name="wrappedTo">end of wrapping range.</param>
             <returns>enumerable for wrapped range.</returns>
             <seealso cref="M:Eco.Shared.Math.IntExtensions.Wrap(System.Int32,System.Int32)"/>
             <seealso cref="M:Eco.Shared.Math.IntExtensions.InWrappedRange(System.Int32,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="T:Eco.Shared.Math.IntRange">
            <summary> Range bounded by int numbers. Alternative to <see cref="T:System.Range"/> without at end indexes support. </summary>
        </member>
        <member name="P:Eco.Shared.Math.IntRange.Length">
            <summary> Length of the range. </summary>
        </member>
        <member name="M:Eco.Shared.Math.IntRange.After(Eco.Shared.Math.IntRange,System.Int32)">
            <summary> Makes new <see cref="T:Eco.Shared.Math.IntRange"/> right after the <paramref name="range"/> with specified <paramref name="length"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.IntRange.FromOffsetAndLength(System.Int32,System.Int32)">
            <summary> Makes <see cref="T:Eco.Shared.Math.IntRange"/> from <paramref name="offset"/> and <paramref name="length"/> instead of two indexes. </summary>
        </member>
        <member name="M:Eco.Shared.Math.IntRange.op_Implicit(Eco.Shared.Math.IntRange)~System.Range">
            <summary> Implicitly converts to System.Range for array accessors etc. </summary>
        </member>
        <member name="T:Eco.Shared.Math.Matrix2x2i">
            <summary>
            Simple 2x2 integer matrix.
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.Range.InRangeNormalDist(System.Single)">
            Return whether a value is in the range, based on a normal random distribution 
        </member>
        <member name="M:Eco.Shared.Math.Range.Clamp0">
            <summary> Make sure the range is >= 0 </summary>
        </member>
        <member name="M:Eco.Shared.Math.Range.RoundToInt">
            <summary> Roumd min down, and max up. </summary>
        </member>
        <member name="M:Eco.Shared.Math.Range.RoundToMultiple(System.Single)">
            <summary> Roumd min down to the nearest multiple of 'val', and max up. </summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector2.NormalizeSafe(Eco.Shared.Math.Vector2)">
            <summary>
            Same as <see cref="P:Eco.Shared.Math.Vector2.Normalized"/>, but for zero-length vector it returns <paramref name="defaultValue"/> instead.
            <see cref="P:Eco.Shared.Math.Vector2.Normalized"/> will return <see cref="F:System.Single.NaN"/> vector in this case.
            </summary>
        </member>
        <member name="P:Eco.Shared.Math.Vector2.Round">
            <summary>
            Uses default rounding rules (bank rounding, or round to closest even in case of tie).
            I.e. 0.5 -> 0, but 1.5 -> 2.
            </summary>
        </member>
        <member name="P:Eco.Shared.Math.Vector2.RoundUp">
            <summary>
            Always rounds to closes greater number. Preferred way of rounding for coordinates, because voxel coordinates always shifted down.
            I.e. 0.5 -> 1, 1.5 -> 2 and -1.5 -> -1.
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector2.AngleRad(Eco.Shared.Math.Vector2)">
            <summary> Returns angle between two in degs.</summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector2i.XYIter(Eco.Shared.Math.Vector2i,System.Int32)">
            <summary> Emits all integer two-component vectors with offset in range from 0 to size for each component and with the specified <paramref name="origin"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector2i.XYIterInclusive(System.Int32,System.Int32)">
            Iterate over a range (inclusive) 
        </member>
        <member name="M:Eco.Shared.Math.Vector3.NormalizeSafe(Eco.Shared.Math.Vector3)">
            <summary> Returns normalized version of vector (by dividing each component on vector length), but returns <paramref name="defaultValue"/> in case if length is zero to avoid producing NaN vector. </summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector3.AngleRad(Eco.Shared.Math.Vector3)">
            <summary> Returns angle between two in degs.</summary>
        </member>
        <member name="P:Eco.Shared.Math.Vector3.Round">
            <summary>
            Uses default rounding rules (bank rounding, or round to closest even in case of tie).
            I.e. 0.5 -> 0, but 1.5 -> 2.
            </summary>
        </member>
        <member name="P:Eco.Shared.Math.Vector3.RoundUp">
            <summary>
            Always rounds to closes greater number. Preferred way of rounding for coordinates, because voxel coordinates always shifted down.
            I.e. 0.5 -> 1, 1.5 -> 2 and -1.5 -> -1.
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector3i.AddY(System.Int32)">
            <summary>Returns new <see cref="T:Eco.Shared.Math.Vector3i"/> with <see cref="P:Eco.Shared.Math.Vector3i.Y"/> component with added <paramref name="deltaY"/>. You can use negative <paramref name="deltaY"/> to subtract value.</summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector3i.GetAxis(Eco.Shared.Math.Axis)">
            <summary> Returns the scalar value for the given axis. </summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector3i.MinAxis">
            <summary> Return the smallest axis, breaking ties arbitrarily. </summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector3i.MaxAxis">
            <summary> Return the largest axis, breaking ties arbitrarily. </summary>
        </member>
        <member name="M:Eco.Shared.Math.VectorUtils.MoveAndRotate(System.Collections.Generic.IEnumerable{Eco.Shared.Math.Vector3i},Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary> Returns distinct collection of vectors form the area that were shifted and rotated according to provided params. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.Length">
            <summary> The length not including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.Width">
            <summary> The width not including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.Height">
            <summary> The height not including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.Volume">
            <summary> The volume not including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.Size">
            <summary> The size not including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.LengthInc">
            <summary> The length including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.WidthInc">
            <summary> The width including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.HeightInc">
            <summary> The weight including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.VolumeInc">
            <summary> The volume including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.SizeInc">
            <summary> The size including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.Invalid">
            <summary> A range where IsValid() will return false. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.Empty">
            <summary> A range around 0,0,0 with 0 dimentions. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.CollapseAlongAxis(Eco.Shared.Math.Axis,System.Boolean)">
            <summary> Collapses a square range into a line. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.InvertRange(System.Int32@,System.Int32@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Inverts the range inside world to make a direction in a proper way
            E.g. start as 955 with end as 1 and worldSize 1000 will give a reversed direction from 955 to 1
            It'll return minValue as -45 and maxValue as 1 (-45:1 range) 
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.Fix(Eco.Shared.Math.Vector3i)">
            <summary> Swaps any values where the min of the axis is larger than the max of the axis. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.RotatedBy(Eco.Shared.Math.Quaternion)">
            <summary>Rotates <see cref="T:Eco.Shared.Math.WorldRange"/> around (0, 0, 0).</summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.ExtendedBy(Eco.Shared.Math.Vector3i)">
            <summary>Returns new <see cref="T:Eco.Shared.Math.WorldRange"/> extended in each direction by <paramref name="extent"/>.</summary>
            <example><code>
            new WorldRange(new(0, 0, 0), new(1, 1, 1)).ExtendedBy(new(1, 0, 2)); // WorldRange((-1, 0, -2), (2, 1, 3))
            </code></example>
        </member>
        <member name="T:Eco.Shared.Math.WrappedWorldPosition3">
            <summary> Represents wrapped world position which doesn't require any further conversions. It prevents multiple checks everywhere for position to be actually wrapped or multiple conversions for same data. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3.Create(System.Single,System.Single,System.Single)">
            <summary> Makes new <see cref="T:Eco.Shared.Math.WrappedWorldPosition3"/> from unwrapped <paramref name="x"/>, <paramref name="y"/> and <paramref name="z"/>. </summary>
        </member>
        <member name="T:Eco.Shared.Math.WrappedWorldPosition3Extensions">
            <summary> Extension methods for <see cref="T:Eco.Shared.Math.WrappedWorldPosition3"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3Extensions.WrappedDifference(Eco.Shared.Math.WrappedWorldPosition3,Eco.Shared.Math.WrappedWorldPosition3)">
            <summary> Calculates wrapped difference between <paramref name="a"/> and <paramref name="b"/>. </summary>
        </member>
        <member name="T:Eco.Shared.Math.WrappedWorldPosition3i">
            <summary>
            Represents wrapped world position which doesn't require any further conversions. It prevents multiple checks everywhere for position to be actually wrapped or multiple conversions for same data.
            Comparing to <see cref="T:Eco.Shared.Math.WorldPosition3i"/> it isn't packed, so doesn't require extra packing/unpacking operations and also readonly what allows to apply some optimizations and makes it thread-safe.
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.XYZNeighbors">
            <summary> Returns all orthogonal neighbors by X, Y, Z axes. It won't return Y axis neighbors if they out of bounds (bellow zero or above MaxY) and wrap X, Z neighbors (if they crossing zero coordinate). </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.XYZNeighborsWithDirection">
            <summary> Returns all orthogonal neighbors by X, Y, Z axes. It won't return Y axis neighbors if they out of bounds (bellow zero or above MaxY) and wrap X, Z neighbors (if they crossing zero coordinate). </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.AddX(System.Int32)">
            <summary>Adds <paramref name="x"/> to <see cref="F:Eco.Shared.Math.WrappedWorldPosition3i.X"/> component and returns new value. The value should be not less than -<see cref="P:Eco.Shared.Voxel.World.WrappedVoxelSize"/>.X.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.AddZ(System.Int32)">
            <summary>Adds <paramref name="z"/> to <see cref="F:Eco.Shared.Math.WrappedWorldPosition3i.Z"/> component and returns new value. The value should be not less than -<see cref="P:Eco.Shared.Voxel.World.WrappedVoxelSize"/>.Z.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.TryIncreaseY(System.Int32,Eco.Shared.Math.WrappedWorldPosition3i@)">
            <summary>Tries to increase <see cref="F:Eco.Shared.Math.WrappedWorldPosition3i.Y"/> component where <paramref name="increment"/> should be positive value. If succeed (not out of world bounds) then returns <c>true</c> and increased value in <paramref name="increasedPos"/>. For decreasing <see cref="F:Eco.Shared.Math.WrappedWorldPosition3i.Y"/> use <see cref="M:Eco.Shared.Math.WrappedWorldPosition3i.TryDecreaseY(System.Int32,Eco.Shared.Math.WrappedWorldPosition3i@)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.TryDecreaseY(System.Int32,Eco.Shared.Math.WrappedWorldPosition3i@)">
            <summary>Tries to decrease <see cref="F:Eco.Shared.Math.WrappedWorldPosition3i.Y"/> component where <paramref name="decrement"/> should be positive value. If succeed (not out of world bounds) then returns <c>true</c> and decreased value in <paramref name="decreasedPos"/>. For increasing <see cref="F:Eco.Shared.Math.WrappedWorldPosition3i.Y"/> use <see cref="M:Eco.Shared.Math.WrappedWorldPosition3i.TryIncreaseY(System.Int32,Eco.Shared.Math.WrappedWorldPosition3i@)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.TryGetNeighbor(Eco.Shared.Math.Direction,Eco.Shared.Math.WrappedWorldPosition3i@)">
            <summary>Returns neighbor world position for <paramref name="dir"/> if possible. It may return <c>false</c> for invalid <paramref name="dir"/> value or if Y will go out of world bounds.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.Create(System.Int32,System.Int32,System.Int32)">
            <summary> Makes new <see cref="T:Eco.Shared.Math.WrappedWorldPosition3i"/> from unwrapped <paramref name="x"/>, <paramref name="y"/> and <paramref name="z"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.Create(System.Single,System.Single,System.Single)">
            <summary> Makes new <see cref="T:Eco.Shared.Math.WrappedWorldPosition3i"/> from unwrapped <paramref name="x"/>, <paramref name="y"/> and <paramref name="z"/>. </summary>
        </member>
        <member name="T:Eco.Shared.Math.WrappedWorldPosition3iExtensions">
            <summary> Extension methods for <see cref="T:Eco.Shared.Math.WrappedWorldPosition3"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3iExtensions.WrappedDifference(Eco.Shared.Math.WrappedWorldPosition3i,Eco.Shared.Math.WrappedWorldPosition3i)">
            <summary>
            Calculates wrapped difference between <paramref name="a"/> and <paramref name="b"/>.
            I.e. for world size (100, 100, 80):
            - (10, 10, 10).WrappedDelta(20, 20, 20) -> (-10, -10, -10)
            - (10, 10, 10).WrappedDelta(60, 20, 60) -> (-50, -10, -30)
            - (10, 10, 10).WrappedDelta(60, 20, 60) -> (-50, -10, -50)
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3iExtensions.XZ(Eco.Shared.Math.WrappedWorldPosition3i)">
            <summary> Returns <see cref="T:Eco.Shared.Math.Vector2i"/> for <see cref="F:Eco.Shared.Math.WrappedWorldPosition3i.X"/> and <see cref="F:Eco.Shared.Math.WrappedWorldPosition3i.Z"/> coordinates. </summary>
        </member>
        <member name="T:Eco.Shared.Networking.ClientUpdate">
            <summary>
            Contains data for <see cref="F:Eco.Shared.Networking.NetworkEvent.ClientUpdate"/> events.
            Every <see cref="T:Eco.Shared.Networking.ClientUpdate"/> belongs to network queue with <see cref="F:Eco.Shared.Networking.ClientUpdate.queueIndex"/>.
            Queue index defines associated <see cref="T:Eco.Shared.Networking.NetworkEvent"/> as ClientUpdate<i>Index</i> (i.e. <see cref="F:Eco.Shared.Networking.NetworkEvent.ClientUpdate0"/> and <see cref="F:Eco.Shared.Networking.NetworkEvent.ClientUpdate1"/>).
            It has four data arrays for <see cref="F:Eco.Shared.Networking.ClientUpdate.Created"/> objects, <see cref="F:Eco.Shared.Networking.ClientUpdate.Updated"/> objects, <see cref="F:Eco.Shared.Networking.ClientUpdate.Destroyed"/> objects and <see cref="F:Eco.Shared.Networking.ClientUpdate.ViewUpdates"/>.
            They should be filled and then flushed with <see cref="M:Eco.Shared.Networking.ClientUpdate.Send(Eco.Shared.Networking.INetClient)"/> method. Only non-empty arrays sent.
            If all arrays are empty then <see cref="M:Eco.Shared.Networking.ClientUpdate.Send(Eco.Shared.Networking.INetClient)"/> call will be ignored unless <see cref="F:Eco.Shared.Networking.ClientUpdate.ForceSend"/> is set.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.ClientUpdate.AddToData(System.String,Eco.Shared.Serialization.BSONArray@)">
            <summary>Adds <paramref name="bson"/> to <see cref="F:Eco.Shared.Networking.ClientUpdate.data"/> with <paramref name="keyName"/> as key and replaces <paramref name="bson"/> with empty array.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.EcoAttribute">
            <summary>
            One attribute to rule them all. This gives all the bells-and-whistles to a property or class, including:
             - Serialized.  Loads and saves the entry.
             - SyncToView.  It creates a view of the property on the client and keeps it updated.
             - AutoRPC.     Creates an RPC for the client to edit this parameter.
             - AutoGen.     Tags the member to have UI generated for it automatically created on the client.
             - Property Scanning. The Property Scanner will traverse into it to update validity.
            </summary>
        </member>
        <member name="T:Eco.Shared.Networking.ScanPropAttribute">
            <summary> Mark a property as being traversed by Property Scanner, even if not tagged [Eco]. </summary>
        </member>
        <member name="T:Eco.Shared.Networking.TreatAsReferenceAttribute">
            <summary> Used for things that reference types like 'object', and we should consider them references from a scanning point of view. </summary>
        </member>
        <member name="T:Eco.Shared.Networking.ForceScanSubPropAttribute">
            <summary> Mark a property as to traverse its sub properties, even if it wouldn't usually otherwise (ie, references dont usually 'scan into') </summary>
        </member>
        <member name="T:Eco.Shared.Networking.DontScanAttribute">
            <summary> Remove a property that would be scanned by the Property Scanner from being scanned. </summary>
        </member>
        <member name="T:Eco.Shared.Networking.AnyStateAllowedAttribute">
            <summary> Mark a property as able to refernce any state of Proposablew. </summary>
        </member>
        <member name="T:Eco.Shared.Networking.RPCAttribute">
            <summary> Creates an RPC that can be called on the client. </summary>
        </member>
        <member name="T:Eco.Shared.Networking.ClientAPIAttribute">
            <summary>Marks method or class with all it's members as Client API. It prevents it marked as unused and adds semantic about use cases.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.AutoRPCAttribute">
            <summary> Creates an RPC in the view for the client to change this property. </summary>
        </member>
        <member name="T:Eco.Shared.Networking.KeepIconAttribute">
            <summary> 
            Keep class icon when using as property for GameValue instead of context icon. 
            Example: GameAction contains Citizen property and uses context icon, this attribute will force any User property to use it's own icon.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.UdpPeerExtensions.SendUnconnectedMessageWithFragmentation(Eco.Shared.Networking.Udp.IUnconnectedUdpPeer,System.Net.IPEndPoint,System.IO.MemoryStream)">
             <summary>
             Sends unconnected message to recipient with fragmentation support.
             Fragmented messages conforms to following protocol:
                 [NetMessage.FragmentedMessage][fragmentation info byte][fragmented message guid][message body fragment]
            
             [fragmentation info byte] - contains pair partIndex/numOfParts (4 bits each), lower 4 bits is a part index and upper 4 bits is a number of parts. If 0 then message is not fragmented
             [fragmented message guid] - Used as fragmented message identifier to assembly message from parts at destination. 16 bytes.
             [message body fragment] - actual message body. Each fragment will contain part of message body.
            
             Samples:
             0Hello World
            
             One fragment:
                 [\0][H][e][l][l][o][ ][W][o][r][l][d]
             Two fragments:
                 [\10][\32][Guid:16 bytes][\0][H][e][l][l][o]
                 [\10][\33][Guid:16 bytes][ ][W][o][r][l][d]
            
             Following this protocol maximum useful allowed message length is: (MTU - 18) * 15.
             </summary>
             <param name="peer">peer.</param>
             <param name="message">Message to send, if it matches MTU then it will be send as is, otherwise wrapped in fragmented message.</param>
             <param name="recipient">recipient endpoint.</param>
             <exception cref="T:System.ArgumentException">Thrown if message body is too long to split into 15 fragments (max number of fragments).</exception>
        </member>
        <member name="P:Eco.Shared.Networking.FragmentedMessageHandler.TTL">
            <summary>
            Gets or sets fragmented message Time-To-Life, if during this interval message will not be assembled then it will be cleaned up.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.FragmentedMessageHandler.TryGetCompleteBuffer(Eco.Shared.Networking.UdpDataMessage@,Eco.Shared.Networking.UdpDataMessage@)">
            <summary>
            Handles incoming message which may be a fragment. Will return same message if message is complete and may be processed further.
            If it is a message fragment then it will be added to collection of message fragments.
            As soon as all message fragments will be collected it will assemble NetBuffer with message content.
            </summary>
            <param name="message">UdpIncomingMessage message which may be fragment or complete message.</param>
            <param name="completeMessage">UdpIncomingMessage containing complete message data if success, null otherwise.</param>
            <returns>Returns true if able to get complete buffer, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">In case of a fragment inconsistency.</exception>
        </member>
        <member name="T:Eco.Shared.Networking.INetObjectName">
            <summary> Interface which may be implemented by <see cref="T:Eco.Shared.Networking.INetObject"/> to expose custom name for network object (i.e. for logging). </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetObjectManager.CollectObjectStats">
            <summary> Collect stats about existing network objects in <see cref="T:Eco.Shared.Networking.NetObjectManager"/>. May be used for statistic and leaks detection. </summary>
        </member>
        <member name="P:Eco.Shared.Networking.NetworkClient.RemoteEndPoint">
            <summary> Actual remote end-point for the <see cref="F:Eco.Shared.Networking.NetworkClient.peer"/>. </summary>
        </member>
        <member name="P:Eco.Shared.Networking.NetworkClient.ServerEndPoint">
            <summary> Server's original end-point (may differ from <see cref="P:Eco.Shared.Networking.NetworkClient.RemoteEndPoint"/> if connected with relay). </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetworkClient.BuildDelivery">
            <summary>
            Build delivery packets list in thread unsafe context to be delivered with thread-safe <see cref="M:Eco.Shared.Networking.NetworkClient.Deliver(System.Collections.Generic.List{Eco.Shared.Pools.PooledMemoryStream})"/>.
            </summary>
            <returns>list of packets to delivery.</returns>
        </member>
        <member name="M:Eco.Shared.Networking.NetworkClient.Deliver(System.Collections.Generic.List{Eco.Shared.Pools.PooledMemoryStream})">
            <summary>
            Thread-safe deliver method for list of packets.
            WARNING! It consumes packets list! You can't use the list after pass it to Deliver method.
            </summary>
            <param name="packets">list of packets to deliver.</param>
        </member>
        <member name="M:Eco.Shared.Networking.NetworkClient.EnqueueReceivedPacket(Eco.Shared.Networking.ReceivedNetworkPacket)">
            <summary>Enqueues received packet to the queue based on network event.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetworkClient.Dispose">
            <summary>
            Disposes of the <see cref='T:System.ComponentModel.Component'/>.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetMessage.EncodePacket(System.IO.MemoryStream,Eco.Shared.Networking.NetworkEvent,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encodes network packet either as compressed (see <see cref="M:Eco.Shared.Networking.NetMessage.EncodeCompressedPacket(System.IO.MemoryStream,Eco.Shared.Networking.NetworkEvent,System.Byte[],System.Int32,System.Int32)"/>) or as non-compressed (if it is short enough &lt;=512).
            It has following structure (for uncompressed packet):
            [network event:1 byte]
            [length in bytes:int, zig zag bytes] - see <see cref="M:Eco.Shared.Utils.MemoryStreamExtensions.EncodeZigZag(System.IO.MemoryStream,System.Int32)"/>
            [message bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetMessage.EncodeCompressedPacket(System.IO.MemoryStream,Eco.Shared.Networking.NetworkEvent,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encodes network packet as compressed.
            It has following structure:
            [0x80 - compressed flag | network event:1 byte]
            [compressed length in bytes:int, 4 bytes]
            [compressed bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetMessage.EncodePacket(System.IO.MemoryStream,Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject)">
            <summary> Encodes <paramref name="payload"/> as network packet for <paramref name="netEvent"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetMessage.SendPacket(Eco.Shared.Networking.Udp.IUdpClient,Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject)">
            <summary> Sends <paramref name="netEvent"/> with <paramref name="payload"/> through the <paramref name="peer"/> (to the server). </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetMessage.BroadcastPacket(Eco.Shared.Networking.Udp.IUdpServer,Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject)">
            <summary> Broadcasts <paramref name="netEvent"/> with <paramref name="payload"/> to all connected clients. </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetMessage.SendPacket(Eco.Shared.Networking.Udp.IUdpPeer,Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject,System.Object)">
            <summary> Encodes <paramref name="payload"/> and sends <paramref name="netEvent"/> with it's data to <paramref name="connection"/> (may be obtained from <see cref="E:Eco.Shared.Networking.Udp.IUdpPeer.Connected"/>). </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetMessage.SendPacket(Eco.Shared.Networking.Udp.IUdpPeer,Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject,System.Collections.Generic.IEnumerable{System.Object})">
            <summary> Encodes <paramref name="payload"/> and sends <paramref name="netEvent"/> with it's data to all <paramref name="connections"/> (may be obtained from <see cref="E:Eco.Shared.Networking.Udp.IUdpPeer.Connected"/>). </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetMessage.DoWithDisconnectReason``1(System.String,``0,System.Action{``0,Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject})">
            <summary> Invokes <paramref name="action"/> with pre-constructed disconnect message object. </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetworkUtils.TryResolve(System.String,System.Net.IPAddress@)">
            <summary>
            Resolves IP address or host name to IPAddress object.
            If '*' used then it will auto-discovery remote address using https://www.ipify.org/.
            </summary>
        </member>
        <member name="F:Eco.Shared.Networking.RelayClient.RelayServerAddresses">
            <value>Remote address list for official relay servers.</value>
        </member>
        <member name="F:Eco.Shared.Networking.RelayClient.DefaultRelayServerPort">
            <value>Default Relay Server port.</value>
        </member>
        <member name="F:Eco.Shared.Networking.RelayClient.RelayServerProtocolVersion">
            <value>Current message serialization version, bump when message format changes.</value>
        </member>
        <member name="M:Eco.Shared.Networking.RelayClient.TryProcessRelayIntroduce(System.Net.IPEndPoint,System.Byte[],System.Int32@,System.Guid@,System.Net.IPEndPoint@)">
            <summary>
            Processes relay introduce message:
             [remote port:2 bytes][server id:guid].
            </summary>
            <param name="senderEndpoint">remote endpoint from which message received.</param>
            <param name="messageData">incoming message data.</param>
            <param name="readPosition">message read position.</param>
            <param name="serverId">expected server id.</param>
            <param name="connectionEndPoint">output parameter for connection end point.</param>
        </member>
        <member name="P:Eco.Shared.Networking.ServerInfo.External">
            <value>
            Set by master server if this server is available directly by external IP address.
            </value>
        </member>
        <member name="P:Eco.Shared.Networking.ServerInfo.RelayAddress">
            <value>
            Optional relay address, may be set by server to inform clients how to connect to this server if connect in usual way (direct/NAT Punch Through) doesn't work.
            </value>
        </member>
        <member name="P:Eco.Shared.Networking.ServerInfo.Access">
            <summary> Access mode of server: "public", "hidden", or "private". </summary>
        </member>
        <member name="T:Eco.Shared.Networking.Udp.DisconnectReason">
            <summary> Enum for different disconnect reasons which may be produced by <see cref="T:Eco.Shared.Networking.Udp.IUdpPeer"/>. </summary>
        </member>
        <member name="T:Eco.Shared.Networking.Udp.IUdpClient">
            <summary>
            Interface for Upd client.
            It contains client specific methods and properties (like <see cref="P:Eco.Shared.Networking.Udp.IUdpClient.ConnectionStatus"/> or <see cref="M:Eco.Shared.Networking.Udp.IUdpClient.Disconnect"/>).
            </summary>
        </member>
        <member name="T:Eco.Shared.Networking.Udp.IUdpLibrary">
            <summary>
            Interface for UDP libraries. Use this to create network lib peers.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUdpLibrary.CreateClient(System.String)">
            <summary>
            Create UPD client for app with <c>appIdentifier</c>.
            </summary>
            <param name="appIdentifier">app identifier.</param>
            <returns><see cref="T:Eco.Shared.Networking.Udp.IUdpClient"/> implementation instance for this lib.</returns>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUdpLibrary.CreateServer(System.String,System.Net.IPEndPoint,System.Int32)">
            <summary>
            Create UPD server for app with <c>appIdentifier</c>.
            </summary>
            <param name="appIdentifier">App identifier.</param>
            <param name="requestedEndPoint">Request endpoint for the server. You can use <c>IPEndPoint.Any</c> for address or <c>0</c>
            for port if you want to have automatically assigned values.</param>
            <param name="maxConnections">Maximum number of connections. <c>0</c> - for maximum possible.</param>
            <returns><see cref="T:Eco.Shared.Networking.Udp.IUdpServer"/> implementation instance for this lib.</returns>
        </member>
        <member name="T:Eco.Shared.Networking.Udp.IUdpPeer">
            <summary>
            Base interface for all UPD peers (either client or server).
            Contains common UPD transport methods: like Connect to specific peer, Send to peer or Receive message.
            </summary>
        </member>
        <member name="T:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer">
            <summary>
            Interface for unconnected UPD peers.
            Contains UPD Peer Api for unconnected messages only.
            </summary>
        </member>
        <member name="E:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.UnconnectedDataMessageReceived">
            <summary>
            Event called when unconnected data message received.
            </summary>
        </member>
        <member name="E:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.ErrorMessageReceived">
            <summary>
            Event called when an error message received.
            </summary>
        </member>
        <member name="E:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.WarningMessageReceived">
            <summary>
            Event called when a warning message received.
            </summary>
        </member>
        <member name="E:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.DebugMessageReceived">
            <summary>
            Event called when a debug message received.
            </summary>
        </member>
        <member name="P:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.MaximumUnconnectedMessageLength">
            <summary>
            MTU - maximum transmission unit size. Maximum size of UPD packet.
            </summary>
        </member>
        <member name="P:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.Port">
            <summary>
            Gets local port.
            </summary>
        </member>
        <member name="P:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.IsRunning">
            <summary>
            Gets running state of the peer.
            </summary>
        </member>
        <member name="P:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.LocalEndPoint">
            <summary>
            Local IP End Point for the peer.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.SendRaw(System.Net.IPEndPoint,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sends raw data with socket to destination peer.
            It releases buffer after a send operation, so it is safe to reuse the <c>messageData</c> buffer.
            </summary>
            <param name="remoteEndPoint">destination end point.</param>
            <param name="messageData">message data to send.</param>
            <param name="offset">offset in message data.</param>
            <param name="length">length of message.</param>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.SendUnconnectedMessage(System.Net.IPEndPoint,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sends unconnected message with network lib to destination peer.
            It releases buffer after a send operation, so it is safe to reuse the <c>messageData</c> buffer.
            </summary>
            <param name="remoteEndPoint">destination end point.</param>
            <param name="messageData">message data to send.</param>
            <param name="offset">offset in message data.</param>
            <param name="length">length of message.</param>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.Start">
            <summary>
            Starts peer. Makes initialization, creates socket and optionally starts background message processing thread.
            You need to call <see cref="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.Service(System.Int32)"/> or <see cref="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.ServiceOne(System.Int32)"/> to have network messages processed and trigger message events.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.Shutdown">
            <summary>
            Shutdowns peers. Releases resources and stops background threads (if any).
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.Service(System.Int32)">
            <summary>
            Services network messages - sending, receiving, connecting etc. You should call this method regular.
            /// Typical usage is following:
            <code>
            while (peer.IsRunning)
               peer.Service(10);
            </code>
            You can service single network event with <see cref="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.ServiceOne(System.Int32)"/>.
            </summary>
            <param name="timeoutMs">Maximum timeout between events. It will return if timeout exceed.</param>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.ServiceOne(System.Int32)">
            <summary>
            Same as <see cref="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.Service(System.Int32)"/>, but only service single network event.
            </summary>
            <param name="timeoutMs">Maximum timeout until event. It will return <c>false</c> if the event won't happen.</param>
            <returns><c>true</c> if the event serviced, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.SyncTimer(System.Double)">
            <summary>
            Synchronize timers. Ensures local timer and network timer will use same time base.
            </summary>
            <param name="currentTimeInSeconds">current time on your timer.</param>
        </member>
        <member name="T:Eco.Shared.Networking.Udp.SimpleUnconnectedUdpPeer">
            <summary> Simplest implementation of Unconnected UDP peer (used by master server) which doesn't use any third-party library, but just async sockets from .NET Core. </summary>
        </member>
        <member name="F:Eco.Shared.Networking.Udp.SimpleUnconnectedUdpPeer.ENetMtu">
            <summary> ENet Network Library MTU, we should have unconnected messages &lt;= MTU to be received by ENet. </summary>
        </member>
        <member name="M:Eco.Shared.Pathing.AITarget.Clear">
            <summary>Stop moving along any routes, and clear targets.</summary>
        </member>
        <member name="P:Eco.Shared.Pathing.AITarget.TargetPosition">
            <summary> Returns either the target object position (if available) and updates <see cref="F:Eco.Shared.Pathing.AITarget.targetPos"/> to last known position or returns <see cref="F:Eco.Shared.Pathing.AITarget.targetPos"/> with fallback to default value otherwise. </summary>
        </member>
        <member name="M:Eco.Shared.Pathing.AITarget.TryGetTargetObject(Eco.Shared.Networking.INetObjectPosition@)">
            <summary> Returns <paramref name="targetObj"/> if it is set and available in <see cref="T:Eco.Shared.Networking.NetObjectManager"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Pathing.AITarget.SetPosition(Eco.Shared.Math.Vector3)">
            <summary> Clear the route and set the position as passed. </summary>
        </member>
        <member name="M:Eco.Shared.Pathing.AITarget.SetLook(Eco.Shared.Networking.INetObjectPosition)">
            <summary> Sets look to <paramref name="followingTarget"/>. If <paramref name="followingTarget"/> is null then resets look target. </summary>
        </member>
        <member name="M:Eco.Shared.Pathing.AITarget.SetLook(Eco.Shared.Math.Vector3i)">
            <summary> Sets look to fixed <paramref name="pos"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Pathing.RouteFollower.SetRoute(Eco.Shared.Math.Route,System.Double)">
            <summary> Set the route, when we start, our speed, an an optional target to watch.</summary>
        </member>
        <member name="M:Eco.Shared.Pathing.RouteFollower.Position(System.Single)">
            <summary> Take the expected position at given time.</summary>
            <param name="lookAhead">Offset distance is adding to a calculated position.</param>
        </member>
        <member name="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.GetUnsafeListSnapshot">
            <summary>
            Returns unsafe list snapshot which may be directly accessed with <see cref="T:System.Collections.Generic.List`1"/> API.
            This list only safe to use before any modification operation like <see cref="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.Clear"/>, <see cref="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.AddRange(System.Collections.Generic.ICollection{`0})"/> etc.
            Also you should guarantee this list won't exceed current <see cref="P:System.Collections.Generic.List`1.Capacity"/> otherwise it may lead to unexpected behavior (including exceptions).
            </summary>
            <returns>Current snapshot reference. It may be null if Capacity == 0.</returns>
        </member>
        <member name="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.RentSnapshotAndClear">
            <summary>
            Returns current list snapshot and clear poolable list wrapper.
            </summary>
            <returns>Current snapshot. It may be null if Capacity == 0.</returns>
        </member>
        <member name="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.ReturnSnapshot(System.Collections.Generic.List{`0})">
            <summary>
            Return previously rented snapshot (see <see cref="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.RentSnapshotAndClear"/>).
            This method is thread-safe. Usual case you rent list in thread-unsafe content and then return it in another thread.
            </summary>
        </member>
        <member name="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.GetUnsafeListSnapshot(System.Int32)">
            <summary>
            Same as <see cref="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.GetUnsafeListSnapshot"/>, but ensures required capacity.
            </summary>
            <param name="minimalCapacity">minimal required capacity for snapshot.</param>
            <returns>Current snapshot reference. It may be null if Capacity == 0.</returns>
        </member>
        <member name="T:Eco.Shared.Pools.FixedSizePool`1">
            <summary>Implementation of <see cref="T:Eco.Shared.Pools.ThreadSafeFixedSizePool`1"/> with extended functionality. Obsolete, should be replaced with <see cref="T:Eco.Shared.Pools.PoolService`1"/> when all functionality will be supported.</summary>
        </member>
        <member name="M:Eco.Shared.Pools.FixedSizePool`1.Get">
            <summary>
            Returns a object from the pool or null if no objects in the pool.
            </summary>
            <returns>object from the pool or a new object.</returns>
        </member>
        <member name="M:Eco.Shared.Pools.FixedSizePool`1.TryAdd(`0)">
            <summary>Tries to add object to the pool (if enough capacity in the pool).</summary>
        </member>
        <member name="T:Eco.Shared.Pools.IObjectPool`1">
            <summary> Minimal Pool interface. If you wanna to have more advanced pool management you can use <see cref="T:Eco.Shared.Pools.PoolService`1"/>. </summary>
        </member>
        <member name="P:Eco.Shared.Pools.IObjectPool`1.Count">
            <summary> Current number of elements in pool. </summary>
        </member>
        <member name="M:Eco.Shared.Pools.IObjectPool`1.Get">
            <summary> Returns object from pool (if any) or <c>null</c> if pool is empty. It doesn't create new instance. </summary>
        </member>
        <member name="M:Eco.Shared.Pools.IObjectPool`1.TryAdd(`0)">
            <summary> Tries to add <paramref name="obj"/> to pool. If succeed then it returns <c>true</c>, otherwise (if pool is full or object is incompatible with pool) it will return <c>false</c>. You can handle return value for final object cleanup. </summary>
        </member>
        <member name="M:Eco.Shared.Pools.ListPool`1.Return(System.Collections.Generic.List{`0})">
            <summary>
            Use this with caution! If you will return list which was exceeded requested capacity then you can give an exception.
            </summary>
            <param name="list">list which was rented from pool.</param>
        </member>
        <member name="T:Eco.Shared.Pools.ObjectPoolExtensions">
            <summary>Extension methods for <see cref="T:Eco.Shared.Pools.IObjectPool`1"/> instances.</summary>
        </member>
        <member name="M:Eco.Shared.Pools.ObjectPoolExtensions.AsService``1(Eco.Shared.Pools.IObjectPool{``0},System.Action{``0})">
            <summary>
            Wraps <paramref name="pool"/> with <see cref="T:Eco.Shared.Pools.PoolService`1"/> with default constructor for new pool elements and optional <paramref name="onReturn"/> cleanup method.
            With this factory method <code><![CDATA[new PoolService<MyClass>(new MyPool<MyClass>(), () => new MyClass(), onReturn)]]></code> can be rewritten as <code><![CDATA[new MyPool<MyClass>().AsService(onReturn)]]></code>.
            </summary>
        </member>
        <member name="M:Eco.Shared.Pools.ObjectPoolExtensions.AsService``1(Eco.Shared.Pools.IObjectPool{``0},System.Func{``0},System.Action{``0})">
            <summary>
            Wraps <paramref name="pool"/> with <see cref="T:Eco.Shared.Pools.PoolService`1"/> with <paramref name="factory"/> for new pool elements and optional <paramref name="onReturn"/> cleanup method.
            With this factory method <code><![CDATA[new PoolService<MyClass>(new MyPool<MyClass>(), () => new MyClass("abc"))]]></code> can be rewritten as <code><![CDATA[new MyPool<MyClass>().AsService(() => new MyClass("abc"))]]></code>.
            </summary>
        </member>
        <member name="T:Eco.Shared.Pools.PooledMemoryStream">
            <summary>
            PooledMemoryStream (based on https://github.com/itn3000/PooledStream).
            It uses .NET Standard <see cref="T:System.Buffers.ArrayPool`1"/> for buffer allocations.
            Also it has <see cref="M:Eco.Shared.Pools.PooledMemoryStream.Truncate"/> which returns buffer to <see cref="T:System.Buffers.ArrayPool`1"/> and resets length, position and capacity to zero.
            It makes the stream reusable without holding extra memory for buffer.
            </summary>
        </member>
        <member name="M:Eco.Shared.Pools.PooledMemoryStream.GetBuffer">
            <summary>
            This buffer is only valid until next Write or Reset operation.
            </summary>
            <returns>current buffer.</returns>
        </member>
        <member name="T:Eco.Shared.Pools.PoolService`1">
            <summary>
            <see cref="T:Eco.Shared.Pools.IObjectPool`1"/> manager which simplifies pool usage, adding methods for automatic objects creation and cleaning up when returned to pool.
            When <see cref="T:Eco.Shared.Pools.PoolService`1"/> created you should provide <see cref="F:Eco.Shared.Pools.PoolService`1.factory"/> method for new object instantiation (if pool is empty) and optionally
            <see cref="F:Eco.Shared.Pools.PoolService`1.onReturn"/> method which will be called on an object when it returned (added) to pool.
            </summary>
        </member>
        <member name="M:Eco.Shared.Pools.PoolService`1.Rent">
            <summary> Rents object from pool or creates new instance using <see cref="F:Eco.Shared.Pools.PoolService`1.factory"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Pools.PoolService`1.Return(`0)">
            <summary>
            Returns (add) <paramref name="value"/> to the pool. If <see cref="F:Eco.Shared.Pools.PoolService`1.onReturn"/> method was provided then it will be called on <paramref name="value"/> <b>before</b> adding to pool.
            Also it may fail to add <paramref name="value"/> to <see cref="F:Eco.Shared.Pools.PoolService`1.pool"/> (in example if <see cref="F:Eco.Shared.Pools.PoolService`1.pool"/> is fixed size and already full).
            In this case <see cref="F:Eco.Shared.Pools.PoolService`1.onReturn"/> will be called anyway, but method return <c>false</c>. It returns <c>true</c> if object was actually added to pool, you can check return value for final object cleanup.
            </summary>
        </member>
        <member name="T:Eco.Shared.Pools.ThreadSafeFixedSizePool`1">
             <summary>
             Fixed Size Pool used to avoid any extra-GC allocations, unless requesting more items from pool than are available.
             It uses circular buffer where
             `tail` points to first element which will be retrieved from pool on request (read position)
             `head` points to next write position which will be used for returning element to pool (write position)
             when `head` == `tail` then buffer is empty
             when `head` == `tail - 1` then buffer is full
             we're using `poolSize + 1` for capacity to maintain full buffer scenario, because otherwise we can have two situations when write position == read position (empty and full).
            
             Performance:
             ~2x faster in concurrent environment than basic Stack based pool implementation with lock
             ~10% faster in single-thread environment than basic Stack based pool implementation with lock.
             </summary>
             <typeparam name="T"></typeparam>
        </member>
        <member name="P:Eco.Shared.Pools.ThreadSafeFixedSizePool`1.MaxSize">
            <summary>Max number of elements in the pool.</summary>
        </member>
        <member name="P:Eco.Shared.Pools.ThreadSafeFixedSizePool`1.Count">
            <inheritdoc cref="P:Eco.Shared.Pools.IObjectPool`1.Count"/>
        </member>
        <member name="M:Eco.Shared.Pools.ThreadSafeFixedSizePool`1.Get">
            <summary>
            Returns a object from the pool or null if no objects in the pool.
            </summary>
            <returns>object from the pool or a new object.</returns>
        </member>
        <member name="M:Eco.Shared.Pools.ThreadSafeFixedSizePool`1.TryAdd(`0)">
            <summary>
            Tries to add object to the pool (if enough capacity in the pool).
            </summary>
            <param name="obj"></param>
        </member>
        <member name="T:Eco.Shared.Pools.ThreadSafePool`1">
            <summary>
            Simple thread-safe <see cref="T:System.Collections.Generic.Stack`1"/> based pool implementation. It implements <see cref="T:Eco.Shared.Pools.IObjectPool`1"/> interface and has unlimited pool size.
            For optimal performance you should prefer thread-safe lock free <see cref="T:Eco.Shared.Pools.FixedSizePool`1"/>, but it has fixed pool size and can't be shrink or extended.
            </summary>
        </member>
        <member name="P:Eco.Shared.Pools.ThreadSafePool`1.Count">
            <inheritdoc cref="P:Eco.Shared.Pools.IObjectPool`1.Count"/>
        </member>
        <member name="M:Eco.Shared.Pools.ThreadSafePool`1.Get">
            <inheritdoc cref="M:Eco.Shared.Pools.IObjectPool`1.Get"/>
        </member>
        <member name="M:Eco.Shared.Pools.ThreadSafePool`1.TryAdd(`0)">
            <inheritdoc cref="M:Eco.Shared.Pools.IObjectPool`1.TryAdd(`0)"/>
        </member>
        <member name="T:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1">
            <summary>
            Thread-unsafe lock free <see cref="T:System.Collections.Generic.Stack`1"/> based pool implementation. It implements <see cref="T:Eco.Shared.Pools.IObjectPool`1"/> interface and has fixed pool size.
            You should prefer it to use over thread-safe pool implementations where you're sure it won't be used from multiple threads (in example in Unity components).
            </summary>
        </member>
        <member name="P:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.MaxSize">
            <summary>
            Max number of elements in pool.
            It actually may be less than actual number of elements if <see cref="P:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.MaxSize"/> was reduced when <see cref="P:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.Count"/> &gt; <see cref="P:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.MaxSize"/>.
            In this case it will not add objects with <see cref="M:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.TryAdd(`0)"/> until <see cref="P:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.Count"/> go below <see cref="P:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.MaxSize"/>.
            </summary>
        </member>
        <member name="P:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.Count">
            <inheritdoc cref="P:Eco.Shared.Pools.IObjectPool`1.Count"/>
        </member>
        <member name="M:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.Get">
            <inheritdoc cref="M:Eco.Shared.Pools.IObjectPool`1.Get"/>
        </member>
        <member name="M:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.TryAdd(`0)">
            <inheritdoc cref="M:Eco.Shared.Pools.IObjectPool`1.TryAdd(`0)"/>
        </member>
        <member name="T:Eco.Shared.Pools.ThreadUnsafePool`1">
            <summary>
            Thread-unsafe lock free <see cref="T:System.Collections.Generic.Stack`1"/> based pool implementation. It implements <see cref="T:Eco.Shared.Pools.IObjectPool`1"/> interface and has unlimited pool size.
            You should prefer it to use over thread-safe pool implementations where you're sure it won't be used from multiple threads (in example in Unity components).
            </summary>
        </member>
        <member name="P:Eco.Shared.Pools.ThreadUnsafePool`1.Count">
            <inheritdoc cref="P:Eco.Shared.Pools.IObjectPool`1.Count"/>
        </member>
        <member name="M:Eco.Shared.Pools.ThreadUnsafePool`1.Get">
            <inheritdoc cref="M:Eco.Shared.Pools.IObjectPool`1.Get"/>
        </member>
        <member name="M:Eco.Shared.Pools.ThreadUnsafePool`1.TryAdd(`0)">
            <inheritdoc cref="M:Eco.Shared.Pools.IObjectPool`1.TryAdd(`0)"/>
        </member>
        <member name="T:Eco.Shared.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Eco.Shared.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Eco.Shared.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BsonManipulator.ObjectTypeHandler(Eco.Shared.Serialization.BSONValue)">
            <summary> Unpacks object from <see cref="T:Eco.Shared.Serialization.BSONValue"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BsonManipulator.MakeGenericDictionarySerializer(System.Type)">
            <summary> Makes generic dictionary lightweight (no reflection) delegate which just converts first argument from non-generic to generic dictionary and passes all other arguments. </summary>
            todo: move to reflection utils
        </member>
        <member name="T:Eco.Shared.Serialization.SerializedAttribute">
            <summary> This symbol will be serialized to BSON for storage in the world file. </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.NoReferenceAttribute">
            <summary> Used in conjunction with SerializedAttribute to designate that a member needs to be fully saved, not using references. </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.UsesReferenceInHashCode">
            <summary> Used when a class needs references resolved before it can calculate its hashcode. </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.SerializedDerivedAttribute">
            <summary> Will be serialized to BSON for storage in the world file, and applies to all derived classes too. </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.ThreadSafeAttribute">
            <summary>
            When serializing some types, such as enumerables, the enumeration must not change - to enforce this, some designate "threadsafe" objects use this attribute, such as the immutable collections.
            When using this attribute manually, proper locking and other checks must be used the ensure thread safety - in general, use the ThreadSafe collections, but if you are SURE that your container
            is thread safe, go ahead and add this attribute.
            </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.SerializesTypeAttribute">
            <summary> Specify that this class serializes specific object types that might not otherwise be determined through reflection. </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.JsonUseAttribute">
            <summary>
            Overrides default strategy for ExpandableObjectContractResolver, it will use this attribute even if read-only and serializeReadOnlyProperties == false.
            </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.SharedBSONObject">
            <summary>
            Use this object if you have to share bson object.
            I.e. Player.animationData stored as shared object and then delivered to all clients.
            It keeps tracking of all object references and only recycle object when all references recycled.
            </summary>
        </member>
        <member name="P:Eco.Shared.Serialization.BSONValue.ValueTypeValue">
            Properties
        </member>
        <member name="F:Eco.Shared.Serialization.BSONObject.refs">
            <value> References count. </value>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryIncrementRef">
            <summary>
            Every time when you create a ref for shared BSONObject you have to increment ref.
            In this case it will be recycled only when last ref will be recycled.
            </summary>
            <returns><c>true</c> if ref was increased, <c>false</c> if ref can't be increased because of all existing refs was already recycled and this object is invalid.</returns>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryGetStringValue(System.String,System.String@)">
            <summary> Returns value for <paramref name="key"/> converted to <see cref="T:System.String"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryGetGuidValue(System.String,System.Guid@)">
            <summary> Returns value for <paramref name="key"/> converted to <see cref="T:System.Guid"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryGetInt32Value(System.String,System.Int32@)">
            <summary> Returns value for <paramref name="key"/> converted to <see cref="T:System.Int32"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryGetFloatValue(System.String,System.Single@)">
            <summary> Returns value for <paramref name="key"/> converted to <see cref="T:System.Single"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryGetDoubleValue(System.String,System.Double@)">
            <summary> Returns value for <paramref name="key"/> converted to <see cref="T:System.Double"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.SimpleBSON.DumpTo(System.IO.MemoryStream,Eco.Shared.Serialization.BSONArray)">
            <summary> Dumps BSON array to memory stream. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.SimpleBSON.DecodeLocString(System.IO.MemoryStream)">
            <summary> Decodes LocString from binary data. <see cref="M:Eco.Shared.Serialization.SimpleBSON.EncodeLocString(System.IO.MemoryStream,Eco.Shared.Localization.LocString)"/> about binary format details. </summary>
        </member>
        <member name="T:Eco.Shared.Streams.SubStream">
            <summary>
            Wrapper around existing stream which allows to use portion of stream without copying it to another stream.
            </summary>
        </member>
        <member name="P:Eco.Shared.Streams.SubStream.CanSeek">
            <summary>
             Not supported for now, but may be implemented.
            </summary>
        </member>
        <member name="T:Eco.Shared.Streams.BitWriter">
            <summary>
            This class provides functionally to write bit-wide values, tracking bitOffset (in opposite to byte-wide values for regular MemoryStream).
            </summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AddSection(Eco.Shared.Localization.LocString,Eco.Shared.Text.InfoBuilder)">
            <summary>
            Add a section.
            </summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AddSectionLoc(System.FormattableString,Eco.Shared.Text.InfoBuilder)">
            <summary>See <see cref="M:Eco.Shared.Text.InfoBuilder.AddSection(Eco.Shared.Localization.LocString,Eco.Shared.Text.InfoBuilder)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AddSectionLocStr(System.String,Eco.Shared.Text.InfoBuilder)">
            <summary>See <see cref="M:Eco.Shared.Text.InfoBuilder.AddSection(Eco.Shared.Localization.LocString,Eco.Shared.Text.InfoBuilder)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AppendLine">
            <summary> Appends new line to <see cref="T:Eco.Shared.Text.InfoBuilder"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AppendLine(Eco.Shared.Localization.LocString)">
            <summary> Appends <see cref="T:Eco.Shared.Localization.LocString"/> with new line to <see cref="T:Eco.Shared.Text.InfoBuilder"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AppendLineLoc(System.FormattableString)">
            <summary>See <see cref="M:Eco.Shared.Text.InfoBuilder.AppendLine(Eco.Shared.Localization.LocString)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AppendLineLocStr(System.String)">
            <summary>See <see cref="M:Eco.Shared.Text.InfoBuilder.AppendLine(Eco.Shared.Localization.LocString)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Threshold.DoubleThreshold.TryPass(System.Double)">
            <inheritdoc cref="M:Eco.Shared.Threshold.IThreshold`1.TryPass(`0)"/>
        </member>
        <member name="M:Eco.Shared.Threshold.DoubleThreshold.UpdateValue(System.Double@,System.Double)">
            <inheritdoc cref="M:Eco.Shared.Threshold.IThreshold`1.UpdateValue(`0@,`0)"/>
        </member>
        <member name="M:Eco.Shared.Threshold.DoubleThreshold.ClampValue(System.Double@,System.Double,System.Double,System.Double)">
            <inheritdoc cref="M:Eco.Shared.Threshold.IThreshold`1.ClampValue(`0@,`0,`0,`0)"/>
        </member>
        <member name="M:Eco.Shared.Threshold.FloatThreshold.TryPass(System.Single)">
            <inheritdoc cref="M:Eco.Shared.Threshold.IThreshold`1.TryPass(`0)"/>
        </member>
        <member name="M:Eco.Shared.Threshold.FloatThreshold.UpdateValue(System.Single@,System.Single)">
            <inheritdoc cref="M:Eco.Shared.Threshold.IThreshold`1.UpdateValue(`0@,`0)"/>
        </member>
        <member name="M:Eco.Shared.Threshold.FloatThreshold.ClampValue(System.Single@,System.Single,System.Single,System.Single)">
            <inheritdoc cref="M:Eco.Shared.Threshold.IThreshold`1.ClampValue(`0@,`0,`0,`0)"/>
        </member>
        <member name="T:Eco.Shared.Threshold.IThreshold`1">
            <summary>
            Threshold value interface. May be used to update value with threshold checking to avoid spamming value change events.
            </summary>
        </member>
        <member name="M:Eco.Shared.Threshold.IThreshold`1.TryPass(`0)">
            <summary>
            Try pass threshold with specified <paramref name="delta"/>. It will aggregate delta for multiple calls until the threshold reached then total delta value will reset.
            </summary>
            <param name="delta">delta between last value and new value.</param>
            <returns><c>true</c> if threshold passed with this (and all previous deltas), <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Eco.Shared.Threshold.IThreshold`1.UpdateValue(`0@,`0)">
            <summary> Updates <paramref name="value"/> to <paramref name="newValue"/>. It returns result of (see <see cref="M:Eco.Shared.Threshold.IThreshold`1.TryPass(`0)"/>) for delta between <paramref name="value"/> and <paramref name="newValue"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Threshold.IThreshold`1.ClampValue(`0@,`0,`0,`0)">
            <summary> It updates value as <see cref="M:Eco.Shared.Threshold.IThreshold`1.UpdateValue(`0@,`0)"/>, but also clamps it to specified range and if the value changed and <paramref name="newValue"/> on bounds then returns <c>true</c>. </summary>
        </member>
        <member name="T:Eco.Shared.Time.TimeLimit">
            <summary>Represents time limit which may be checked for expiration and overtime.</summary>
        </member>
        <member name="M:Eco.Shared.Time.TimeLimit.#ctor(System.Int64)">
            <summary>Creates <see cref="T:Eco.Shared.Time.TimeLimit"/> from <see cref="T:System.Diagnostics.Stopwatch"/> ticks (note they may be not same as <see cref="P:System.TimeSpan.Ticks"/>).</summary>
        </member>
        <member name="M:Eco.Shared.Time.TimeLimit.SubLimitFromTicks(System.Int64,System.Int64@)">
            <summary> Creates new limit with upper bound set to current limit. </summary>
            <param name="ticks">new limit ticks.</param>
            <param name="truncatedTicks">number of ticks truncated to match current limit.</param>
            <returns>new TimeLimit object.</returns>
        </member>
        <member name="T:Eco.Shared.Tools.PerformanceCounter">
            <summary>
            A PerformanceCounter is a collection of values with performance data for a single topic.
            Values will be grouped together under the PerformanceCounter name, but can optionally have text associated
            with them individually too.
            </summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounter.#ctor(System.String,System.Int32)">
            <summary>
            Create a PerformanceCounter with the maximum number of historical values stored.
            </summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounter.AddValue(System.String)">
            <summary> Add a value with an optional name. Call Dispose to end duration time, or use a using block.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounter.AddValue(System.TimeSpan,System.String)">
            <summary> Add a value with an optional name with known duration.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounter.AddMarker">
            <summary> Add an event marker, which is a durationless event.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounter.MinMaxAverage">
            <summary>
            Get the min, max, and average for the history of values.
            </summary>
        </member>
        <member name="T:Eco.Shared.Tools.PerformanceCounterValue">
            <summary>
            A single value for a performance counter.
            </summary>
        </member>
        <member name="T:Eco.Shared.Tools.PerformanceCounterValueRef">
            <summary> A reference to a single performance counter. </summary>
        </member>
        <member name="P:Eco.Shared.Tools.PerformanceCounterValueRef.IsCreated">
            <summary> Checks if ref was created. Will be <c>false</c> for default struct value. </summary>
        </member>
        <member name="T:Eco.Shared.Tools.PerformanceManager">
            <summary> Class for managing performance counters (<see cref="T:Eco.Shared.Tools.PerformanceCounter"/>) and producing performance reports. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.BidirectionalMap`2.TryGetValue(`0,`1@)">
            <summary> Tries to get <paramref name="val"/> by the <paramref name="key"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.BidirectionalMap`2.TryGetByValue(`1,`0@)">
            <summary> Tries to get <paramref name="key"/> by the <paramref name="val"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.BinaryWriterExtensions.EncodeZigZag(System.IO.BinaryWriter,System.UInt32)">
            <summary>
            Encodes <paramref name="value"/> to <paramref name="writer"/> using zig-zag encoding which minimizes number of bytes to represent the number.<br/>
            1. If the number below 128 then it just serialize it as single byte.<br/>
            2. Otherwise it will set the flag 0x80 for first byte, divide the number by 128 and repeat from step 1.<br/>
            In best case we have 1 byte (0-127).
            In worst case we have 5 bytes (the number &gt;268 435 456).
            </summary>
        </member>
        <member name="T:Eco.Shared.Utils.BinaryUtils">
            <summary> Utility methods to work with binary number representation. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.BinaryUtils.CountOfSetBits(System.Int32)">
            <summary> Counts set bits in a number. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.BinaryUtils.CountOfSetBits(System.UInt64)">
            <summary> Counts set bits in a number. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.BitReader">
            <summary>
            This class provides functionally to read bit-wide values, tracking <c>bitOffset</c> (in opposite to byte-wide values for regular <see cref="T:System.IO.MemoryStream"/> or byte array).
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.BitReader.BitReadBoolean(System.Byte[],System.Int32@)">
            <summary>
            Reads boolean from byte array using <c>bitPosition</c>. Boolean represented as single bit.
            </summary>
            <param name="buffer">byte array.</param>
            <param name="bitPosition">position in array in bits.</param>
            <returns>boolean value. <c>true</c> - if bit was 1, <c>false</c> - otherwise.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.BitReader.BitReadByte(System.Byte[],System.Int32@)">
            <summary>
            Reads a byte value from byte array using <c>bitPosition</c>. It may have offset within a byte.
            </summary>
            <param name="buffer">byte array.</param>
            <param name="bitPosition">position in array in bits.</param>
            <returns>byte value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.BitReader.BitReadUInt16(System.Byte[],System.Int32@)">
            <summary>
            Reads a ushort value from byte array using <c>bitPosition</c>. It may have offset within a byte.
            </summary>
            <param name="buffer">byte array.</param>
            <param name="bitPosition">position in array in bits.</param>
            <returns>ushort value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.BitReader.BitReadBytes(System.Byte[],System.Int32,System.Int32@)">
            <summary>
            Reads a byte array from a source byte array using <c>bitPosition</c>. It may have offset within a byte.
            </summary>
            <param name="buffer">source byte array.</param>
            <param name="length">number of bytes to read.</param>
            <param name="bitPosition">position in array in bits.</param>
            <returns>result byte array.</returns>
        </member>
        <member name="T:Eco.Shared.Utils.ByteArrayReader">
            <summary>
            Utility class to read structured data from byte array.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ByteArrayReader.ReadByte(System.Byte[],System.Int32@)">
            <summary>
            Read a byte from byte array using provided offset.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded byte value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.ByteArrayReader.ReadUInt32ZigZag(System.Byte[],System.Int32@)">
            <summary>
            Read a unsigned int from data array zig zag encoded.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded unsigned int value.</returns>
            <exception cref="T:System.Exception">if value can't be decoded from byte array.</exception>
        </member>
        <member name="M:Eco.Shared.Utils.ByteArrayReader.ReadInt16(System.Byte[],System.Int32@)">
            <summary>
            Read a short value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded short value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.ByteArrayReader.ReadInt32(System.Byte[],System.Int32@)">
            <summary>
            Read a int value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded int value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.ByteArrayReader.ReadInt64(System.Byte[],System.Int32@)">
            <summary>
            Read a long value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded long value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.ByteArrayReader.ReadUInt16(System.Byte[],System.Int32@)">
            <summary>
            Read a ushort value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded ushort value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.ByteArrayReader.ReadUInt32(System.Byte[],System.Int32@)">
            <summary>
            Read a uint value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded uint value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.ByteArrayReader.ReadDouble(System.Byte[],System.Int32@)">
            <summary>
            Read a double value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded double value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.ByteArrayReader.ReadVector3(System.Byte[],System.Int32@)">
            <summary>
            Read a vector3 value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded float value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.ByteArrayReader.ReadSingle(System.Byte[],System.Int32@)">
            <summary>
            Read a float value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded float value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.ByteArrayReader.ReadString(System.Byte[],System.Int32@)">
            <summary>
            [str len:zig zag uint][str:utf-8 encoded byte array]
            Reads a string from byte array using provided <c>offset</c>.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded string.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.ByteArrayReader.ReadBoolean(System.Byte[],System.Int32@)">
            <summary>
            [0 - false/1 - true:byte]
            Reads a boolean value from byte array using provided <c>offset</c>.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded boolean value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.ByteArrayReader.ReadGuid(System.Byte[],System.Int32@)">
            <summary>
            [guid:byte[16]]
            Reads a Guid from byte array using provided <c>offset</c>.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded Guid.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.ByteArrayReader.ReadIPEndPoint(System.Byte[],System.Int32@)">
            <summary>
            [address length:byte][address bytes:byte array][port:ushort]
            Reads a IP end point from byte array using provided <c>offset</c>.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded IP endpoint.</returns>
        </member>
        <member name="T:Eco.Shared.Utils.CommandLine">
             <summary>
             Class for getting arguments from command line. Arguments are not case sensitive.
            
             Excpected syntax of parameters:
             * -arg
             * -arg="value"
             * -arg.subarg="value"
             </summary>
        </member>
        <member name="M:Eco.Shared.Utils.CommandLine.GetValuelessArg(System.String)">
            <summary> Gets whether an argument is set or not. Not case sensitive. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.CommandLine.GetValueArg(System.String)">
            <summary> Gets the value for a given argument is set, null otherwise. Not case sensitive. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.RemoveFirst``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>Removes first item matching the <paramref name="matcher"/>. Returns <c>true</c> if item was removed.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.AddOrReplace``1(System.Collections.Generic.IList{``0},``0,System.Predicate{``0})">
            <summary>Replaces first element matching the <paramref name="matcher"/> with <paramref name="item"/> or adds new <paramref name="item"/> if no one matched.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.FirstOfTypeOrDefault``2(System.Collections.Generic.List{``0})">
            <summary> Returns first item of type <typeparam name="T"/> or default value if not found. It is a list specific implementation to avoid GC-allocations. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.Median``1(System.Collections.Generic.IList{``0},System.Boolean)">
            <summary> Returns median value for <paramref name="list"/>. If <paramref name="sorted"/> is <c>false</c> then it makes sorted copy of list to find the median otherwise it just returns medium element. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.DictionaryExtensions.TryRemove``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1@)">
            <summary> Replicates <see cref="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemove(`0,`1@)"/> for regular dictionary (handy way to get and remove value with one call). It isn't atomic like concurrent dictionary version though. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.DictionaryExtensions.AllValues``2(System.Collections.Generic.Dictionary{``0,``1},System.Predicate{``1})">
            <summary>
            Checks if all values in <paramref name="dict"/> matches <paramref name="predicate"/>.
            We are using explicit <see cref="T:System.Collections.Generic.Dictionary`2"/> here and don't use LINQ to avoid garbage creation for enumerator.
            We are using this method in Unity, so it is critical to not have extra GC-allocations.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.DictionaryExtensions.TryAdd``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary> Make Dictionary.TryAdd .NET Core 2.1 available in .NET Core 2.0. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.QueueExtensions.AddRange``1(System.Collections.Generic.Queue{``0},System.Collections.Generic.List{``0})">
            <summary>
            Optimized non-alloc version of <see cref="M:Eco.Shared.Utils.QueueExtensions.AddRange``1(System.Collections.Generic.Queue{``0},System.Collections.Generic.IEnumerable{``0})"/>.
            Because <see cref="M:System.Collections.Generic.List`1.GetEnumerator"/> returns struct <see cref="T:System.Collections.Generic.List`1.Enumerator"/>, but <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/> returns <see cref="T:System.Collections.Generic.IEnumerator`1"/> as boxed version of <see cref="T:System.Collections.Generic.List`1.Enumerator"/>.
            </summary>
            <param name="queue">destination queue.</param>
            <param name="list">list to add.</param>
            <typeparam name="T">item type.</typeparam>
        </member>
        <member name="M:Eco.Shared.Utils.QueueExtensions.TryDequeue``1(System.Collections.Generic.Queue{``0},``0@)">
            <summary> Make Queue.TryDequeue .NET Core 2.1 available in .NET Core 2.0. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.CollectionExtensions.ContainsAny``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary> Checks if <paramref name="source"/> collection contains any value from <paramref name="values"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.CollectionExtensions.AddNotNull``1(System.Collections.Generic.ICollection{``0},``0)">
            <summary>Adds element to <paramref name="collection"/> only if it isn't null. Returns <c>true</c> if element was added.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ArrayUtil.MakeNew``1(System.Int32)">
            <summary> Make an array and fill it with 'new'd entries. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.SetExtensions.First``1(System.Collections.Generic.HashSet{``0})">
            <summary> No alloc version of Enumerable.First() for HashSet. </summary>
            <exception cref="T:System.InvalidOperationException">If no elements in HashSet.</exception>
        </member>
        <member name="M:Eco.Shared.Utils.SetExtensions.MapGroupingKey``3(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{``0,``2}},System.Func{``0,``1})">
            <summary> Maps <see cref="T:System.Linq.IGrouping`2"/> key to new value (in example id may be resolved to name). </summary>
        </member>
        <member name="M:Eco.Shared.Utils.SetExtensions.IgnoreRepeats``1(System.Collections.Generic.IEnumerable{``0})">
            <summary> Returns the passed enumerable omitting any entries repeated in the sequence. Only checks sequential repeats, not list-wide repeats (like 'Distinct()' would).</summary>
        </member>
        <member name="T:Eco.Shared.Utils.DelegateWrapper`1">
            <summary>
            Intended to be used as base class for delegate wrapper which implements some interface.
            It implements equality operations and holds delegate references.
            It helps to avoid creating similar classes only differing by interface method implementation.
            </summary>
            <example>
            This sample shows how it may be used with <see cref="T:System.IComparable`1"/> interface.
            <code>
            class IntComparableWrapper : DelegateWrapper&lt;Func&lt;int, int&gt;&gt;, IComparable&lt;int&gt;
            {
               public IntComparableWrapper(Func&lt;int, int&gt; func) : base(func) { }
               int CompareTo(int value) => this.Delegate(value);
            }
            </code>
            </example>
        </member>
        <member name="T:Eco.Shared.Utils.DisposableUtils.DisposableActionEnumerator`1">
            Provides an enumerator which will execute an action when it is disposed (such as after a foreach loop)
        </member>
        <member name="F:Eco.Shared.Utils.EnumerableExtensions.CastMethods">
            <summary>Cache for <see cref="M:Eco.Shared.Utils.EnumerableExtensions.Cast(System.Collections.IEnumerable,System.Type)"/> method.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.AnyNotNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary> Checks if collection contains at least 1 not null element </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.ConcatNullSafe``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary> Same as <see cref="M:Eco.Shared.Utils.EnumerableExtensions.ConcatNullSafe``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>, but returns <c>null</c> if both are <c>null</c> and <paramref name="nullAllowed"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.ConcatNullSafe``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Concat two enumerable if possible (both not null). If any enum is null then it will be omitted from concatenation and only non-null enumerable elements will be returned.
            If both null then it will return empty enumerable.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.MinRange``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary> Returns up to <paramref name="n"/> minimal elements from <paramref name="enumerable"/>. From smallest to larger. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.Any``1(System.Collections.Generic.List{``0},System.Func{``0,System.Boolean})">
            <summary> Specialized version for <see cref="T:System.Collections.Generic.List`1"/>. No allocations. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.FirstOfTypeOrDefault``1(System.Collections.IList)">
            <summary> Returns first value in list of type <typeparamref name="T"/> or default value. No allocations. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.ForEach``3(System.Collections.Generic.Dictionary{``0,``1},``2,System.Action{System.Collections.Generic.KeyValuePair{``0,``1},``2})">
            <summary>
            Calls action for each entry with the context for a dictionary.
            </summary>
            <param name="dict">dictionary.</param>
            <param name="context">context.</param>
            <param name="action">action.</param>
            <typeparam name="TKey">key type.</typeparam>
            <typeparam name="TValue">value type.</typeparam>
            <typeparam name="TContext">context type.</typeparam>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.ForEach``3(System.Collections.Generic.IDictionary{``0,``1},``2,System.Action{System.Collections.Generic.KeyValuePair{``0,``1},``2})">
            <summary>
            Calls action for each entry with the context for a dictionary preferring no-alloc enumerator version (avoiding boxing).
            </summary>
            <param name="dict">dictionary.</param>
            <param name="context">context.</param>
            <param name="action">action.</param>
            <typeparam name="TKey">key type.</typeparam>
            <typeparam name="TValue">value type.</typeparam>
            <typeparam name="TContext">context type.</typeparam>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.ForEach``2(System.Collections.Generic.List{``0},``1,System.Action{``0,``1})">
            <summary>
            Calls action for each element with the context for a list.
            </summary>
            <param name="list">list.</param>
            <param name="context">context.</param>
            <param name="action">action.</param>
            <typeparam name="T">item type.</typeparam>
            <typeparam name="TContext">context type.</typeparam>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.ForEach``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,``1})">
            <summary>
            Calls action for each element with context preferring no-alloc enumerator version (avoiding boxing).
            </summary>
            <param name="enumerable">enumerable.</param>
            <param name="context">context.</param>
            <param name="action">action.</param>
            <typeparam name="T">item type.</typeparam>
            <typeparam name="TContext">context type.</typeparam>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.Median``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary> Returns median value for <paramref name="enumerable"/>. If <paramref name="sorted"/> is <c>false</c> then it makes sorted copy of enumerable to find the median otherwise it just returns medium element. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.ToDictionaryWithDistinctKeys``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary> Same as ToDictionary, but only adds entry with first distinct key. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.AsReadOnlyList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary> Represents enumerable as <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> avoiding copy creation if not necessary. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.Cast(System.Collections.IEnumerable,System.Type)">
            <summary>Casts <paramref name="enumerable"/> to <see cref="T:System.Collections.Generic.IEnumerable`1"/>. Is useful when you need to cast to specific runtime type, but can't use generic type arguments.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.FastMath">
            <summary>
            Fast but not so precise math, it uses approximation for expensive functions (like pow). It may vary in 5-10% of original value, but it may be OK for some scenarios.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.FastMath.FastAndDirtyPow(System.Double,System.Double)">
            <summary>
            Calculates fast and dirty power of value. In worst cases it may have error up-to 25% (for big power value), but usually within 5%-12%.
            It is faster than regular pow in 23 times for Java (didn't test for C#).
            More details here https://martin.ankerl.com/2007/10/04/optimized-pow-approximation-for-java-and-c-c/.
            </summary>
            <param name="value"></param>
            <param name="pow"></param>
            <returns></returns>
        </member>
        <member name="T:Eco.Shared.Utils.GlobalRandom">
            <remarks>
            Exposed implementation of Global Random from MoreLinq to be publicly available.
            <see cref="T:System.Random"/> is not thread-safe so the following
            implementation uses thread-local <see cref="T:System.Random"/>
            instances to create the illusion of a global
            <see cref="T:System.Random"/> implementation. For some background,
            see <a href="https://blogs.msdn.microsoft.com/pfxteam/2009/02/19/getting-random-numbers-in-a-thread-safe-way/">Getting
            random numbers in a thread-safe way</a>
            </remarks>
        </member>
        <member name="T:Eco.Shared.Utils.Grouping`2">
            <summary> Simple implementation of <see cref="T:System.Linq.IGrouping`2"/> which allows us to make grouping remapping (like resolving key to string or filtering elements). </summary>
        </member>
        <member name="T:Eco.Shared.Utils.IBidirectionalMap`2">
            <summary>Interface for bi-directional maps which allow to access key by value in addition to usual by key lookup.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.IBidirectionalMap`2.TryGetByValue(`1,`0@)">
            <summary>Lookups key by value.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.IBidirectionalMap`2.ContainsValue(`1)">
            <summary>Checks if value is in map.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.IBidirectionalMap`2.GetOrAdd(`0,System.Func{`1})">
            <summary>Gets value by key or adds new mapping if not exits. Value will be created with <paramref name="valueFactory"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.IBidirectionalMap`2.GetOrAdd(`0,`1)">
            <summary>Gets value by key or adds new mapping if not exits.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.ImmutableCountdown">
            <summary> An immutable timer that is sycned with the client and doesn't require ticks. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ImmutableCountdown.Create(System.Double,System.Double,System.Boolean)">
            <summary> Creates <see cref="T:Eco.Shared.Utils.ImmutableCountdown"/> either paused or running with <paramref name="duration"/> and <paramref name="timeLeft"/>. <paramref name="timeLeft"/> should be less or equal to duration. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.InterlockedUtils.TrySubNonNegative(System.Int32@,System.Int32)">
            <summary>
            Tries to subtract value from location. It only happen if location won't become negative (value &lt;= location).
            </summary>
            <param name="location">location to modify.</param>
            <param name="value">value to subtract.</param>
            <returns>true - if location >= value, location -= value; false - otherwise, location won't be modified.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.InterlockedUtils.SubMinNonNegative(System.Int32@,System.Int32)">
            <summary>
            Atomic operation to subtract `value` from `location`, or if value > location then subtract location (make it 0). It returns actual subtracted value.
            Basic formula: value > location ? location = 0, return old_location_value : location -= value, return value.
            </summary>
            <param name="location">location to change.</param>
            <param name="value">value to subtract.</param>
            <returns>subtracted value: min(location, value).</returns>
        </member>
        <member name="M:Eco.Shared.Utils.InterlockedUtils.SubMinNonNegative(System.Single@,System.Single)">
            <summary>
            Atomic operation to subtract `value` from `location`, or if value > location then subtract location (make it 0). It returns actual subtracted value.
            Basic formula: value > location ? location = 0, return old_location_value : location -= value, return value.
            </summary>
            <param name="location">location to change.</param>
            <param name="value">value to subtract.</param>
            <returns>subtracted value: min(location, value).</returns>
        </member>
        <member name="T:Eco.Shared.Utils.LockUtils.ExitReadLockOnDispose">
            <summary>
            Disposable structure which guarantees that <see cref="F:Eco.Shared.Utils.LockUtils.ExitReadLockOnDispose.rwLock"/> will exit read lock when <see cref="M:Eco.Shared.Utils.LockUtils.ExitReadLockOnDispose.Dispose"/> called. Handy when you wanna to use it with `using` pattern.
            We are not using something like <see cref="M:Eco.Shared.Utils.DisposableUtils.FromAction(System.Action)"/> because it creates new delegate every time what is bad both for performance and memory allocations.
            </summary>
        </member>
        <member name="T:Eco.Shared.Utils.LockUtils.ExitWriteLockOnDispose">
            <summary>
            Disposable structure which guarantees that <see cref="F:Eco.Shared.Utils.LockUtils.ExitWriteLockOnDispose.rwLock"/> will exit write lock when <see cref="M:Eco.Shared.Utils.LockUtils.ExitWriteLockOnDispose.Dispose"/> called. Handy when you wanna to use it with `using` pattern.
            We are not using something like <see cref="M:Eco.Shared.Utils.DisposableUtils.FromAction(System.Action)"/> because it creates new delegate every time what is bad both for performance and memory allocations.
            </summary>
        </member>
        <member name="T:Eco.Shared.Utils.LockUtils.ExitUpgradeableReadLockOnDispose">
            <summary>
            Disposable structure which guarantees that <see cref="F:Eco.Shared.Utils.LockUtils.ExitUpgradeableReadLockOnDispose.rwLock"/> will exit upgradeable read lock when <see cref="M:Eco.Shared.Utils.LockUtils.ExitUpgradeableReadLockOnDispose.Dispose"/> called. Handy when you wanna to use it with `using` pattern.
            We are not using something like <see cref="M:Eco.Shared.Utils.DisposableUtils.FromAction(System.Action)"/> because it creates new delegate every time what is bad both for performance and memory allocations.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.NormalizeAngleDeg(Eco.Shared.Math.Vector3,Eco.Shared.Math.Vector3,System.Single)">
            <summary> Find a normalized (-1 : 1) angle between two directions. Cuts angle higher than max angle </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.IsInCenter(Eco.Shared.Math.Vector3,Eco.Shared.Math.Vector3,Eco.Shared.Math.Vector3,Eco.Shared.Math.Vector3,System.Single)">
            <summary>
            Determine whether the point is in the center of a block
            </summary>
            <param name="size">Size of a block</param>
            <param name="normal">Normal vector of a hit point</param>
            <param name="scaledHit">Position of a hit point scaled to a size</param>
            <param name="centerSize">Size of center on a block (default is 65% of a half)</param>
            <param name="thinSize">Size of thin block</param>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.ClampDirectionAngleDeg(Eco.Shared.Math.Vector2,Eco.Shared.Math.Vector2,System.Single)">
            <summary> Returns a max possible angle between two vectors </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.ClampDirectionToOffsetDeg(Eco.Shared.Math.Vector2@,Eco.Shared.Math.Vector2@,Eco.Shared.Math.Vector2,Eco.Shared.Math.Vector2,Eco.Shared.Math.Vector2,System.Int32,System.Single,System.Single,System.Int32,System.Int32)">
            <summary> Function is finding new target and opposite directions in a curved way (lerping each step) </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.WeightedAverage(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Calculates average value between <paramref name="x"/> nad <paramref name="y"/> using value weights.
            Formula is following: <c>(x * xWeight + y * yWeight) / (xWeight + yWeight)</c>.
            </summary>
        </member>
        <member name="T:Eco.Shared.Utils.NullableExtensions">
            <summary> Extension methods for <see cref="T:System.Nullable`1"/> </summary>
        </member>
        <member name="M:Eco.Shared.Utils.NullableExtensions.TryGetValue``1(System.Nullable{``0},``0@)">
            <summary> Checks if <paramref name="nullable"/> has value and returns it as <paramref name="value"/> if has. Returns result of this check. It is thread-safe as it makes copy of <see cref="T:System.Nullable`1"/> struct. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.PathUtils">
            <summary>Home for <see cref="T:System.IO.Path"/> utility functions.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.PathUtils.SanitizeFileName(System.String)">
            <summary>Replaces all invalid file name characters with '_' and removes trailing '.' if exists.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.RandomCandidateChooser`1">
             <summary>
             Random Candidate Chooser from unknown size number of candidates.
             As soon as first candidate tested it will be auto-winner, but also it will randomly select next winner index and reset candidate counter.
             As soon as we have candidate with selected winner index it will replace previous winner and we select next winner index.
             It uses some adjustments to make replacement more often for low number of elements and less often as number of elements growth.
            
             This algorithm is adaptation of https://en.wikipedia.org/wiki/Reservoir_sampling for k = 1.
             </summary>
        </member>
        <member name="F:Eco.Shared.Utils.RandomCandidateChooser`1.weight">
            <summary> Next candidate weight. With lower value new candidate has lower chances to replace last Winner. </summary>
        </member>
        <member name="F:Eco.Shared.Utils.RandomCandidateChooser`1.nextWinnerIndex">
            <summary> Next winner index (zero-based). </summary>
        </member>
        <member name="F:Eco.Shared.Utils.RandomCandidateChooser`1.nextCandidateIndex">
            <summary> Next candidate (who will be tested) index. If it matches winner index then the candidate wins. Increased after each <see cref="M:Eco.Shared.Utils.RandomCandidateChooser`1.TestCandidate(`0)"/>.  </summary>
        </member>
        <member name="P:Eco.Shared.Utils.RandomCandidateChooser`1.Winner">
            <summary> Current winner. Should be selected by <see cref="M:Eco.Shared.Utils.RandomCandidateChooser`1.TestCandidate(`0)"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.RandomCandidateChooser`1.TestCandidate(`0)">
            <summary> Test the <paramref name="candidate"/> if it is the next winner. Updates <see cref="P:Eco.Shared.Utils.RandomCandidateChooser`1.Winner"/> if test succeed. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.RandomExtensions.Random(System.Random,Eco.Shared.Math.Vector2i)">
            <summary> Returns new <see cref="T:Eco.Shared.Math.Vector2i"/> with <c>x</c> greater or equal to <c>0</c> and less than <c>max.x</c>. Same for <c>y</c>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.RandomExtensions.Shuffle``1(System.Random,``0[])">
            <summary> Shuffles <paramref name="array"/> elements in-place in random order using <paramref name="random"/> generator. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.RandomUtil.Shuffle``1(``0[])">
            <summary> Shortcut for <see cref="M:Eco.Shared.Utils.RandomExtensions.Shuffle``1(System.Random,``0[])"/> with <see cref="P:Eco.Shared.Utils.RandomUtil.Global"/> randomizer. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.DerivedTypes(System.Type,System.Reflection.Assembly,System.Boolean)">
            <summary> Returns all derived types for <paramref name="baseType"/> optionally in specific <paramref name="assembly"/> and optionally (if <paramref name="includeSelf"/> set) returning the type itself. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.DerivedTypes(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Type,System.Boolean)">
            <summary> Returns all derived types for <paramref name="baseType"/> in <paramref name="assemblies"/> optionally (if <paramref name="includeSelf"/> set) returning the type itself. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.ConcreteTypesWithInteface(System.Type,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary> Returns all types that implements interface <paramref name="interfaceType"/>  </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.DerivedTypes(System.Reflection.Assembly,System.Type,System.Boolean)">
            <summary> Returns all derived types for <paramref name="baseType"/> in <paramref name="assembly"/> optionally (if <paramref name="includeSelf"/> set) returning the type itself. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.IsInheritFromGenericTypeDefinition(System.Type,System.Type)">
            <summary> Checks if any base class is generic type from generic type definition. </summary>
            <sample><code>EconomyManager.IsInheritFromGenericTypeDefinition(typeof(Singleton&lt;&gt;)) // true</code></sample>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.AllMembers(System.Type,System.Boolean)">
            <summary> Gets all properties, methods, and extension methods.  Operates either on instance members or static members based on passed bool. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.InNamespace(System.Type,System.String)">
            <summary> Checks if <paramref name="type"/> in <paramref name="namespace"/> (same or nested). </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.IsBackingField(System.Reflection.FieldInfo)">
            <summary> Checks if <paramref name="fieldInfo"/> is backing field (for auto-property). </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.CanAccess(System.Reflection.Assembly,System.Reflection.FieldInfo)">
            <summary>
            Checks if <paramref name="field"/> may be accessed (without reflection) from <paramref name="assembly"/>.
            It is possible in 3 cases:
            - field is "public";
            - field declared in the assembly;
            - field declared as "protected" or "protected internal" and field's owning type is in the assembly;
            <remarks>It currently doesn't support intermediate types through inheritance, i.e. in A (Assembly 1) : B (Assembly 2) : C (Assembly 3) if you check for Assembly 2 for A.field
            which is declared as protected in C then it will return false. Adding this check will make logic more complex and doesn't have practical usage for now.</remarks>
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.CanAccess(System.Reflection.Assembly,System.Reflection.MethodInfo)">
            <summary>
            Checks if <paramref name="method"/> may be accessed (without reflection) from <paramref name="assembly"/>.
            It is possible in 3 cases:
            - <paramref name="method"/> is "public";
            - <paramref name="method"/> declared in the <paramref name="assembly"/>;
            - <paramref name="method"/> declared as "protected" or "protected internal" and <paramref name="method"/>'s owning type is in the <paramref name="assembly"/>;
            <remarks>It currently doesn't support intermediate types through inheritance, i.e. in A (Assembly 1) : B (Assembly 2) : C (Assembly 3) if you check for Assembly 2 for A.Method
            which is declared as protected in C then it will return false. Adding this check will make logic more complex and doesn't have practical usage for now.</remarks>
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Text.SignedNum(System.Single,System.Boolean)">
            <summary> Returns styled number with forded sing ('+' - for positive, '-' - for negative, no sing for zero). If <paramref name="invertHighlight"/> set then it will use negative highlight for positive value. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Text.Truncate(System.String,System.Int32)">
            <summary> Cuts visible part of the content after provided width and replaces it with a hoverable link to see the origin. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Text.Columns(System.Int32,System.ValueTuple{System.String,System.Int32}[])">
            <summary> Aligns strings within blocks with specified widths. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.Singleton`1.Temp">
            <summary>
            Structure which used for temporary replaced singletons (for test purposes). It saves previous singleton object (usually null) and when disposed restores it.
            It may be preferred over <see cref="M:Eco.Shared.Utils.Singleton`1.WithTempSingleton``1(System.Action)"/>, because you may create this object in [SetUp] method and destroy in [TearDown] method
            allowing all tests to run with this temp singleton without explicitly wrapping them in WithTempSingleton call.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchExtensions.FractionalMilliseconds(System.Diagnostics.Stopwatch)">
            <summary>Returns milliseconds as fractional.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.StopwatchUtils">
            <summary> <see cref="T:System.Diagnostics.Stopwatch"/> utilities for high performance time measures. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchUtils.TicksFromMilliseconds(System.Int64)">
            <summary> Returns number of <see cref="P:System.Diagnostics.Stopwatch.ElapsedTicks"/> for <paramref name="milliseconds"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchUtils.TicksFromMilliseconds(System.Double)">
            <summary> Returns number of <see cref="P:System.Diagnostics.Stopwatch.ElapsedTicks"/> for <paramref name="milliseconds"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchUtils.TicksFromSeconds(System.Double)">
            <summary> Returns number of <see cref="P:System.Diagnostics.Stopwatch.ElapsedTicks"/> for <paramref name="seconds"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchUtils.TicksFromTimeSpan(System.TimeSpan)">
            <summary> Returns number of <see cref="P:System.Diagnostics.Stopwatch.ElapsedTicks"/> for <paramref name="timeSpan"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchUtils.MillisecondsFromTicks(System.Int64)">
            <summary> Returns number of milliseconds for <see cref="P:System.Diagnostics.Stopwatch.ElapsedTicks"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchUtils.SecondsFromTicks(System.Int64)">
            <summary> Returns number of seconds for <see cref="P:System.Diagnostics.Stopwatch.ElapsedTicks"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchUtils.TimeSpanFromTicks(System.Int64)">
            <summary> Returns <see cref="T:System.TimeSpan"/> for raw <see cref="T:System.Diagnostics.Stopwatch"/> ticks. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StreamExtensions.CopyOptimizedTo(System.IO.Stream,System.IO.Stream)">
            <summary>
            Optimized version of Stream.CopyTo trying to avoid memory allocations.
            </summary>
            <param name="source">source stream.</param>
            <param name="destination">destination stream.</param>
            <returns>number of bytes transferred.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.StreamExtensions.CopyOptimizedTo(System.IO.Stream,System.IO.Stream,System.Int64)">
            <summary>
            Optimized version of Stream.CopyTo trying to avoid memory allocations.
            </summary>
            <param name="source">source stream.</param>
            <param name="destination">destination stream.</param>
            <param name="bytesToCopy">number of bytes to copy.</param>
            <returns>number of bytes transferred.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.StringBuilderExtensions.Append(System.Text.StringBuilder,System.ReadOnlySpan{System.Char})">
            <summary> Backport of NetStandard 2.1+ StringBuilder.Append with <see cref="T:System.ReadOnlySpan`1"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.JoinSafe(Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString,System.String)">
            <summary>Join a string to another with a separator, if both are set.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.Strip(System.String,System.Char)">
            <summary>Strips character <paramref name="ch"/> from <paramref name="input"/> string.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.DescribeAmountLoc(System.Collections.Generic.IEnumerable{Eco.Shared.Localization.LocString},System.String)">
            <summary>  Version of <see cref="M:Eco.Shared.Utils.StringExtensions.DescribeAmount(System.Collections.Generic.IEnumerable{Eco.Shared.Localization.LocString},Eco.Shared.Localization.LocString)"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.DescribeAmount(System.Collections.Generic.IEnumerable{Eco.Shared.Localization.LocString},Eco.Shared.Localization.LocString)">
            <summary> Combines a set of lines into a foldout list. The link will be in format "description: linesCount". </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.CommaList(System.Collections.Generic.IEnumerable{Eco.Shared.Localization.LocString},Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString)">
            <summary>
            Creates comma separated list from <paramref name="phrases"/>.
            If input is empty then it will return <paramref name="noneText"/>.
            Otherwise it will return comma separated list prefixed with <paramref name="prefix"/> and suffixed with <paramref name="suffix"/>.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.TrimEndString(System.String,System.String)">
            <summary> Trim the end if it matches a string. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.IsSet(System.String)">
            <summary> Checks if string is not null and is not empty. Inverse of <see cref="M:System.String.IsNullOrEmpty(System.String)"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.AppendToBuilder(Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocStringBuilder@)">
            <summary> Avoid creating new builder if not needed </summary>
        </member>
        <member name="T:Eco.Shared.Utils.TagParser.CustomTagProcessor">
            <summary>Processing callback for custom tags.</summary>
            <param name="paramNamesToValues">Parameters of the tag and their values (see sample below). This dictionary will be used as parentAttrs for child tags. See how ProcessFoldoutMatch on client side looks for parameters that were added by its children.</param>
            <param name="content">&lt;someTag parameter="value"&gt;content&lt;/someTag&gt;</param>
            <param name="parentAttrs">paramNamesToValues of the parent tag. See how ProcessFoldoutTitle on the client side passes data to its parent foldout tag.</param>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.Parse(System.String)">
            <summary>Parses <paramref name="text"/> using registered custom processors and fixing any unclosed tags (defined to be auto-closed).</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.ReleaseBuilder(System.Text.StringBuilder)">
            <summary>Returns content of <paramref name="builder"/> and adds it back to the pool.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.TryParseClosingTag(System.ReadOnlySpan{System.Char},System.String@)">
            <summary>Tries parse <paramref name="tag"/> as closing and outputs it's <paramref name="name"/> if succeed.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.ParseAttributes(System.ReadOnlySpan{System.Char})">
            <summary>Parses parameters for the <paramref name="tag"/> as dictionary.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.HandleTag(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char}@,System.Collections.Generic.Dictionary{System.String,System.String},System.Text.StringBuilder,System.String@)">
            <summary>Handles <paramref name="tag"/> either as unknown tag or registered custom tag. For custom tags it will output <see cref="T:Eco.Shared.Utils.TagParser.CustomTagProcessor"/> result, for unknown tags it will add them as is to <paramref name="output"/>.</summary>
            <param name="tag">Contains tag to process.</param>
            <param name="unparsed">Contains unparsed value right after the <paramref name="tag"/>.</param>
            <param name="parentAttributes">Contains parent tag attributes dictionary (only if parent tag has custom tag processor). May be <c>null</c>.</param>
            <param name="output"><see cref="T:System.Text.StringBuilder"/> which should be used to write output (parsed) content.</param>
            <param name="unhandledCloseTag">If parsing was stopped at tag which is different than <paramref name="tag"/> then it considered as unhandled and will output in this parameter.</param>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.ParseContent(System.ReadOnlySpan{System.Char}@,System.Collections.Generic.Dictionary{System.String,System.String},System.Text.StringBuilder,System.String@)">
            <summary>Parses <paramref name="unparsed"/> content. Handles tags with <see cref="M:Eco.Shared.Utils.TagParser.HandleTag(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char}@,System.Collections.Generic.Dictionary{System.String,System.String},System.Text.StringBuilder,System.String@)"/> for every open tag, returns if found close tag and output it to <paramref name="unhandledCloseTag"/> and adds everything else to <paramref name="output"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.TryFindNextTag(System.ReadOnlySpan{System.Char},System.Int32@,System.Int32@)">
            <summary>Scans <paramref name="unparsed"/> content until first tag entry and outputs it's position in <paramref name="tagStart"/> and <paramref name="tagEnd"/> parameters if succeed. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.TagParserConfig">
            <summary> Config for <see cref="T:Eco.Shared.Utils.TagParser"/> which allows to add custom parsers and configure autocloseable tags. </summary>
        </member>
        <member name="F:Eco.Shared.Utils.TagParserConfig.TagNamesToCustomProcessors">
            <summary> Tag parser looks for a custom processor for every tag it finds. The tag and its content will be left as is if there is no custom processor for it.
            Otherwise, everything will be replaced with the result returned by the processor. </summary>
        </member>
        <member name="F:Eco.Shared.Utils.TagParserConfig.AutoCloseTags">
            <summary> Set of tags which should be automatically closed if no matching close tag was found. </summary>
        </member>
        <member name="T:Eco.Shared.Validation.PropertyValidationUtils">
            <summary>Utilities to work with ValidationAttribute. Could be used on client.</summary>
        </member>
        <member name="M:Eco.Shared.Validation.PropertyValidationUtils.ClampRangeFloatValues(System.Object)">
            <summary>Tries to fix all values to fit it's RangeAttribute's restrictions.</summary>
            <param name="propertyContainer">Iterates through propertyContainer properties with RangeAttribute set.</param>
            <returns>Returns true if object has invalid values and was modified</returns>
        </member>
        <member name="M:Eco.Shared.Validation.PropertyValidationUtils.ClampRangeFloatValue(System.Object,System.String)">
            <summary>Tests if object's property contains float RangeAttribute and tries to fix that. Produces error message if invalid object was found.</summary>
            <param name="propertyContainer">Object with given property</param>
            <param name="propertyName">Propery name to test</param>
            <returns>Returns true if object has invalid values and was modified</returns>
        </member>
        <member name="M:Eco.Shared.Validation.PropertyValidationUtils.GetPropertyFloatRange(System.Object,System.String)">
            <summary>Get object's given property float range restrictions. If it has not RangeAttribute of valid float values returns whole float range.</summary>
            <param name="propertyContainer">Object with given property</param>
            <param name="propertyName">Property name to test</param>
            <returns>Returns effective float range</returns>
        </member>
        <member name="T:Eco.Shared.View.IObservable">
            <summary>Interface for objects which may be subscribed (observed) for property changes.</summary>
        </member>
        <member name="T:Eco.Shared.View.IPropertySubscription">
            <summary>Interface for property change subscriptions. Holds information about observable subject, invocation target and method. May be invoked to notify subscription.</summary>
        </member>
        <member name="T:Eco.Shared.View.ISubscription">
            <summary>Interface for all subscription classes. May be either <see cref="T:Eco.Shared.View.Subscriptions"/> for subscriptions group or <see cref="T:Eco.Shared.View.IPropertySubscription"/>.</summary>
        </member>
        <member name="T:Eco.Shared.View.ISubscriptions">
            <summary>
            This is a replacement for IAnonymousSubscriber.
            This simplifies Subscription management, because you can use it with extension methods for easy subscription management.
            </summary>
        </member>
        <member name="T:Eco.Shared.View.NoOpPropertySubscription">
            <summary>
            No operation <see cref="T:Eco.Shared.View.PropertySubscription"/>. Will do nothing on callback.
            May be used as replacement for removed subscription during subscription list processing. I.e. we have list [sub1, sub2] and sub2 removed in sub1 callback.
            If we just remove it then list iteration will fail with <see cref="T:System.IndexOutOfRangeException"/> when accessing index 1 of removed sub2.
            To avoid this we can just replace removed subscription with <see cref="T:Eco.Shared.View.NoOpPropertySubscription"/> until list processing finish and then remove all no-op subscriptions from the list.
            </summary>
        </member>
        <member name="T:Eco.Shared.View.ObservableExtensions">
            <summary>Extension methods for <see cref="T:System.IObservable`1"/>.</summary>
        </member>
        <member name="T:Eco.Shared.View.PropertySubscription">
            <summary>Default property subscription implementation which works with provided subject, property name and callback.</summary>
        </member>
        <member name="T:Eco.Shared.View.PropertySubscriptionBase">
            <summary>Base class for all property subscriptions.</summary>
        </member>
        <member name="T:Eco.Shared.View.Subscriptions">
            <summary>
            Simple subscriptions collection which may be used for holding subset of subscriptions for class.
            It also may be used as ISubscription to keep sub-collection of subscriptions and unsubscribed together with main collection.
            </summary>
        </member>
        <member name="T:Eco.Shared.View.SubscriptionsExtensions">
            <summary>Extension methods for <see cref="T:Eco.Shared.View.ISubscriptions"/>.</summary>
        </member>
        <member name="F:Eco.Shared.View.SubscriptionsExtensions.CreatePropertySubscription">
            <summary>Function which creates IPropertySubscription, for server it will create ImmutablePropertySubscription instead of PropertySubscription, because it is thread-safe</summary>
        </member>
        <member name="M:Eco.Shared.View.SubscriptionsExtensions.UnsubscribeAll(Eco.Shared.View.ISubscriptions,System.Boolean)">
            <summary>
            Unsubscribes all previously added subscriptions and cleans subscription collection.
            </summary>
            <param name="ss">this ref.</param>
            <param name="release">by default Subscriptions list will be just cleared and then may be reused without recreation of list, but if Subscriptions won't be used anymore they may be released and returned to pool.</param>
        </member>
        <member name="M:Eco.Shared.View.SubscriptionsExtensions.UnsubscribeAllForSubject(Eco.Shared.View.ISubscriptions,Eco.Shared.View.IObservable)">
            <summary>
            Unsubscribe all subscriptions for given subject.
            </summary>
            <param name="ss">this ref.</param>
            <param name="subject">subject to unsubscribe.</param>
        </member>
        <member name="M:Eco.Shared.View.SubscriptionsExtensions.MakeNestedSubscriptions(Eco.Shared.View.ISubscriptions)">
            <summary> Makes nested subscriptions collection working as subset of <paramref name="ss"/>. It will be unsubscribed when <see cref="M:Eco.Shared.View.SubscriptionsExtensions.UnsubscribeAll(Eco.Shared.View.ISubscriptions,System.Boolean)"/> called on <paramref name="ss"/>, but may when <see cref="M:Eco.Shared.View.SubscriptionsExtensions.UnsubscribeAll(Eco.Shared.View.ISubscriptions,System.Boolean)"/> called on this it will only clear nested subscriptions. </summary>
        </member>
        <member name="M:Eco.Shared.View.SubscriptionsExtensions.TrySubscribe(Eco.Shared.View.ISubscriptions,Eco.Shared.View.IPropertySubscription)">
            <summary> Tries to add <paramref name="subscription"/> to <paramref name="ss"/>. Internally it subscribes on <see cref="P:Eco.Shared.View.IPropertySubscription.Subject"/>. If subscription already was added to same property with same callback then it will return <c>false</c> and won't add subscription. </summary>
        </member>
        <member name="F:Eco.Shared.View.View.NoOpSubscription">
            <summary> When a property callback removed during notifying the property. It will replace removed callback to avoid invoke on invalid subscription. </summary>
        </member>
        <member name="F:Eco.Shared.View.View.notifyTarget">
            <summary> Current notification target for <see cref="M:Eco.Shared.View.View.NotifyChanged(System.String)"/>. It may be used in methods like <see cref="M:Eco.Shared.View.View.Unsubscribe(Eco.Shared.View.IPropertySubscription)"/> which modifies the callbacks collection to prevent concurrent modifications. </summary>
        </member>
        <member name="M:Eco.Shared.View.View.HasData(Eco.Shared.View.View.ViewData)">
            <summary> Checks if view is holding <paramref name="data"/>. </summary>
        </member>
        <member name="M:Eco.Shared.View.View.MarkPropSubscribed(System.String)">
            <summary> Mark the prop as received, so we can verify access only occurs when its received.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.GetSubscriptions">
            <summary>Returns all registered property subscriptions. Don't use it for notify, just for inspection!</summary>
        </member>
        <member name="M:Eco.Shared.View.View.Unsubscribe(Eco.Shared.View.IPropertySubscription)">
            <summary> Removes <paramref name="subscription"/> from <see cref="F:Eco.Shared.View.View.changedCallbacks"/>. </summary>
        </member>
        <member name="M:Eco.Shared.View.View.RemovePropertyCallbacksIfEmpty(System.String,System.Collections.Generic.List{Eco.Shared.View.IPropertySubscription})">
            <summary>Checks if <paramref name="propertyCallbacks"/> collection is empty for <paramref name="propertyName"/> and removes it from registered property callbacks in this case.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.NotifyAll">
            <summary> Notifies all changed callbacks for all properties. Primarily intended for debugging. </summary>
        </member>
        <member name="M:Eco.Shared.View.View.DescribeSubscriptions(System.Text.StringBuilder,System.String)">
            <summary>Returns count of property subscriptions. Mostly for debugging purposes.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.SetFieldViewData``1(``0@,Eco.Shared.View.View)">
            <summary> Sets <paramref name="field"/>'s <see cref="T:Eco.Shared.View.View.ViewData"/> from <paramref name="view"/>. We need this method because of accessibility restrictions. </summary>
        </member>
        <member name="M:Eco.Shared.View.View.GetOrRecoverView(Eco.Shared.View.View.ViewData)">
            <summary> Exposes access to <see cref="M:Eco.Shared.View.ViewManager.GetOrRecoverView(Eco.Shared.View.View.ViewData)"/> from <see cref="T:Eco.Shared.View.View"/> derived classes. </summary>
        </member>
        <member name="M:Eco.Shared.View.View.Recover">
            <summary>
            Recovers <see cref="T:Eco.Shared.View.View"/> from <see cref="F:Eco.Shared.View.View.Data"/>.
            When original <see cref="T:Eco.Shared.View.View"/> was destroyed, but then a reference to it received from the server then it may need to perform some logic to correctly restore <see cref="T:Eco.Shared.View.View"/> from backup <see cref="F:Eco.Shared.View.View.Data"/>.
            </summary>
        </member>
        <member name="P:Eco.Shared.View.View.DebugName">
            <summary> Returns View name which may be used for debugging. </summary>
        </member>
        <member name="T:Eco.Shared.View.ViewManager">
            <summary> Manages Views on client. Read more details about View System in ViewSystem.md. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.GetOrRecoverView(Eco.Shared.View.View.ViewData)">
            <summary> Gets or recover <see cref="T:Eco.Shared.View.View"/> for <see cref="T:Eco.Shared.View.View.ViewData"/>. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.TryGetView(System.Int32,Eco.Shared.View.View@)">
            <summary>Try get <see cref="T:Eco.Shared.View.View"/> by id. It may not return view if it wasn't received or already released (has no active ref).</summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.CollectViewStats">
            <summary> Collect stats about existing views in <see cref="T:Eco.Shared.View.ViewManager"/>. May be used for statistic and leaks detection. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.CollectInvalidSubscriptions">
            <summary>Collects all invalid subscriptions. Invalid subscription is a <see cref="T:Eco.Shared.View.IPropertySubscription"/> which has <c>null</c> or destroyed target for an instance method (it is always <c>null</c> for static methods).</summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.TraceViewRefs(System.Int32)">
            <summary> Traces existing views for references to view with specified <paramref name="viewId"/>. It helps to debug why some view was added to the client and why it wasn't GC. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.SampleViewTraces(System.String,System.Int32,System.Int32)">
            <summary> Returns <see cref="T:Eco.Shared.Text.InfoBuilder"/> with traces for <paramref name="n"/> views of <paramref name="viewType"/> type (see <see cref="M:Eco.Shared.View.ViewManager.TraceViewRefs(System.Int32)"/>). Optionally it can skip firt <paramref name="skipN"/> elements. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.TraceViewRefs(Eco.Shared.View.View.ViewData)">
            <summary> Traces existing views for references to <paramref name="targetData"/>. It helps to debug why some view was added to the client and why it wasn't GC. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.TraceViewRefs(Eco.Shared.View.View.ViewData,System.Text.StringBuilder,System.Collections.Generic.HashSet{Eco.Shared.View.View.ViewData})">
            <summary> Internal recursive implementation of <see cref="M:Eco.Shared.View.ViewManager.TraceViewRefs(System.Int32)"/>. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.IsReferencingViewData(System.Object,Eco.Shared.View.View.ViewData)">
            <summary> Checks if <paramref name="value"/> either is <see cref="T:Eco.Shared.View.View"/> containing <paramref name="viewData"/> or collection one of each elements is such view. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.NotifyAllViews">
            <summary> Notifies all views about all subscribed properties changes. NOT INTENDED FOR PRODUCTION USAGE. ONLY FOR DEBUGGING! </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.ViewNotify(Eco.Shared.Serialization.BSONObject,Eco.Shared.View.View,System.Collections.Generic.List{Eco.Shared.View.ViewManager.ViewNotification})">
            <summary> Updates view property and adds property change notification to notifications list (if not null). </summary>
        </member>
        <member name="T:Eco.Shared.View.ApplyOnViewAttribute">
            <summary> Tag interfaces with this to make them add themselves when autogenning views. Useful for interfaces that are shared among server/client in shared code. </summary>
        </member>
        <member name="T:Eco.Shared.View.WeakPropertySubscription">
            <summary>// Weak reference wrapper class for delegate storage without user defined removal.</summary>
        </member>
        <member name="T:Eco.Shared.Voxel.Octree`1">
            <summary>
            Implements a cubic Octree.
            </summary>
            <remarks>
            An octree implemented over cubes indexed by integer values.  The tree will automatically grow to accommodate
            any added entries.  Optionally thread-safe.  Where ranges are used, they are interpreted as [min,max).
            </remarks>
            <typeparam name="T">The type of data to store in the tree.</typeparam>
        </member>
        <member name="M:Eco.Shared.Voxel.OctreeNode`1.Set(Eco.Shared.Math.Vector3i,`0)">
            <summary>
            Set the value at the specified position.
            </summary>
            <returns>True if a new value was added, false if a value was replaced.</returns>
        </member>
        <member name="T:Eco.Shared.Voxel.PlotUtil">
            <summary> Functions for translating to/from property plot coordinates. </summary>
        </member>
        <member name="M:Eco.Shared.Voxel.PlotUtil.GetPropertyPos(Eco.Shared.Math.Vector3i)">
            <summary> Returns World Position of the plot that contains provided position. </summary>
        </member>
        <member name="M:Eco.Shared.Voxel.PlotUtil.GetPropertyPos(Eco.Shared.Math.Vector2i)">
            <summary> Returns World Position of the plot that contains provided position. </summary>
        </member>
        <member name="M:Eco.Shared.Voxel.PlotUtil.GetPropertyPos(System.Int32,System.Int32)">
            <summary> Returns World Position of the plot that contains provided position. </summary>
        </member>
        <member name="M:Eco.Shared.Voxel.PlotUtil.PlotPosToWorldPos(Eco.Shared.Math.Vector2i)">
            <summary> Get the center World Position of a plot. </summary>
        </member>
        <member name="M:Eco.Shared.Voxel.PlotUtil.WorldPosToPlotPos(Eco.Shared.Math.Vector2i)">
            <summary> Gets the 'plot position' in the plot-grid from a World Position. NOTE: Do not get confused with GetPropertyPos(), which gets the rounded World Position of the plot provided. </summary>
        </member>
        <member name="M:Eco.Shared.Voxel.PlotUtil.DifferentPlots(Eco.Shared.Math.Vector2i,Eco.Shared.Math.Vector2i)">
            <summary> Determines if two positions are in the same plot. </summary>
        </member>
        <member name="M:Eco.Shared.Voxel.PlotUtil.NearestPlotPosInWorld(Eco.Shared.Math.Vector2i)">
            <summary> Returns World Position of the plot that contains provided position. </summary>
        </member>
        <member name="M:Eco.Shared.Voxel.PlotUtil.WorldPosCenterOfPlot(Eco.Shared.Math.Vector2i)">
            <summary> Take a position, find the plot of it, then find the center of that plot. </summary>
        </member>
        <member name="P:Eco.Shared.Voxel.PlotUtil.WorldPlotDims">
            <summary> Returns many plots exist in the x and z of world? </summary>
        </member>
        <member name="M:Eco.Shared.Voxel.PlotUtil.GetAllPropertyPos(Eco.Shared.Math.WorldRange)">
            <summary> Get the list of World Positions for each plot that this range overlaps. </summary>
        </member>
        <member name="M:Eco.Shared.Voxel.PlotUtil.GetAllPropertyPos(Eco.Shared.Math.Vector3i,Eco.Shared.Math.WorldRange)">
            <summary> Returns World Positions of plots that overlaps provided range around the position. </summary>
        </member>
        <member name="T:Eco.Shared.Voxel.World">
            <summary>
            Wrapper class around the static voxel grid that represents the world.
            Essentially this class exists so its easier to do WorldCache.SomeMethod() instead of WorldCache.Obj.SomeMethod().
            Gets ChunkViews from the ChunkGrid.
            Gets Blocks from Chunks from the ChunkGrid.
            </summary>
        </member>
        <member name="M:Eco.Shared.Voxel.World.ToChunkPosition(Eco.Shared.Math.WrappedWorldPosition3i)">
            <summary> Converts <see cref="T:Eco.Shared.Math.WrappedWorldPosition3i"/> to chunk position. </summary>
        </member>
        <member name="M:Eco.Shared.Voxel.World.ToLocalPosition(Eco.Shared.Math.Vector3i)">
            Warning: The coordinates are modulus/wrapping based on the chunk size, not relative to the chunk origin 
        </member>
        <member name="M:Eco.Shared.Voxel.World.ToLocalPosition(System.Int32,System.Int32,System.Int32)">
            Warning: The coordinates are modulus/wrapping based on the chunk size, not relative to the chunk origin 
        </member>
        <member name="M:Eco.Shared.Voxel.World.ToLocalPosition(Eco.Shared.Math.WrappedWorldPosition3i)">
            <summary> Returns local block position within chunk space. All chunks should be aligned to <see cref="F:Eco.Shared.Voxel.Chunk.Size"/>. Using <see cref="T:Eco.Shared.Math.WrappedWorldPosition3i"/> let us skip some check and use most optimized algorithm. </summary>
        </member>
        <member name="T:Microsoft.IO.RecyclableMemoryStream">
             <summary>
             MemoryStream implementation that deals with pooling and managing memory streams which use potentially large
             buffers.
             </summary>
             <remarks>
             This class works in tandem with the RecylableMemoryStreamManager to supply MemoryStream
             objects to callers, while avoiding these specific problems:
             1. LOH allocations - since all large buffers are pooled, they will never incur a Gen2 GC
             2. Memory waste - A standard memory stream doubles its size when it runs out of room. This
             leads to continual memory growth as each stream approaches the maximum allowed size.
             3. Memory copying - Each time a MemoryStream grows, all the bytes are copied into new buffers.
             This implementation only copies the bytes when GetBuffer is called.
             4. Memory fragmentation - By using homogeneous buffer sizes, it ensures that blocks of memory
             can be easily reused.
            
             The stream is implemented on top of a series of uniformly-sized blocks. As the stream's length grows,
             additional blocks are retrieved from the memory manager. It is these blocks that are pooled, not the stream
             object itself.
            
             The biggest wrinkle in this implementation is when GetBuffer() is called. This requires a single
             contiguous buffer. If only a single block is in use, then that block is returned. If multiple blocks
             are in use, we retrieve a larger buffer from the memory manager. These large buffers are also pooled,
             split by size--they are multiples of a chunk size (1 MB by default).
            
             Once a large buffer is assigned to the stream the blocks are NEVER again used for this stream. All operations take place on the
             large buffer. The large buffer can be replaced by a larger buffer from the pool as needed. All blocks and large buffers
             are maintained in the stream until the stream is disposed (unless AggressiveBufferReturn is enabled in the stream manager).
            
             </remarks>
        </member>
        <member name="F:Microsoft.IO.RecyclableMemoryStream.blocks">
            <summary>
            All of these blocks must be the same size.
            </summary>
        </member>
        <member name="F:Microsoft.IO.RecyclableMemoryStream.byteBuffer">
            <summary>
            This buffer exists so that WriteByte can forward all of its calls to Write
            without creating a new byte[] buffer on every call.
            </summary>
        </member>
        <member name="F:Microsoft.IO.RecyclableMemoryStream.dirtyBuffers">
            <summary>
            This list is used to store buffers once they're replaced by something larger.
            This is for the cases where you have users of this class that may hold onto the buffers longer
            than they should and you want to prevent race conditions which could corrupt the data.
            </summary>
        </member>
        <member name="F:Microsoft.IO.RecyclableMemoryStream.largeBuffer">
            <summary>
            This is only set by GetBuffer() if the necessary buffer is larger than a single block size, or on
            construction if the caller immediately requests a single large buffer.
            </summary>
            <remarks>If this field is non-null, it contains the concatenation of the bytes found in the individual
            blocks. Once it is created, this (or a larger) largeBuffer will be used for the life of the stream.
            </remarks>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.Id">
            <summary>
            Unique identifier for this stream across it's entire lifetime.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.Tag">
            <summary>
            A temporary identifier for the current usage of this stream.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.MemoryManager">
            <summary>
            Gets the memory manager being used by this stream.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.AllocationStack">
            <summary>
            Callstack of the constructor. It is only set if MemoryManager.GenerateCallStacks is true,
            which should only be in debugging situations.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.DisposeStack">
            <summary>
            Callstack of the Dispose call. It is only set if MemoryManager.GenerateCallStacks is true,
            which should only be in debugging situations.
            </summary>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.#ctor(Microsoft.IO.RecyclableMemoryStreamManager)">
            <summary>
            Allocate a new RecyclableMemoryStream object.
            </summary>
            <param name="memoryManager">The memory manager.</param>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.#ctor(Microsoft.IO.RecyclableMemoryStreamManager,System.String)">
            <summary>
            Allocate a new RecyclableMemoryStream object.
            </summary>
            <param name="memoryManager">The memory manager.</param>
            <param name="tag">A string identifying this stream for logging and debugging purposes.</param>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.#ctor(Microsoft.IO.RecyclableMemoryStreamManager,System.String,System.Int32)">
            <summary>
            Allocate a new RecyclableMemoryStream object.
            </summary>
            <param name="memoryManager">The memory manager.</param>
            <param name="tag">A string identifying this stream for logging and debugging purposes.</param>
            <param name="requestedSize">The initial requested size to prevent future allocations.</param>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.#ctor(Microsoft.IO.RecyclableMemoryStreamManager,System.String,System.Int32,System.Byte[])">
            <summary>
            Allocate a new RecyclableMemoryStream object.
            </summary>
            <param name="memoryManager">The memory manager.</param>
            <param name="tag">A string identifying this stream for logging and debugging purposes.</param>
            <param name="requestedSize">The initial requested size to prevent future allocations.</param>
            <param name="initialLargeBuffer">An initial buffer to use. This buffer will be owned by the stream and returned to the memory manager upon Dispose.</param>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.Dispose(System.Boolean)">
            <summary>
            Returns the memory used by this stream back to the pool.
            </summary>
            <param name="disposing">Whether we're disposing (true), or being called by the finalizer (false).</param>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.Close">
            <summary>
            Equivalent to Dispose.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.Capacity">
            <summary>
            Gets or sets the capacity.
            </summary>
            <remarks>Capacity is always in multiples of the memory manager's block size, unless
            the large buffer is in use.  Capacity never decreases during a stream's lifetime.
            Explicitly setting the capacity to a lower value than the current value will have no effect.
            This is because the buffers are all pooled by chunks and there's little reason to
            allow stream truncation.
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.Length">
            <summary>
            Gets the number of bytes written to this stream.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.Position">
            <summary>
            Gets the current position in the stream.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.CanRead">
            <summary>
            Whether the stream can currently read.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.CanSeek">
            <summary>
            Whether the stream can currently seek.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.CanTimeout">
            <summary>
            Always false.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.CanWrite">
            <summary>
            Whether the stream can currently write.
            </summary>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.GetBuffer">
            <summary>
            Returns a single buffer containing the contents of the stream.
            The buffer may be longer than the stream length.
            </summary>
            <returns>A byte[] buffer.</returns>
            <remarks>IMPORTANT: Doing a Write() after calling GetBuffer() invalidates the buffer. The old buffer is held onto
            until Dispose is called, but the next time GetBuffer() is called, a new buffer from the pool will be required.</remarks>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.ToArray">
            <summary>
            Returns a new array with a copy of the buffer's contents. You should almost certainly be using GetBuffer combined with the Length to
            access the bytes in this stream. Calling ToArray will destroy the benefits of pooled buffers, but it is included
            for the sake of completeness.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads from the current position into the provided buffer.
            </summary>
            <param name="buffer">Destination buffer.</param>
            <param name="offset">Offset into buffer at which to start placing the read bytes.</param>
            <param name="count">Number of bytes to read.</param>
            <returns>The number of bytes read.</returns>
            <exception cref="T:System.ArgumentNullException">buffer is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is less than 0.</exception>
            <exception cref="T:System.ArgumentException">offset subtracted from the buffer length is less than count.</exception>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.SafeRead(System.Byte[],System.Int32,System.Int32,System.Int32@)">
            <summary>
            Reads from the specified position into the provided buffer.
            </summary>
            <param name="buffer">Destination buffer.</param>
            <param name="offset">Offset into buffer at which to start placing the read bytes.</param>
            <param name="count">Number of bytes to read.</param>
            <param name="streamPosition">Position in the stream to start reading from.</param>
            <returns>The number of bytes read.</returns>
            <exception cref="T:System.ArgumentNullException">buffer is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is less than 0.</exception>
            <exception cref="T:System.ArgumentException">offset subtracted from the buffer length is less than count.</exception>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the buffer to the stream.
            </summary>
            <param name="buffer">Source buffer.</param>
            <param name="offset">Start position.</param>
            <param name="count">Number of bytes to write.</param>
            <exception cref="T:System.ArgumentNullException">buffer is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative.</exception>
            <exception cref="T:System.ArgumentException">buffer.Length - offset is not less than count.</exception>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.ToString">
            <summary>
            Returns a useful string for debugging. This should not normally be called in actual production code.
            </summary>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.WriteByte(System.Byte)">
            <summary>
            Writes a single byte to the current position in the stream.
            </summary>
            <param name="value">byte value to write.</param>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.ReadByte">
            <summary>
            Reads a single byte from the current position in the stream.
            </summary>
            <returns>The byte at the current position, or -1 if the position is at the end of the stream.</returns>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.SafeReadByte(System.Int32@)">
            <summary>
            Reads a single byte from the specified position in the stream.
            </summary>
            <param name="streamPosition">The position in the stream to read from.</param>
            <returns>The byte at the current position, or -1 if the position is at the end of the stream.</returns>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.SetLength(System.Int64)">
            <summary>
            Sets the length of the stream.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">value is negative or larger than MaxStreamLength.</exception>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position to the offset from the seek location.
            </summary>
            <param name="offset">How many bytes to move.</param>
            <param name="loc">From where.</param>
            <returns>The new position.</returns>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset is larger than MaxStreamLength.</exception>
            <exception cref="T:System.ArgumentException">Invalid seek origin.</exception>
            <exception cref="T:System.IO.IOException">Attempt to set negative position.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.WriteTo(System.IO.Stream)">
            <summary>
            Synchronously writes this stream's bytes to the parameter stream.
            </summary>
            <param name="stream">Destination stream.</param>
            <remarks>Important: This does a synchronous write, which may not be desired in some situations.</remarks>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.ReleaseLargeBuffer">
            <summary>
            Release the large buffer (either stores it for eventual release or returns it immediately).
            </summary>
        </member>
        <member name="T:Microsoft.IO.RecyclableMemoryStreamManager">
             <summary>
             Manages pools of RecyclableMemoryStream objects.
             </summary>
             <remarks>
             There are two pools managed in here. The small pool contains same-sized buffers that are handed to streams
             as they write more data.
            
             For scenarios that need to call GetBuffer(), the large pool contains buffers of various sizes, all
             multiples of LargeBufferMultiple (1 MB by default). They are split by size to avoid overly-wasteful buffer
             usage. There should be far fewer 8 MB buffers than 1 MB buffers, for example.
             </remarks>
        </member>
        <member name="F:Microsoft.IO.RecyclableMemoryStreamManager.largePools">
            <summary>
            pools[0] = 1x largeBufferMultiple buffers
            pools[1] = 2x largeBufferMultiple buffers
            etc., up to maximumBufferSize.
            </summary>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.#ctor">
            <summary>
            Initializes the memory manager with the default block/buffer specifications.
            </summary>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes the memory manager with the given block requiredSize.
            </summary>
            <param name="blockSize">Size of each block that is pooled. Must be > 0.</param>
            <param name="largeBufferMultiple">Each large buffer will be a multiple of this value.</param>
            <param name="maximumBufferSize">Buffers larger than this are not pooled.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">blockSize is not a positive number, or largeBufferMultiple is not a positive number, or maximumBufferSize is less than blockSize.</exception>
            <exception cref="T:System.ArgumentException">maximumBufferSize is not a multiple of largeBufferMultiple.</exception>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.BlockSize">
            <summary>
            The size of each block. It must be set at creation and cannot be changed.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.LargeBufferMultiple">
            <summary>
            All buffers are multiples of this number. It must be set at creation and cannot be changed.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.MaximumBufferSize">
            <summary>
            Gets or sets the maximum buffer size.
            </summary>
            <remarks>Any buffer that is returned to the pool that is larger than this will be
            discarded and garbage collected.</remarks>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.SmallPoolFreeSize">
            <summary>
            Number of bytes in small pool not currently in use.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.SmallPoolInUseSize">
            <summary>
            Number of bytes currently in use by stream from the small pool.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.LargePoolFreeSize">
            <summary>
            Number of bytes in large pool not currently in use.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.LargePoolInUseSize">
            <summary>
            Number of bytes currently in use by streams from the large pool.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.SmallBlocksFree">
            <summary>
            How many blocks are in the small pool.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.LargeBuffersFree">
            <summary>
            How many buffers are in the large pool.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.MaximumFreeSmallPoolBytes">
            <summary>
            How many bytes of small free blocks to allow before we start dropping
            those returned to us.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.MaximumFreeLargePoolBytes">
            <summary>
            How many bytes of large free buffers to allow before we start dropping
            those returned to us.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.MaximumStreamCapacity">
            <summary>
            Maximum stream capacity in bytes. Attempts to set a larger capacity will
            result in an exception.
            </summary>
            <remarks>A value of 0 indicates no limit.</remarks>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.GenerateCallStacks">
            <summary>
            Whether to save callstacks for stream allocations. This can help in debugging.
            It should NEVER be turned on generally in production.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.AggressiveBufferReturn">
            <summary>
            Whether dirty buffers can be immediately returned to the buffer pool. E.g. when GetBuffer() is called on
            a stream and creates a single large buffer, if this setting is enabled, the other blocks will be returned
            to the buffer pool immediately.
            Note when enabling this setting that the user is responsible for ensuring that any buffer previously
            retrieved from a stream which is subsequently modified is not used after modification (as it may no longer
            be valid).
            </summary>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.GetBlock">
            <summary>
            Removes and returns a single block from the pool.
            </summary>
            <returns>A byte[] array.</returns>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.GetLargeBuffer(System.Int32,System.String)">
            <summary>
            Returns a buffer of arbitrary size from the large buffer pool. This buffer
            will be at least the requiredSize and always be a multiple of largeBufferMultiple.
            </summary>
            <param name="requiredSize">The minimum length of the buffer.</param>
            <param name="tag">The tag of the stream returning this buffer, for logging if necessary.</param>
            <returns>A buffer of at least the required size.</returns>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.ReturnLargeBuffer(System.Byte[],System.String)">
            <summary>
            Returns the buffer to the large pool.
            </summary>
            <param name="buffer">The buffer to return.</param>
            <param name="tag">The tag of the stream returning this buffer, for logging if necessary.</param>
            <exception cref="T:System.ArgumentNullException">buffer is null.</exception>
            <exception cref="T:System.ArgumentException">buffer.Length is not a multiple of LargeBufferMultiple (it did not originate from this pool).</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.ReturnBlocks(System.Collections.Generic.ICollection{System.Byte[]},System.String)">
            <summary>
            Returns the blocks to the pool.
            </summary>
            <param name="blocks">Collection of blocks to return to the pool.</param>
            <param name="tag">The tag of the stream returning these blocks, for logging if necessary.</param>
            <exception cref="T:System.ArgumentNullException">blocks is null.</exception>
            <exception cref="T:System.ArgumentException">blocks contains buffers that are the wrong size (or null) for this memory manager.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.GetStream">
            <summary>
            Retrieve a new MemoryStream object with no tag and a default initial capacity.
            </summary>
            <returns>A MemoryStream.</returns>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.GetStream(System.String)">
            <summary>
            Retrieve a new MemoryStream object with the given tag and a default initial capacity.
            </summary>
            <param name="tag">A tag which can be used to track the source of the stream.</param>
            <returns>A MemoryStream.</returns>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.GetStream(System.String,System.Int32)">
            <summary>
            Retrieve a new MemoryStream object with the given tag and at least the given capacity.
            </summary>
            <param name="tag">A tag which can be used to track the source of the stream.</param>
            <param name="requiredSize">The minimum desired capacity for the stream.</param>
            <returns>A MemoryStream.</returns>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.GetStream(System.String,System.Int32,System.Boolean)">
            <summary>
            Retrieve a new MemoryStream object with the given tag and at least the given capacity, possibly using
            a single contiguous underlying buffer.
            </summary>
            <remarks>Retrieving a MemoryStream which provides a single contiguous buffer can be useful in situations
            where the initial size is known and it is desirable to avoid copying data between the smaller underlying
            buffers to a single large one. This is most helpful when you know that you will always call GetBuffer
            on the underlying stream.</remarks>
            <param name="tag">A tag which can be used to track the source of the stream.</param>
            <param name="requiredSize">The minimum desired capacity for the stream.</param>
            <param name="asContiguousBuffer">Whether to attempt to use a single contiguous buffer.</param>
            <returns>A MemoryStream.</returns>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.GetStream(System.String,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Retrieve a new MemoryStream object with the given tag and with contents copied from the provided
            buffer. The provided buffer is not wrapped or used after construction.
            </summary>
            <remarks>The new stream's position is set to the beginning of the stream when returned.</remarks>
            <param name="tag">A tag which can be used to track the source of the stream.</param>
            <param name="buffer">The byte buffer to copy data from.</param>
            <param name="offset">The offset from the start of the buffer to copy from.</param>
            <param name="count">The number of bytes to copy from the buffer.</param>
            <returns>A MemoryStream.</returns>
        </member>
    </members>
</doc>
