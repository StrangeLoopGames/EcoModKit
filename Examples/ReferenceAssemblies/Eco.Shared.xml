<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Eco.Shared</name>
    </assembly>
    <members>
        <member name="T:Eco.Shared.Authentication.AuthResult">
            <summary>
            A mirror of AuthSucceedResult and AuthFailedResult from AuthServer combined
            </summary>
        </member>
        <member name="T:Eco.Shared.Authentication.IDevAuthenticate">
            <summary>Services to authenticate by <see cref="T:Eco.Shared.Authentication.DevAuthentication"/></summary>
        </member>
        <member name="T:Eco.Shared.Authentication.DevAuthentication">
            <summary>Dev users authenticator for <see cref="T:Eco.Shared.Authentication.IDevAuthenticate"/></summary>
            services that can't be accessible to normal users, but need to be avaible for devs in any environment (debug or release)
            e.g.: some QA options will only be available with successful auth
        </member>
        <member name="M:Eco.Shared.Authentication.DevAuthentication.GetCredentials">
            <summary>Collect login and password if any</summary>
        </member>
        <member name="M:Eco.Shared.Authentication.DevAuthentication.AuthCredentials">
            <summary>Authenticates user credentials</summary>
            <returns>Authentication succeded or not</returns>
        </member>
        <member name="M:Eco.Shared.Authentication.DevAuthentication.ValidadeSession(Eco.Shared.Authentication.LoginSession)">
            <summary>Validates login session, token and dev tier</summary>
            <param name="session">session to validade</param>
        </member>
        <member name="M:Eco.Shared.Authentication.DevAuthentication.Authenticate">
            <summary>Authenticates all services <see cref="T:Eco.Shared.Authentication.IDevAuthenticate"/></summary>
        </member>
        <member name="T:Eco.Shared.Authentication.AccountTiers">
            <summary> Key account tiers from the accounts database. There are multiple versions of tiers so use >= to compare for a specific tier. </summary>
        </member>
        <member name="T:Eco.Shared.Authentication.VoiceJoinTokenRequest">
            <summary>
            Used to group together voice paramters when requesting a token.
            </summary>
        </member>
        <member name="T:Eco.Shared.Blueprints.Blueprint">
            <summary>
            A combination of blocks to be placed or modified.
            </summary>
        </member>
        <member name="M:Eco.Shared.Blueprints.Blueprint.SetValue(Eco.Shared.Math.Vector3i,System.UInt16)">
            <summary> Set the block ID of a relative position, overwriting any existing block ID. </summary>
        </member>
        <member name="M:Eco.Shared.Blueprints.Blueprint.RemoveValue(Eco.Shared.Math.Vector3i)">
            <summary> Clear the block from the given position if it is set.</summary>
        </member>
        <member name="M:Eco.Shared.Blueprints.Blueprint.TryGetValue(Eco.Shared.Math.Vector3i,System.UInt16@)">
            <summary> Gets the block ID for the given position if it exists. </summary>
        </member>
        <member name="M:Eco.Shared.Blueprints.Blueprint.Clear">
            <summary> Clear all block IDs from the blueprint. </summary>
        </member>
        <member name="M:Eco.Shared.Blueprints.Blueprint.GetEnumerator">
            <summary> Gets a enumerator of all the set block IDs with their positions. </summary>
        </member>
        <member name="M:Eco.Shared.Blueprints.Blueprint.System#Collections#IEnumerable#GetEnumerator">
            <summary> Gets a enumerator of all the set block IDs with their positions. </summary>
        </member>
        <member name="M:Eco.Shared.Blueprints.Blueprint.SetFromRangeAndBlockId(System.Collections.Generic.IEnumerable{Eco.Shared.Math.Vector3i},System.UInt16)">
            <summary> Sets the blueprint to all the blocks of the range, relative to WorldRange.min, set to the given block ID. </summary>
        </member>
        <member name="T:Eco.Shared.Blueprints.BlueprintBlock">
            <summary>
            A block from a blueprint, consisting of a position and a block ID.
            </summary>
        </member>
        <member name="T:Eco.Shared.Blueprints.BlueprintInstance">
            <summary>
            An instance of a blueprint in the world, given a blueprint and a world position.
            </summary>
        </member>
        <member name="M:Eco.Shared.Blueprints.BlueprintInstance.TryGetValue(Eco.Shared.Math.Vector3i,System.UInt16@)">
            <summary> Gets the block ID from the bluprint relative to the world position of the instance. </summary>
        </member>
        <member name="M:Eco.Shared.Blueprints.BlueprintInstance.GetEnumerator">
            <summary> Gets a enumerator of all the set block IDs with their world positions. </summary>
        </member>
        <member name="M:Eco.Shared.Blueprints.BlueprintInstance.System#Collections#IEnumerable#GetEnumerator">
            <summary> Gets a enumerator of all the set block IDs with their world positions. </summary>
        </member>
        <member name="T:Eco.Shared.Collections.BatchedSet`1">
            <summary>
            Batched queue which allows to process queued objects by batches of max size <see cref="F:Eco.Shared.Collections.BatchedSet`1.batchSize"/>.
            It should be provided with <see cref="F:Eco.Shared.Collections.BatchedSet`1.fetcher"/> which will perform fetching of new objects to the queue either incremental or with full re-fetch way.
            In case of full re-fetch it will replace current queue content with new data. For incremental fetch it will add fetched items to end of the queue.
            You can use <see cref="M:Eco.Shared.Collections.BatchedSet`1.Fetch(System.Boolean)"/> and <see cref="M:Eco.Shared.Collections.BatchedSet`1.GetNextBatch"/> separate or you can use <see cref="M:Eco.Shared.Collections.BatchedSet`1.FetchNextBatch(System.Boolean)"/> which combines these two methods calls.
            This class isn't thread-safe!
            </summary>
        </member>
        <member name="M:Eco.Shared.Collections.BatchedSet`1.FetchNextBatch(System.Boolean)">
            <summary> Combines call to <see cref="M:Eco.Shared.Collections.BatchedSet`1.Fetch(System.Boolean)"/> and <see cref="M:Eco.Shared.Collections.BatchedSet`1.GetNextBatch"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Collections.BatchedSet`1.GetNextBatch">
            <summary> Returns next batch of max size <see cref="F:Eco.Shared.Collections.BatchedSet`1.batchSize"/> from pre-fetched objects. </summary>
        </member>
        <member name="M:Eco.Shared.Collections.BatchedSet`1.Fetch(System.Boolean)">
            <summary>
            Fetches data using <see cref="F:Eco.Shared.Collections.BatchedSet`1.fetcher"/> and adds it to end of the queue.
            If <paramref name="incremental"/> is <c>false</c> then it will clear the queue and replace it with fetched data.
            </summary>
        </member>
        <member name="T:Eco.Shared.Collections.EquatableArray`1">
            <summary>Equatable Array is a way to create equatable version of array which may be used as Dictionary key or for other hash/equals aware collections or operations.</summary>
        </member>
        <member name="T:Eco.Shared.Collections.RandomAccessQueue`1">
            <summary>
            RandomAccessQueue class is re-implementation of standard .NET Queue class, but with few additions for random access:
            <see cref="M:Eco.Shared.Collections.RandomAccessQueue`1.Remove(`0)"/> allows to remove element from queue (for standard queue you can only remove first element with Dequeue)
            <see cref="M:Eco.Shared.Collections.RandomAccessQueue`1.EnqueueFirst(`0)"/> allows to add element at beginning of queue (not possible in standard queue).
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.Enqueue(`0)">
            <summary>
            Add element to the end of queue.
            </summary>
            <param name="el">element to add.</param>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.EnqueueFirst(`0)">
            <summary>
            Add element before first element in the queue.
            </summary>
            <param name="el">element to add.</param>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.Dequeue">
            <summary>
            Remove and return first element from queue.
            </summary>
            <returns>First element in queue.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if queue is empty.</exception>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.TryDequeue(`0@)">
            <summary>
            Tries to <see cref="M:Eco.Shared.Collections.RandomAccessQueue`1.Dequeue"/> element from queue. Safe version which returns <c>false</c> if no element instead of throwing exception.
            </summary>
            <param name="value">first element of queue if operation succeed, default value otherwise.</param>
            <returns><code>true</code> if element exists and outputted in <c>value</c>.</returns>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.DequeueLast">
            <summary>
            Remove and return last element from queue.
            </summary>
            <returns>Last element in queue.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if queue is empty.</exception>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.TryDequeueLast(`0@)">
            <summary>
            Tries to <see cref="M:Eco.Shared.Collections.RandomAccessQueue`1.DequeueLast"/> element from queue. Safe version which returns <c>false</c> if no element instead of throwing exception.
            </summary>
            <param name="value">last element of queue if operation succeed, default value otherwise.</param>
            <returns><code>true</code> if element exists and outputted in <c>value</c>.</returns>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.TryPeek(`0@)">
            <summary>Tries to Peek next element without dequeing it from the colletions.</summary>
            <returns><code>true</code> if collection is not empty, false otherwise</returns>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.TryPeekLast(`0@)">
            <summary>Tries to Peek the last element without dequeing it from the colletions.</summary>
            <returns><code>true</code> if collection is not empty, false otherwise</returns>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.Contains(`0)">
            <summary>Performs search of given item in the collection.</summary>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.Requeue">
            <summary>Requeue (take next element and put it back in the end of the queue) the next element and returns it</summary>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.Reverse">
            <summary>Zero allocation and much faster alternative to <see cref="M:System.Linq.Enumerable.Reverse``1(System.Collections.Generic.IEnumerable{``0})"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Collections.RandomAccessQueue`1.ReverseEnumerable">
            <summary>Reverse view of <see cref="T:Eco.Shared.Collections.RandomAccessQueue`1"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Collections.RandomAccessQueue`1.ReverseEnumerator">
            <summary>Reverse enumerator of <see cref="T:Eco.Shared.Collections.RandomAccessQueue`1"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Collections.UnboundedSPSCQueue`1">
            <summary>
            Unbounded Single Producer Single Consumer Queue.
            </summary>
            <remarks>
            It is safe to use in multi-threaded environment as long as only one thread is consuming and only one thead is producing.
            It may lead to unpredictable results otherwise.
            </remarks>
        </member>
        <member name="T:Eco.Shared.Collections.UniqueStack`1">
            <summary> Thread-unsafe Unique Stack implementation. It only allows to put unique elements. </summary>
        </member>
        <member name="M:Eco.Shared.Collections.UniqueStack`1.Push(`0)">
            <summary> Push new item . Item ignored if already present in stack and method returns false in this case. </summary>
        </member>
        <member name="M:Eco.Shared.Collections.UniqueStack`1.TryPop(`0@)">
            <summary> Tries to pop item from the stack (if any). Returns <c>true</c> and item output parameter, <c>false</c> otherwise. </summary>
        </member>
        <member name="M:Eco.Shared.Collections.UniqueStack`1.Clear">
            <summary> Clears whole stack. </summary>
        </member>
        <member name="T:Eco.Shared.Comparers.FuncBasedEqualityComparer`1">
            <summary><see cref="T:System.Collections.Generic.IEqualityComparer`1"/> based on provided equality and hash functions. Useful when API only supports <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>, but you want to use lambda functions.</summary>
        </member>
        <member name="T:Eco.Shared.Concurrent.ConcurrentFlag">
            <summary>
            This class is implementation of thread-safe flag which can be atomically set to <c>true</c> with <see cref="M:Eco.Shared.Concurrent.ConcurrentFlag.TrySet"/> method.
            Once set the owning thread is responsible for call to <see cref="M:Eco.Shared.Concurrent.ConcurrentFlag.Reset"/> method with returns value to <c>false</c> if needed.
            If this flag used as publicly available property then ensure it exposed as <c>ref ConcurrentFlag Flag => ref this.flag</c> to avoid accidental struct copy
            (in this case it will modify state of copy, not of the original flag).
            </summary>
            <example>
            Typical usage is following:
            <code>
            ConcurrentFlag doingSomething;
            void DoSomething()
            {
                if (!doingSomething.TrySet())
                    return;
                Something();
                doingSomething.Reset();
            }
            </code>
            It is replacement for boolean flag, but with thread-safety support. Equivalent non thread-safe code will look like:
            <code>
            bool doingSomething;
            void DoSomething()
            {
                if (!doingSomething)
                    return;
                doingSomething = true;  // for multi-thread this flag may be already set by another thread here even if it wasn't in previous condition check
                Something();
                doingSomething = false;
            }
            </code>
            </example>
        </member>
        <member name="M:Eco.Shared.Concurrent.ConcurrentFlag.TrySet">
            <summary>Tries atomically set flag. If this flag already set by another thread then the method returns <c>false</c>.</summary>
        </member>
        <member name="M:Eco.Shared.Concurrent.ConcurrentFlag.Reset">
            <summary>Resets flag to not set state. Should be called after successful <see cref="M:Eco.Shared.Concurrent.ConcurrentFlag.TrySet"/> method if needed to make this flag available to be set again.</summary>
        </member>
        <member name="T:Eco.Shared.Extensions.ReadOnlySpanExtensions">
            <summary>Set of extension methods for <see cref="T:System.ReadOnlySpan`1"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Extensions.ReadOnlySpanExtensions.ToSet``1(System.ReadOnlySpan{``0})">
            <summary>Returns new <see cref="T:System.Collections.Generic.HashSet`1"/> containing all items from <paramref name="span"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Extensions.ReadOnlySpanExtensions.ToList``1(System.ReadOnlySpan{``0})">
            <summary>Returns new <see cref="T:System.Collections.Generic.List`1"/> containing all items from <paramref name="span"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Gameplay.MapEntryOverlay">
            Basic implementation for IEntryOverlay. Used to sent/recieve data at map edit request
        </member>
        <member name="M:Eco.Shared.IoC.ServiceHolder`1.CreateAndReplace``1">
            <summary> Creates new instance of <typeparamref name="TImpl"/> and replaces <see cref="F:Eco.Shared.IoC.ServiceHolder`1.Obj"/> with new value. </summary>
        </member>
        <member name="M:Eco.Shared.IoC.ServiceHolder`1.GetOrCreate``1">
            <summary>Gets existing instance of service or if not set then creates new instance of <typeparamref name="TImpl"/> type and sets it.</summary>
        </member>
        <member name="T:Eco.Shared.Items.InteractionInfo">
            <summary> Information about an interaction, calculated on the client. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.ID">
            <summary> ID used to rewind bad predictions. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.Method">
            <summary> Method used to start the interaction. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.Modifier">
            <summary> Any modifier key held down while triggering the interaction. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.TargetObject">
            <summary> The object being interacted with, if set. If this is set BlockPosition will be null. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.BlockPosition">
            <summary> The targeted block, if set. Will not be set at the same time as TargetObject. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.Parameters">
            <summary> Custom interaction parameters. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.Distance">
            <summary> Distance to the interaction target. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.Position">
            <summary> When TargetObject is not null, the position the interaction ray intersected with the target object. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.Normal">
            <summary> The facing direction of the side of the selected block. This is the side any placed block will be. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.FacingDirection">
            <summary> The facing direction of the player when performing the action. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionQueryInfo.TargetObject">
            <summary> Target object, if set. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionQueryInfo.HitPosition">
            <summary> If TargetObject is set, the position the ray interacted with the object. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionQueryInfo.Parameters">
            <summary> Custom parameters. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionQueryInfo.BlockPosition">
            <summary> The targeted blocks position, if TargetObject is not set. </summary>
        </member>
        <member name="F:Eco.Shared.Items.ItemInfo.InteractDistance">
            <summary> For IInteractingItem, the distance that it can be interacted with. </summary>
        </member>
        <member name="F:Eco.Shared.Items.ItemInfo.HighlightBlockIDs">
            <summary> For IInteractingItems, the block IDs that will get highlighted. </summary>
        </member>
        <member name="T:Eco.Shared.Items.TTCat">
            <summary> Categories of tooltips.</summary>
        </member>
        <member name="T:Eco.Shared.Items.TutorialFlag">
            <summary> Shared with the client to indicate when an RPCs (tutorial related) is needed </summary>
        </member>
        <member name="T:Eco.Shared.Localization.ConstLocs.ConstLocalizationAttribute">
            <summary>Attribute to signal for localization parser to extract const strings from class to be localized</summary>
        </member>
        <member name="T:Eco.Shared.Localization.FormattableStringExtensions">
            <summary>Extensions for <see cref="T:System.FormattableString"/> related to localization.</summary>
        </member>
        <member name="M:Eco.Shared.Localization.FormattableStringExtensions.CanBeInlined(System.FormattableString)">
            <summary>Checks if <paramref name="fs"/> can be inlined (resolved to string without information lose). It may be inlined if all arguments can be inlined.</summary>
        </member>
        <member name="M:Eco.Shared.Localization.FormattableStringExtensions.CanInlineAsArg(System.Object)">
            <summary>Checks if <paramref name="arg"/> may be inlined (resolved to string without information lose). <see cref="T:Eco.Shared.Localization.LocString"/> may be inlined if it wraps non-localized string, other types assumed to be inlinable.</summary>
        </member>
        <member name="T:Eco.Shared.Localization.LocalizationExtractionUtils">
            <summary>Utils for localization string extractions</summary>
        </member>
        <member name="M:Eco.Shared.Localization.LocalizationExtractionUtils.TypesToExtract(System.Boolean)">
            <summary>Localization types to extract loc strings from</summary>
            <param name="excludeShared">Ignore shared namespace (so it doesn't get extracted twice)</param>
        </member>
        <member name="M:Eco.Shared.Localization.LocalizationExtractionUtils.ExtractLocalizedAttr(System.Type,System.Collections.Generic.List{Eco.Shared.Localization.StringLocalizedData},Eco.Shared.Localization.LocalizedAttribute,System.Boolean)">
            <summary>Extract localization strings from classes or enums with <see cref="T:Eco.Shared.Localization.LocalizedAttribute"/></summary>
            From classes will extract properties and/or fields
            From enums will extract
            <param name="type">type with attribute</param>
            <param name="locData">list to add new localization data</param>
            <param name="localizedAttr">actual attribute</param>
            <param name="includeFields">should also include fields</param>
        </member>
        <member name="M:Eco.Shared.Localization.LocalizationExtractionUtils.GetTypeLocName(System.Type,Eco.Shared.Localization.LocalizedAttribute)">
            <summary>Extract loc display name of type from <see cref="P:Eco.Shared.Localization.LocalizedAttribute.CustomDisplayName"/> or RemoveCamelCase</summary>
        </member>
        <member name="T:Eco.Shared.Localization.LocalizedEnumConverter">
            <summary>
            Used to enable localized enum values in PropertyGrids.
            Can also be manually added to any enum to override the default behaviour when casting to a string.
            </summary>
        </member>
        <member name="M:Eco.Shared.Localization.Localizer.StyledPluralUnsigned(System.String,System.Single)">
            <summary> Styles originally negative numbers in red (negative style) while removing the negative sign from the output.</summary>
        </member>
        <member name="M:Eco.Shared.Localization.Localizer.A(Eco.Shared.Localization.LocString)">
            <summary>Adds a/an based on the first letter of the given string, the given word shouldn't include tags.</summary>
        </member>
        <member name="M:Eco.Shared.Localization.Localizer.A_strip(Eco.Shared.Localization.LocString)">
            <summary>Adds a/an based on the first letter of the given string, safely excuted and strips tags if any.</summary>
        </member>
        <member name="M:Eco.Shared.Localization.Localizer.InitializeLanguage(Eco.Shared.Localization.SupportedLanguage)">
            <summary>Sets initial localizer language and invoke post initialize actions</summary>
            For things that get setup before localization, but must wait for localizer correct language
        </member>
        <member name="M:Eco.Shared.Localization.Localizer.OnInitialized(System.Action)">
            <summary>Call action after initialization or instantly when already initialized</summary>
        </member>
        <member name="M:Eco.Shared.Localization.Localizer.AddIndefiniteArticle(Eco.Shared.Localization.LocString)">
            <summary> Adds "a" or "an" to the phrase depending on some common English rules E.g a user, an item </summary>
        </member>
        <member name="M:Eco.Shared.Localization.Localizer.GetIndefiniteArticle(System.String)">
            <summary> Returns "a" or "an" depending on some common English rules</summary>
        </member>
        <member name="M:Eco.Shared.Localization.TextLoc.Table(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Eco.Shared.Localization.LocString}})">
            <summary> Creates localized text table with tags from 2D LocString IEnumerable </summary>
        </member>
        <member name="M:Eco.Shared.Localization.DescriptionLoc.MutualTag(System.Collections.Generic.IEnumerable{System.ValueTuple{System.String,System.Collections.Generic.IEnumerable{System.String}}},System.Collections.Generic.IEnumerable{System.ValueTuple{System.String,System.Collections.Generic.IEnumerable{System.String}}},System.Collections.Generic.HashSet{System.String})">
            <summary> Searches for the rarest tag that is present in every selected element. Can also determine if all elements of this tag have been selected. </summary>
        </member>
        <member name="M:Eco.Shared.Localization.DescriptionLoc.DescribeViews(System.Collections.Generic.IEnumerable{System.Object},System.Collections.Generic.IEnumerable{System.Object},System.Collections.Generic.HashSet{System.String},System.String)">
            <summary> Tries to combine entries into groups. See SearchableListUI.UpdateSlots on the client side for a demo. </summary> // Handy converter for the client side.
        </member>
        <member name="M:Eco.Shared.Localization.DescriptionExtensinons.GetNamesAndTags(Eco.Shared.View.ViewClassInfo)">
            <summary> Gets ViewClassInfo's display name and tags. </summary>
        </member>
        <member name="M:Eco.Shared.Localization.DescriptionExtensinons.GetNamesAndTagsFromViews(System.Collections.Generic.IEnumerable{System.Object})">
            <summary> Gets display name and tags of every ViewClassInfo in the collection. </summary>
        </member>
        <member name="T:Eco.Shared.Localization.LocDescriptionCloneAttribute">
            <summary> Clones <see cref="T:Eco.Shared.Localization.LocDescriptionAttribute"/> of the provided property. </summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocDescriptionAttribute.LocDescription">
            <summary> Non-resolved <see cref="T:Eco.Shared.Localization.LocString"/> value for the description. </summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocDescriptionAttribute.Description">
            <summary> Localized description. </summary>
        </member>
        <member name="T:Eco.Shared.Localization.NotLocalizedDisplayNameAttribute">
            <summary>
            The standard DisplayNameAttribute doesn't support Enums + other types, so this is a useful extension.
            </summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocCategoryDescription.LocDescription">
            <summary> Non-resolved <see cref="T:Eco.Shared.Localization.LocString"/> value for the display name. </summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocCategoryDescription.Description">
            <summary> Localized description. </summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocDisplayNameAttribute.LocDisplayName">
            <summary> Non-resolved <see cref="T:Eco.Shared.Localization.LocString"/> value for the display name. </summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocDisplayNameAttribute.Name">
            <summary> Not localized display name. </summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocDisplayNameAttribute.DisplayName">
            <summary> Localized display name. </summary>
        </member>
        <member name="T:Eco.Shared.Localization.AutoContextCommentAttribute">
            <summary>
            Add context comment to Classes, Fields, Properties and Enums auto-localized via <see cref="T:Eco.Shared.Networking.EcoAttribute"/> or <see cref="T:Eco.Shared.Localization.LocalizedAttribute"/>
            e.g.:
            [Localized] class Player 
            { 
                [AutoContextComment("Player Configuration")]
                public Setting  Config { get; set; } 
            }
            
            will extract "Config" loc string with context 'Player Configuration'
            
            </summary>
        </member>
        <member name="T:Eco.Shared.Localization.ContextCommentAttribute">
            <summary>
            For Classes, Fields, Properties, Methods and Enums to localize other attribute parameters
            e.g.:
            [Eco, LocDescription("Some description"), ContextComment(typeof(LocDescriptionAttribute), "Some description context")]
            public class CivicAction_AddElement
            { 
                [AutoContextComment("Player Configuration")]
                public Setting  Config { get; set; } 
            }
            
            will extract "Some description" loc string with context 'Some description context'
            
            </summary>
        </member>
        <member name="M:Eco.Shared.Localization.LocExtensions.GetLocDisplayName(System.Enum,System.Boolean)">
            <summary>Get FOLDOUT Loc Display name of an Enum value. If that value has `LocDisplayNameAttribute` then use that instead of the Value's name. If that value has `LocDescriptionAttribute` then do foldout with the description.</summary>
            should be renamed to GetFoldoutDisplayName, but it has too many references
        </member>
        <member name="M:Eco.Shared.Localization.LocExtensions.GetEnumLocDisplayName(System.Enum)">
            <summary>Get only Loc Display name from localized Enum</summary>
            aware of <see cref="T:Eco.Shared.Localization.LocDisplayNameAttribute"/>, <see cref="T:Eco.Shared.Localization.NotLocalizedDisplayNameAttribute"/>
        </member>
        <member name="M:Eco.Shared.Localization.LocExtensions.GetLocDisplayName(System.Reflection.MemberInfo)">
            <summary> Get a localized display name, using the the defined LocDisplayName attribute, or if that's missing, by localizing the 'remove camel case' of the name.</summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:Eco.Shared.Localization.LocExtensions.GetLocDisplayNameColored(System.Reflection.MemberInfo)">
            <summary> Get the display name and query the color of this property from the Color attribute and apply it.</summary>
        </member>
        <member name="M:Eco.Shared.Localization.LocExtensions.InsertLineLoc(Eco.Shared.Localization.LocStringBuilder,System.FormattableString)">
            <summary> Inserts the line at the beginning of the builder. </summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocString.NotTranslated">
            <summary>Returns not translated string. If <see cref="T:System.FormattableString"/> was used then it will be resolved to string.</summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocString.Inlinable">
            <summary>Checks if <see cref="T:Eco.Shared.Localization.LocString"/> may be inlined (resolved to string without information lose). It is <c>true</c> if the LocString shouldn't be localized and wraps string.</summary>
        </member>
        <member name="M:Eco.Shared.Localization.LocString.TryGetInlineValue(System.String@)">
            <summary>If the loc string is <see cref="P:Eco.Shared.Localization.LocString.Inlinable"/> then returns inline value which then may be used for result string building.</summary>
        </member>
        <member name="M:Eco.Shared.Localization.LocStringBuilder.AppendArgument(System.Object)">
            <summary>Adds <paramref name="value"/> as argument to <see cref="T:Eco.Shared.Localization.LocStringBuilder"/>. If there at least one argument then <see cref="T:System.FormattableString"/> will be used.</summary>
        </member>
        <member name="M:Eco.Shared.Localization.LocStringBuilder.Append(Eco.Shared.Localization.LocString)">
            <summary>
            Appends <paramref name="value"/> to <see cref="T:Eco.Shared.Localization.LocStringBuilder"/>. Behavior depends on the <paramref name="value"/>.
            If value is not localized and is plain string then it will just be added to format, but otherwise it will be added as argument.
            </summary>
        </member>
        <member name="M:Eco.Shared.Localization.LocStringBuilder.Append(System.String)">
            <summary>Appends <paramref name="value"/> "as is".</summary>
        </member>
        <member name="M:Eco.Shared.Localization.LocStringBuilder.TrimFormat">
            <summary> Trims format string. </summary>
        </member>
        <member name="M:Eco.Shared.Localization.LocStringBuilder.ToLocString">
            <summary>Produces <see cref="T:Eco.Shared.Localization.LocString"/> from appended content.</summary>
        </member>
        <member name="T:Eco.Shared.Localization.LocStringBuilderUtils">
            <summary> utilities for <see cref="T:Eco.Shared.Localization.LocStringBuilder"/> </summary>
        </member>
        <member name="T:Eco.Shared.Localization.MissingString">
            <summary> class is used to register missing localization strings /// </summary>
        </member>
        <member name="T:Eco.Shared.Localization.StringLocalizedData">
            <summary> Class used by LocalizationAssemblyParser to hold data intended for localization. </summary>
        </member>
        <member name="F:Eco.Shared.Localization.SupportedLanguageUtils.DictToCultureLangCode">
            <summary>
            Table for converting eco lang to .NET culture codes for use with external ASP.NET restful services.
            A complete list of supported CultureInfo codes can be found here: 
            https://docs.microsoft.com/en-us/bingmaps/rest-services/common-parameters-and-types/supported-culture-codes
            </summary>
        </member>
        <member name="M:Eco.Shared.LZ4.LZ4Utils.StreamEncode(System.ReadOnlySpan{System.Byte},System.IO.MemoryStream)">
            <summary>Encodes <paramref name="data"/> to <paramref name="compressed"/> stream.</summary>
        </member>
        <member name="M:Eco.Shared.LZ4.LZ4Utils.StreamDecode(System.ReadOnlySpan{System.Byte},System.IO.MemoryStream)">
            <summary>Decodes content of <paramref name="compressed"/> span with LZ4 and outputs decompressed result to <paramref name="decompressed"/>.</summary>
        </member>
        <member name="M:Eco.Shared.LZ4.LZ4Utils.ReadFrame(Eco.Shared.Utils.Binary.ByteSpanReader@)">
            <summary>
            Ported from https://github.com/MiloszKrajewski/K4os.Compression.LZ4.
            Reads LZ4 frame header and returns descriptor.
            </summary>
        </member>
        <member name="M:Eco.Shared.LZ4.LZ4Utils.ReadBlock(Eco.Shared.Utils.Binary.ByteSpanReader@,K4os.Compression.LZ4.Streams.LZ4Descriptor,K4os.Compression.LZ4.Encoders.ILZ4Decoder)">
            <summary>
            Ported from https://github.com/MiloszKrajewski/K4os.Compression.LZ4.
            Reads next LZ4 block using <paramref name="descriptor"/> and <paramref name="decoder"/>.
            Block content may be then drained from <paramref name="decoder"/>. Returns number of uncompressed bytes to be drained.
            </summary>
        </member>
        <member name="M:Eco.Shared.LZ4.LZ4Utils.WriteFrame(System.IO.MemoryStream,K4os.Compression.LZ4.Streams.LZ4Descriptor)">
            <summary>
            Ported from https://github.com/MiloszKrajewski/K4os.Compression.LZ4.
            Writes LZ4 frame header for provided <paramref name="descriptor"/>.
            </summary>
        </member>
        <member name="M:Eco.Shared.LZ4.LZ4Utils.WriteEmptyBlock(System.IO.MemoryStream)">
            <summary>Writes empty block (usually used to last block marker).</summary>
        </member>
        <member name="M:Eco.Shared.LZ4.LZ4Utils.WriteBlock(System.IO.MemoryStream,System.Byte[],System.Int32,K4os.Compression.LZ4.Encoders.EncoderAction)">
            <summary>
            Ported from https://github.com/MiloszKrajewski/K4os.Compression.LZ4.
            Writes LZ4 block (either compressed or uncompressed).
            </summary>
        </member>
        <member name="M:Eco.Shared.LZ4.LZ4Utils.MaxBlockSizeCode(System.Int32)">
            <summary> Ported from https://github.com/MiloszKrajewski/K4os.Compression.LZ4. Converts block size to block size code.</summary>
        </member>
        <member name="M:Eco.Shared.LZ4.LZ4Utils.MaxBlockSize(System.Int32)">
            <summary> Ported from https://github.com/MiloszKrajewski/K4os.Compression.LZ4. Converts block size code to actual block size.</summary>
        </member>
        <member name="M:Eco.Shared.Mathf.Round(System.Single)">
            <summary>
            Rounds half using standard rounding algorithm (to even or bank rounding)!
            I.e. -0.5 -> 0; 0.5 -> 0; 1.5 -> 2.
            </summary>
            <param name="value">value to round.</param>
            <returns>rounded value, tie rounded to closest even number.</returns>
        </member>
        <member name="M:Eco.Shared.Mathf.RoundToMultiple(System.Single,System.Int32)">
            <summary> Rounds value so it will be multiple of some value. Sample: 11, 5 => 10 </summary>
        </member>
        <member name="M:Eco.Shared.Mathf.RoundUp(System.Single)">
            <summary>
            Rounds half up. I.e. -0.5 -> 0; 0.5 -> 1; 1.5 -> 2.
            We should prefer this way of rounding for coordinates,
            because for voxel we always subtracting 0.5 (i.e. voxel with position [0,0,0] will have [-0.5,-0.5,-0.5] coordinates).
            </summary>
            <param name="value">value to round.</param>
            <returns>rounded value, tie rounded to closest greater int number.</returns>
        </member>
        <member name="M:Eco.Shared.Mathf.RoundUpToInt(System.Single)">
            <summary>
            Rounds half up. I.e. -0.5 -> 0; 0.5 -> 1; 1.5 -> 2.
            We should prefer this way of rounding for coordinates,
            because for voxel we always subtracting 0.5 (i.e. voxel with position [0,0,0] will have [-0.5,-0.5,-0.5] coordinates).
            </summary>
            <param name="value">value to round.</param>
            <returns>rounded value, tie rounded to closest greater int number.</returns>
        </member>
        <member name="M:Eco.Shared.Mathf.ClampTop(System.Single,System.Single)">
            <summary> Clamps to max value. Same as Clamp(current, float.MinValue, max). </summary>
        </member>
        <member name="M:Eco.Shared.Mathf.PercentageOf(System.Single,System.Single)">
            <summary> Calculates percentage [0; 1] of <paramref name="total"/> for specified <paramref name="value"/>. </summary>
            <sample> percentage of <c>5</c> for <c>100</c> is <c>0.05</c>. </sample>
        </member>
        <member name="M:Eco.Shared.Mathf.PercentageComplementOf(System.Single,System.Single)">
            <summary> Calculates complement of the percentage [0; 1] of the <paramref name="value"/> for the <paramref name="total"/> (1 - percentage). </summary>
            <sample> percentage of <c>5</c> for <c>100</c> is <c>0.05</c>; complement of the percentage of <c>5</c> for <c>100</c> is <c>0.95</c>. </sample>
        </member>
        <member name="M:Eco.Shared.Mathf.RoundToAcceptedDigits(System.Single)">
            <summary> Calculates the exact visible amount for the economy by removing extra fractional digits. </summary>
        </member>
        <member name="M:Eco.Shared.Mathf.CeilingToInt(System.Single,System.Single)">
            <summary>
            Performs <see cref="M:System.Math.Ceiling(System.Double)"/> for <paramref name="num"/> with specified <paramref name="epsilon"/> and converts value to int.
            If previous integer value is within <paramref name="epsilon"/> of <paramref name="num"/> then it will use previous value instead.
            <paramref name="num"/> should be >= 0 and <paramref name="epsilon"/> should be > 0 and &lt;=0.5. Otherwise you will get undetermined result.
            </summary>
            <sample>
            <code>CeilingToInt(0.01f, 0.001f) // 1</code>
            <code>CeilingToInt(0.001f, 0.001f) // 0</code>
            </sample>
        </member>
        <member name="M:Eco.Shared.Mathf.FloorToInt(System.Single,System.Single)">
            <summary>
            Performs <see cref="M:System.Math.Floor(System.Double)"/> for <paramref name="num"/> with specified <paramref name="epsilon"/> and converts value to int.
            If next integer value is within <paramref name="epsilon"/> of <paramref name="num"/> then it will use next value instead.
            <paramref name="num"/> should be >= 0 and <paramref name="epsilon"/> should be > 0 and &lt;= 0.5. Otherwise you will get undetermined result.
            </summary>
            <sample>
            <code>FloorToInt(0.99f, 0.001f) // 0</code>
            <code>FloorToInt(0.999f, 0.001f) // 1</code>
            </sample>
        </member>
        <member name="M:Eco.Shared.Math.DirectionExtensions.ToVec2i(Eco.Shared.Math.Direction2D)">
            <summary>Converts the direction into a Vector2i</summary>
        </member>
        <member name="M:Eco.Shared.Math.DoubleExtensions.TryConvertToLong(System.Double,System.Int64@)">
            <summary>Tries to convert <paramref name="value"/> to <see cref="T:System.Int64"/>. It will fail if the value out of long value range, NaN or infinity.</summary>
        </member>
        <member name="T:Eco.Shared.Math.EcoTextLimit">
            <summary>
            EcoTextLimit allows for limiting text length in Eco with respect to whether or not the text contains tags. Max is used for text without tags, while MaxWithTags is used for text with tags.
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.FloatExtensions.Sign(System.Single,System.Single)">
            <summary> Returns <paramref name="value"/> sing with specified <paramref name="tolerance"/>. If absolute <paramref name="value"/> less than <paramref name="tolerance"/> then sign will be assumed to <c>0</c>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.FloatExtensions.Wrap(System.Single,System.Single)">
             <summary>
             Wraps value to a range starting with 0 and ending with wrapTo.
             It ensures value in this range and if value is negative it will start from end of range.
            
             For wrapped range we means a some range starting with 0 and ended with concrete end value. I.e. [0, 100)
             When value wrapped it should be enclosed in this range:
              - reduce it to length of this range with "modulo" operation.
              - if it negative then it should be aligned at the end of range
              Some examples for range [0, 100):
                250     ->   250 % 100 = 50   | -                -> 50
                -175    ->   -175 % 100 = -75 | 100 - 75 = 25    -> 25.
             </summary>
             <param name="value">Value to wrap.</param>
             <param name="wrapTo">Ending value of range.</param>
             <returns>Value wrapped to range.</returns>
        </member>
        <member name="M:Eco.Shared.Math.FloatExtensions.SetWhenLess(System.Single@,System.Single)">
            <summary>
            Replaces <paramref name="value"/> with <paramref name="candidate"/> if it is less than <paramref name="value"/>.
            Shorthand for
            <code>
            var candidate = someFunc();
            if (candidate &lt; value)
            {
               value = candidate;
               doSomethingElse();
            }
            </code>
            may be shortened to
            <code>
            if (value.SetWhenLess(someFunc())) doSomethingElse();
            </code>
            </summary>
            <returns><c>true</c> if value was set.</returns>
        </member>
        <member name="M:Eco.Shared.Math.IntExtensions.Wrap(System.Int32,System.Int32)">
             <summary>
             Wraps value to a range starting with 0 and ending with wrapTo.
             It ensures value in this range and if value is negative it will start from end of range.
            
             For wrapped range we means a some range starting with 0 and ended with concrete end value. I.e. [0, 100)
             When value wrapped it should be enclosed in this range:
              - reduce it to length of this range with "modulo" operation.
              - if it negative then it should be aligned at the end of range
              Some examples for range [0, 100):
                250     ->   250 % 100 = 50   | -                -> 50
                -175    ->   -175 % 100 = -75 | 100 - 75 = 25    -> 25.
             </summary>
             <param name="value">Value to wrap.</param>
             <param name="wrapTo">Ending value of range.</param>
             <returns>Value wrapped to range.</returns>
        </member>
        <member name="M:Eco.Shared.Math.IntExtensions.InWrappedRange(System.Int32,System.Int32,System.Int32,System.Int32)">
             <summary>
             Checks if value is in a range which enclosed in wrapped range. <see cref="M:Eco.Shared.Math.IntExtensions.Wrap(System.Int32,System.Int32)"/>
            
             It means that "wrappedStart" and "wrappedEnd" values defines a range [wrappedStart, wrappedEnd),
             but this range itself is wrapped to [0, wrappedTo).
            
             So it may create situation when we have initial values: "start" = 80, "end" = 150,
             but after wrapping to [0, 100) they become: "wrappedStart" = 80 and "wrappedEnd" = 50.
            
             And in this case we have "wrappedStart" > "wrappedEnd", because of wrapping. It may be represented as:
             <para>
             xxxxxxx*********************xxxxxxx.
             </para>
             where "x" belongs to wrappedStart to wrappedEnd range.
            
             And for this kind of range we have to make special check where "value" contained in [min, max) range when
             it either contained in [wrappedStart, wrappedTo) or [0, wrappedEnd).
            
             If min &lt;= max, then standard check will be used.
             </summary>
             <param name="value">value to check if it contains in range.</param>
             <param name="wrappedStart">start range value (wrapped).</param>
             <param name="wrappedEnd">end range value (open, wrapped).</param>
             <param name="wrappedTo">end of wrapping range.</param>
             <returns>True if value contained in wrappedStart to wrappedEnd range, False otherwise.</returns>
             <seealso cref="M:Eco.Shared.Math.IntExtensions.Wrap(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Eco.Shared.Math.IntExtensions.WrappedRangeTo(System.Int32,System.Int32,System.Int32)">
             <summary>
             Creates enumerable which enumerates all values contained in range defined by "wrappedStart" and "wrappedEnd". <see cref="M:Eco.Shared.Math.IntExtensions.Wrap(System.Int32,System.Int32)"/>
             These values enclosed in wrapping range [0, wrappedTo), so it may create situation where "wrappedStart"
             greater than "wrappedEnd" because of overlapping start or end bound.
            
             I.e. for wrapping range [0, 100): [-50, 10) => [50, 10), [50, 120) => [50, 20)
            
             In this case we have to iterate over two ranges: [wrappedStart, wrappedTo) and [0, wrappedEnd).
             If wrappedStart less or equal to wrappedEnd then we go to standard iteration over [wrappedStart, wrappedEnd).
             </summary>
             <param name="wrappedStart">start range value (wrapped).</param>
             <param name="wrappedEnd">end range value (open, wrapped).</param>
             <param name="wrappedTo">end of wrapping range.</param>
             <returns>enumerable for wrapped range.</returns>
             <seealso cref="M:Eco.Shared.Math.IntExtensions.Wrap(System.Int32,System.Int32)"/>
             <seealso cref="M:Eco.Shared.Math.IntExtensions.InWrappedRange(System.Int32,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="T:Eco.Shared.Math.IntRange">
            <summary>
            Range bounded by int numbers. Alternative to <see cref="T:System.Range"/> without at end indexes support.
            With <see cref="T:System.Range"/> you have to know length of sequence for ^1 like indices and so can't calculate <see cref="P:Eco.Shared.Math.IntRange.Length"/> of range.
            </summary>
        </member>
        <member name="P:Eco.Shared.Math.IntRange.Length">
            <summary> Length of the range. </summary>
        </member>
        <member name="M:Eco.Shared.Math.IntRange.After(Eco.Shared.Math.IntRange,System.Int32)">
            <summary> Makes new <see cref="T:Eco.Shared.Math.IntRange"/> right after the <paramref name="range"/> with specified <paramref name="length"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.IntRange.FromOffsetAndLength(System.Int32,System.Int32)">
            <summary> Makes <see cref="T:Eco.Shared.Math.IntRange"/> from <paramref name="offset"/> and <paramref name="length"/> instead of two indexes. </summary>
        </member>
        <member name="M:Eco.Shared.Math.IntRange.op_Implicit(Eco.Shared.Math.IntRange)~System.Range">
            <summary> Implicitly converts to System.Range for array accessors etc. </summary>
        </member>
        <member name="T:Eco.Shared.Math.Matrix2x2i">
            <summary>
            Simple 2x2 integer matrix.
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.Range.InRangeNormalDist(System.Single)">
            Return whether a value is in the range, based on a normal random distribution 
        </member>
        <member name="M:Eco.Shared.Math.Range.Clamp0">
            <summary> Make sure the range is >= 0 </summary>
        </member>
        <member name="M:Eco.Shared.Math.Range.RoundToInt">
            <summary> Roumd min down, and max up. </summary>
        </member>
        <member name="M:Eco.Shared.Math.Range.RoundToMultiple(System.Single)">
            <summary> Roumd min down to the nearest multiple of 'val', and max up. </summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector2.WrappedDistanceSq(Eco.Shared.Math.Vector2@,Eco.Shared.Math.Vector2@)">
            <summary>Calculates squared distance for wrapped axes distances for voxel world size.</summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector2.WrappedDistance(Eco.Shared.Math.Vector2,Eco.Shared.Math.Vector2,Eco.Shared.Math.Vector2@)">
            <summary>Calculates distance for wrapped axes distances for <paramref name="size"/> (i.e. size may be voxel size, chunk size or plot size).</summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector2.WrappedDistanceSq(Eco.Shared.Math.Vector2@,Eco.Shared.Math.Vector2@,Eco.Shared.Math.Vector2@)">
            <summary>Calculates squared distance for wrapped axes distances for <paramref name="size"/> (i.e. size may be voxel size, chunk size or plot size).</summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector2.WrappedDirectionalVector(Eco.Shared.Math.Vector2@,Eco.Shared.Math.Vector2@,Eco.Shared.Math.Vector2@)">
            <summary>Returns directional difference vector wrapped in <paramref name="size"/> (i.e. WrappedVoxelSize, WrappedChunkSize or WrappedPlotSize).</summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector2.NormalizeSafe(Eco.Shared.Math.Vector2)">
            <summary>
            Same as <see cref="P:Eco.Shared.Math.Vector2.Normalized"/>, but for zero-length vector it returns <paramref name="defaultValue"/> instead.
            <see cref="P:Eco.Shared.Math.Vector2.Normalized"/> will return <see cref="F:System.Single.NaN"/> vector in this case.
            </summary>
        </member>
        <member name="P:Eco.Shared.Math.Vector2.Round">
            <summary>
            Uses default rounding rules (bank rounding, or round to closest even in case of tie).
            I.e. 0.5 -> 0, but 1.5 -> 2.
            </summary>
        </member>
        <member name="P:Eco.Shared.Math.Vector2.RoundUp">
            <summary>
            Always rounds to closes greater number. Preferred way of rounding for coordinates, because voxel coordinates always shifted down.
            I.e. 0.5 -> 1, 1.5 -> 2 and -1.5 -> -1.
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector2.AngleRad(Eco.Shared.Math.Vector2)">
            <summary> Returns angle between two in degs.</summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector2i.XYIter(Eco.Shared.Math.Vector2i,System.Int32)">
            <summary> Emits all integer two-component vectors with offset in range from 0 to size for each component and with the specified <paramref name="origin"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector2i.XYIterInclusive(System.Int32,System.Int32)">
            Iterate over a range (inclusive) 
        </member>
        <member name="M:Eco.Shared.Math.Vector3.NormalizeSafe(Eco.Shared.Math.Vector3)">
            <summary> Returns normalized version of vector (by dividing each component on vector length), but returns <paramref name="defaultValue"/> in case if length is zero to avoid producing NaN vector. </summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector3.AngleRad(Eco.Shared.Math.Vector3)">
            <summary> Returns angle between two in degs.</summary>
        </member>
        <member name="P:Eco.Shared.Math.Vector3.Round">
            <summary>
            Uses default rounding rules (bank rounding, or round to closest even in case of tie).
            I.e. 0.5 -> 0, but 1.5 -> 2.
            </summary>
        </member>
        <member name="P:Eco.Shared.Math.Vector3.RoundUp">
            <summary>
            Always rounds to closes greater number. Preferred way of rounding for coordinates, because voxel coordinates always shifted down.
            I.e. 0.5 -> 1, 1.5 -> 2 and -1.5 -> -1.
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector3.XZWrappedDirectionalVector(Eco.Shared.Math.Vector3@,Eco.Shared.Math.Vector3@,Eco.Shared.Math.Vector3@)">
            <summary>Returns directional difference vector wrapped in <paramref name="size"/> (i.e. WrappedVoxelSize, WrappedChunkSize or WrappedPlotSize).</summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector3.XZWrappedDirectionalVector(Eco.Shared.Math.Vector3@,Eco.Shared.Math.Vector3@)">
            <summary>Wraps a true 'vector' (which is now meaningless so we need a long name, points in the shortest direction after accounting for world wrapping).</summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector3i.AddY(System.Int32)">
            <summary>Returns new <see cref="T:Eco.Shared.Math.Vector3i"/> with <see cref="P:Eco.Shared.Math.Vector3i.Y"/> component with added <paramref name="deltaY"/>. You can use negative <paramref name="deltaY"/> to subtract value.</summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector3i.GetAxis(Eco.Shared.Math.Axis)">
            <summary> Returns the scalar value for the given axis. </summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector3i.XZWrappedDirectionalVector(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Vector3i)">
            <summary>Wraps a true 'vector' (which is now meaningless so we need a long name, points in the shortest direction after accounting for world voxel wrapping).</summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector3i.MinAxis">
            <summary> Return the smallest axis, breaking ties arbitrarily. </summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector3i.MaxAxis">
            <summary> Return the largest axis, breaking ties arbitrarily. </summary>
        </member>
        <member name="M:Eco.Shared.Math.VectorUtils.MoveAndRotate(System.Collections.Generic.IEnumerable{Eco.Shared.Math.Vector3i},Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary> Returns distinct collection of vectors form the area that were shifted and rotated according to provided params. </summary>
        </member>
        <member name="M:Eco.Shared.Math.VectorUtils.Average(System.Collections.Generic.IEnumerable{Eco.Shared.Math.Vector2})">
            <summary> Average position, or zero's if none in list. </summary>
        </member>
        <member name="M:Eco.Shared.Math.VectorUtils.Average(System.Collections.Generic.IEnumerable{Eco.Shared.Math.Vector2i})">
            <summary> Average position, or zero's if none in list. </summary>
        </member>
        <member name="M:Eco.Shared.Math.VectorUtils.Average(System.Collections.Generic.IEnumerable{Eco.Shared.Math.Vector3i})">
            <summary> Average position, or zero's if none in list. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldArea.WrappedAreas(Eco.Shared.Math.Vector2i)">
            <summary>Enumerates wrapped areas in <paramref name="size"/>. There may be more than one area if <see cref="T:Eco.Shared.Math.WorldArea"/> crossing the border. It assumes that <see cref="F:Eco.Shared.Math.WorldArea.MinInclusive"/> never less than -size for optimization purposes.</summary>
            <example>If <paramref name="size"/> is (100, 100) and area is (90, 90)-(110, 110) then this method will enumerate following areas: (90, 90)-(100, 100), (0, 90)-(10, 100), (90, 0)-(100, 10) and (0, 0)-(10,10).</example>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.Length">
            <summary> The length not including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.Width">
            <summary> The width not including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.Height">
            <summary> The height not including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.Volume">
            <summary> The volume not including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.Size">
            <summary> The size not including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.LengthInc">
            <summary> The length including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.WidthInc">
            <summary> The width including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.HeightInc">
            <summary> The height including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.VolumeInc">
            <summary> The volume including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.SizeInc">
            <summary> The size including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.Invalid">
            <summary> A range where IsValid() will return false. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.Empty">
            <summary> A range around 0,0,0 with 0 dimentions. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.Translate(Eco.Shared.Math.Vector3i)">
            <summary>Create a new world range translated by the given direction.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.ExpandMax(Eco.Shared.Math.Vector3i)">
            <summary>Expands the maximum value by <paramref name="delta"/>. Useful for converting from an inclusive world range to an exclusive one.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.CollapseAlongAxis(Eco.Shared.Math.Axis,System.Boolean)">
            <summary> Collapses a square range into a line. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.InvertRange(System.Int32@,System.Int32@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Inverts the range inside world to make a direction in a proper way
            E.g. start as 955 with end as 1 and worldSize 1000 will give a reversed direction from 955 to 1
            It'll return minValue as -45 and maxValue as 1 (-45:1 range) 
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.Fix(Eco.Shared.Math.Vector3i)">
            <summary> Swaps any values where the min of the axis is larger than the max of the axis. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.RotatedByExc(Eco.Shared.Math.Quaternion)">
            <summary>Rotates <see cref="T:Eco.Shared.Math.WorldRange"/> around (0, 0, 0) (works only with exclusive range). I.e. (-2,-2)-(4,4) rotated by 180 degree will be (-3,-3)-(3,3). When used as exclusive range will include point which was rotated from (-2,-2) to (2,2).</summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.RotatedByInc(Eco.Shared.Math.Quaternion)">
            <summary>Rotates <see cref="T:Eco.Shared.Math.WorldRange"/> around (0, 0, 0) (works only with inclusive range). I.e. (-2,-2)-(4,4) rotated by 180 degree will be (-4,-4)-(2,2).</summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.ExtendedBy(Eco.Shared.Math.Vector3i)">
            <summary>Returns new <see cref="T:Eco.Shared.Math.WorldRange"/> extended in each direction by <paramref name="extent"/>.</summary>
            <example><code>
            new WorldRange(new(0, 0, 0), new(1, 1, 1)).ExtendedBy(new(1, 0, 2)); // WorldRange((-1, 0, -2), (2, 1, 3))
            </code></example>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.Corners">
            <summary>
            Returns enumerable with all corners of this <see cref="T:Eco.Shared.Math.WorldRange"/>
            </summary>
        </member>
        <member name="T:Eco.Shared.Math.WrappedWorldPosition3">
            <summary> Represents wrapped world position which doesn't require any further conversions. It prevents multiple checks everywhere for position to be actually wrapped or multiple conversions for same data. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3.Create(System.Single,System.Single,System.Single)">
            <summary> Makes new <see cref="T:Eco.Shared.Math.WrappedWorldPosition3"/> from unwrapped <paramref name="x"/>, <paramref name="y"/> and <paramref name="z"/>. </summary>
        </member>
        <member name="T:Eco.Shared.Math.WrappedWorldPosition3Extensions">
            <summary> Extension methods for <see cref="T:Eco.Shared.Math.WrappedWorldPosition3"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3Extensions.WrappedDifference(Eco.Shared.Math.WrappedWorldPosition3,Eco.Shared.Math.WrappedWorldPosition3)">
            <summary> Calculates wrapped difference between <paramref name="a"/> and <paramref name="b"/>. </summary>
        </member>
        <member name="T:Eco.Shared.Math.WrappedWorldPosition3i">
            <summary>
            Represents wrapped world position which doesn't require any further conversions. It prevents multiple checks everywhere for position to be actually wrapped or multiple conversions for same data.
            Comparing to <see cref="T:Eco.Shared.Math.WorldPosition3i"/> it isn't packed, so doesn't require extra packing/unpacking operations and also readonly what allows to apply some optimizations and makes it thread-safe.
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.XYZNeighbors">
            <summary> Returns all orthogonal neighbors by X, Y, Z axes. It won't return Y axis neighbors if they out of bounds (bellow zero or above MaxY) and wrap X, Z neighbors (if they crossing zero coordinate). </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.Full26Neighbors(System.Boolean)">
            <summary> Returns all orthogonal and diagonal neighbors by X, Y, Z axes. It won't return Y axis neighbors if they out of bounds (bellow zero or above MaxY) and wrap X, Z neighbors (if they crossing zero coordinate). </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.XYZNeighborsWithDirection">
            <summary> Returns all orthogonal neighbors by X, Y, Z axes. It won't return Y axis neighbors if they out of bounds (bellow zero or above MaxY) and wrap X, Z neighbors (if they crossing zero coordinate). </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.AddX(System.Int32)">
            <summary>Adds <paramref name="x"/> to <see cref="F:Eco.Shared.Math.WrappedWorldPosition3i.X"/> component and returns new value. The value should be not less than -<see cref="P:Eco.Shared.Voxel.World.WrappedVoxelSize"/>.X.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.AddZ(System.Int32)">
            <summary>Adds <paramref name="z"/> to <see cref="F:Eco.Shared.Math.WrappedWorldPosition3i.Z"/> component and returns new value. The value should be not less than -<see cref="P:Eco.Shared.Voxel.World.WrappedVoxelSize"/>.Z.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.TryIncreaseY(System.Int32,Eco.Shared.Math.WrappedWorldPosition3i@)">
            <summary>Tries to increase <see cref="F:Eco.Shared.Math.WrappedWorldPosition3i.Y"/> component where <paramref name="increment"/> should be positive value. If succeed (not out of world bounds) then returns <c>true</c> and increased value in <paramref name="increasedPos"/>. For decreasing <see cref="F:Eco.Shared.Math.WrappedWorldPosition3i.Y"/> use <see cref="M:Eco.Shared.Math.WrappedWorldPosition3i.TryDecreaseY(System.Int32,Eco.Shared.Math.WrappedWorldPosition3i@)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.TryDecreaseY(System.Int32,Eco.Shared.Math.WrappedWorldPosition3i@)">
            <summary>Tries to decrease <see cref="F:Eco.Shared.Math.WrappedWorldPosition3i.Y"/> component where <paramref name="decrement"/> should be positive value. If succeed (not out of world bounds) then returns <c>true</c> and decreased value in <paramref name="decreasedPos"/>. For increasing <see cref="F:Eco.Shared.Math.WrappedWorldPosition3i.Y"/> use <see cref="M:Eco.Shared.Math.WrappedWorldPosition3i.TryIncreaseY(System.Int32,Eco.Shared.Math.WrappedWorldPosition3i@)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.TryGetNeighbor(Eco.Shared.Math.Direction,Eco.Shared.Math.WrappedWorldPosition3i@)">
            <summary>Returns neighbor world position for <paramref name="dir"/> if possible. It may return <c>false</c> for invalid <paramref name="dir"/> value or if Y will go out of world bounds.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.TryGetSides(Eco.Shared.Math.Axis,Eco.Shared.Math.WrappedWorldPosition3i@,Eco.Shared.Math.WrappedWorldPosition3i@)">
            <summary> If possible, returns two positions using passed axis. It may be impossible if it will be outside of world by Y coor. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.Create(System.Int32,System.Int32,System.Int32)">
            <summary> Makes new <see cref="T:Eco.Shared.Math.WrappedWorldPosition3i"/> from unwrapped <paramref name="x"/>, <paramref name="y"/> and <paramref name="z"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.Create(System.Single,System.Single,System.Single)">
            <summary> Makes new <see cref="T:Eco.Shared.Math.WrappedWorldPosition3i"/> from unwrapped <paramref name="x"/>, <paramref name="y"/> and <paramref name="z"/>. </summary>
        </member>
        <member name="T:Eco.Shared.Math.WrappedWorldPosition3iExtensions">
            <summary> Extension methods for <see cref="T:Eco.Shared.Math.WrappedWorldPosition3"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3iExtensions.WrappedDifference(Eco.Shared.Math.WrappedWorldPosition3i,Eco.Shared.Math.WrappedWorldPosition3i)">
            <summary>
            Calculates wrapped difference between <paramref name="a"/> and <paramref name="b"/>.
            I.e. for world size (100, 100, 80):
            - (10, 10, 10).WrappedDelta(20, 20, 20) -> (-10, -10, -10)
            - (10, 10, 10).WrappedDelta(60, 20, 60) -> (-50, -10, -30)
            - (10, 10, 10).WrappedDelta(60, 20, 60) -> (-50, -10, -50)
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3iExtensions.XZ(Eco.Shared.Math.WrappedWorldPosition3i)">
            <summary> Returns <see cref="T:Eco.Shared.Math.Vector2i"/> for <see cref="F:Eco.Shared.Math.WrappedWorldPosition3i.X"/> and <see cref="F:Eco.Shared.Math.WrappedWorldPosition3i.Z"/> coordinates. </summary>
        </member>
        <member name="M:Eco.Shared.Math.Route.FindPathSegmentIndexAtTime(System.Single,System.Int32)">
            <summary>Finds <see cref="T:Eco.Shared.Math.PathSegment"/> index covering <paramref name="time"/> starting at path segment with index <paramref name="start"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.ClientUpdate">
            <summary>
            Contains data for <see cref="F:Eco.Shared.Networking.NetworkEvent.ClientUpdate"/> events.
            Every <see cref="T:Eco.Shared.Networking.ClientUpdate"/> belongs to network queue with <see cref="F:Eco.Shared.Networking.ClientUpdate.queueIndex"/>.
            Queue index defines associated <see cref="T:Eco.Shared.Networking.NetworkEvent"/> as ClientUpdate<i>Index</i> (i.e. <see cref="F:Eco.Shared.Networking.NetworkEvent.ClientUpdate0"/> and <see cref="F:Eco.Shared.Networking.NetworkEvent.ClientUpdate1"/>).
            It has four data arrays for <see cref="F:Eco.Shared.Networking.ClientUpdate.Created"/> objects, <see cref="F:Eco.Shared.Networking.ClientUpdate.Updated"/> objects, <see cref="F:Eco.Shared.Networking.ClientUpdate.Destroyed"/> objects and <see cref="F:Eco.Shared.Networking.ClientUpdate.ViewUpdates"/>.
            They should be filled and then flushed with <see cref="M:Eco.Shared.Networking.ClientUpdate.Send(Eco.Shared.Networking.INetClient)"/> method. Only non-empty arrays sent.
            If all arrays are empty then <see cref="M:Eco.Shared.Networking.ClientUpdate.Send(Eco.Shared.Networking.INetClient)"/> call will be ignored unless <see cref="F:Eco.Shared.Networking.ClientUpdate.ForceSend"/> is set.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.ClientUpdate.AddToData(System.String,Eco.Shared.Serialization.BSONArray@)">
            <summary>Adds <paramref name="bson"/> to <see cref="F:Eco.Shared.Networking.ClientUpdate.data"/> with <paramref name="keyName"/> as key and replaces <paramref name="bson"/> with empty array.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.EcoAttribute">
            <summary>
            One attribute to rule them all. This gives all the bells-and-whistles to a property or class, including:
             - Serialized.  Loads and saves the entry.
             - SyncToView.  It creates a view of the property on the client and keeps it updated.
             - AutoRPC.     Creates an RPC for the client to edit this parameter.
             - AutoGen.     Tags the member to have UI generated for it automatically created on the client.
             - Property Scanning. The Property Scanner will traverse into it to update validity.
            </summary>
        </member>
        <member name="T:Eco.Shared.Networking.ScanPropAttribute">
            <summary> Mark a property as being traversed by Property Scanner, even if not tagged [Eco]. </summary>
        </member>
        <member name="T:Eco.Shared.Networking.TreatAsReferenceAttribute">
            <summary> Used for things that reference types like 'object', and we should consider them references from a scanning point of view. </summary>
        </member>
        <member name="T:Eco.Shared.Networking.ForceScanSubPropAttribute">
            <summary> Mark a property as to traverse its sub properties, even if it wouldn't usually otherwise (ie, references dont usually 'scan into') </summary>
        </member>
        <member name="T:Eco.Shared.Networking.OnlyReferenceScanAttribute">
            <summary> When this is encountered, the Property Scanner will continue scanning that property and any children properties, but will no longer check validity. This is useful when you have a property with members who's validity shouldnt affect our own (like actions that an election references), but you still want to perform the other features PropertyManager provides (like setting up references). </summary>
        </member>
        <member name="T:Eco.Shared.Networking.AnyStateAllowedAttribute">
            <summary> Mark a property as able to refernce any state of Proposablew. </summary>
        </member>
        <member name="T:Eco.Shared.Networking.RPCAttribute">
            <summary> Creates an RPC that can be called on the client. </summary>
        </member>
        <member name="T:Eco.Shared.Networking.ClientAPIAttribute">
            <summary>Marks method or class with all it's members as Client API. It prevents it marked as unused and adds semantic about use cases.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.AutoRPCAttribute">
            <summary> Creates an RPC in the view for the client to change this property. </summary>
        </member>
        <member name="T:Eco.Shared.Networking.ProfanityAttribute">
            <summary> Filter profanity RPC properties and parameters </summary>
        </member>
        <member name="T:Eco.Shared.Networking.RangeAttribute">
            <summary> Limit the strings to a certain range, based on the text type </summary>
        </member>
        <member name="T:Eco.Shared.Networking.EcoTextLimitAttribute">
            <summary> Limit the strings to a certain range, based on the text type </summary>
        </member>
        <member name="T:Eco.Shared.Networking.ProfanityPropertyAttribute">
            <summary> Filter profanity RPC properties and parameters by replacing with some specific property </summary>
        </member>
        <member name="T:Eco.Shared.Networking.KeepIconAttribute">
            <summary> 
            Keep class icon when using as property for GameValue instead of context icon. 
            <para>Example: GameAction contains Citizen property and uses context icon, this attribute will force any User property to use it's own icon.</para>
            </summary>
        </member>
        <member name="T:Eco.Shared.Networking.DoNotLinkOnTypeTooltipAttribute">
            <summary> Marks the type as non-linkable, even if it inherits from ILinkable. Types with this will not be linked from CivicsTooltip. </summary>
        </member>
        <member name="T:Eco.Shared.Networking.CustomIconOnTypeTooltipAttribute">
            <summary>
            Use to have a property prepended with an icon different than its type's.
            <para>Example: Alias has no icon of its own, but we want it to appear with the icon of 'Demographics', so we apply [CustomIconOnTypeTooltip(typeof(Demographics))].</para>
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.CustomIconOnTypeTooltipAttribute.#ctor(System.Type)">
            <param name="type"> Type to inherit the icon from. </param>
        </member>
        <member name="T:Eco.Shared.Networking.ExtendedServerInfo">
            <summary>Subclass of <see cref="T:Eco.Shared.Networking.ServerInfo"/> with additional properties provided only by Master Server and not published by server with <see cref="T:Eco.Shared.Networking.ServerInfo"/> to keep payload size as small as possible (to avoid problems with UDP packet size limits).</summary>
        </member>
        <member name="M:Eco.Shared.Networking.UdpPeerExtensions.SendUnconnectedMessageWithFragmentation(Eco.Shared.Networking.Udp.IUnconnectedUdpPeer,System.Net.IPEndPoint,System.IO.MemoryStream)">
             <summary>
             Sends unconnected message to recipient with fragmentation support.
             Fragmented messages conforms to following protocol:
                 [NetMessage.FragmentedMessage][fragmentation info byte][fragmented message guid][message body fragment]
            
             [fragmentation info byte] - contains pair partIndex/numOfParts (4 bits each), lower 4 bits is a part index and upper 4 bits is a number of parts. If 0 then message is not fragmented
             [fragmented message guid] - Used as fragmented message identifier to assembly message from parts at destination. 16 bytes.
             [message body fragment] - actual message body. Each fragment will contain part of message body.
            
             Samples:
             0Hello World
            
             One fragment:
                 [\0][H][e][l][l][o][ ][W][o][r][l][d]
             Two fragments:
                 [\10][\32][Guid:16 bytes][\0][H][e][l][l][o]
                 [\10][\33][Guid:16 bytes][ ][W][o][r][l][d]
            
             Following this protocol maximum useful allowed message length is: (MTU - 18) * 15.
             </summary>
             <param name="peer">peer.</param>
             <param name="message">Message to send, if it matches MTU then it will be send as is, otherwise wrapped in fragmented message.</param>
             <param name="recipient">recipient endpoint.</param>
             <exception cref="T:System.ArgumentException">Thrown if message body is too long to split into 15 fragments (max number of fragments).</exception>
        </member>
        <member name="P:Eco.Shared.Networking.FragmentedMessageHandler.TTL">
            <summary>
            Gets or sets fragmented message Time-To-Life, if during this interval message will not be assembled then it will be cleaned up.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.FragmentedMessageHandler.TryGetCompleteBuffer(Eco.Shared.Networking.UdpDataMessage@,Eco.Shared.Networking.UdpDataMessage@)">
            <summary>
            Handles incoming message which may be a fragment. Will return same message if message is complete and may be processed further.
            If it is a message fragment then it will be added to collection of message fragments.
            As soon as all message fragments will be collected it will assemble NetBuffer with message content.
            </summary>
            <param name="message">UdpIncomingMessage message which may be fragment or complete message.</param>
            <param name="completeMessage">UdpIncomingMessage containing complete message data if success, null otherwise.</param>
            <returns>Returns true if able to get complete buffer, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">In case of a fragment inconsistency.</exception>
        </member>
        <member name="T:Eco.Shared.Networking.INetObjectName">
            <summary> Interface which may be implemented by <see cref="T:Eco.Shared.Networking.INetObject"/> to expose custom name for network object (i.e. for logging). </summary>
        </member>
        <member name="T:Eco.Shared.Networking.INetObjectManager">
            <summary>Interface for <see cref="T:Eco.Shared.Networking.INetObject"/> manager.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.INetObjectManager.GetNextID">
            <summary>Allocates and returns next <see cref="T:Eco.Shared.Networking.INetObject"/> identifier.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.INetObjectManager.Add(Eco.Shared.Networking.INetObject,System.Int32)">
            <summary>Adds <paramref name="netObject"/> with associated <paramref name="id"/> to <see cref="T:Eco.Shared.Networking.INetObjectManager"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.INetObjectManager.Remove(Eco.Shared.Networking.INetObject)">
            <summary>Removes <paramref name="netObject"/> from <see cref="T:Eco.Shared.Networking.INetObjectManager"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.INetworkInterceptor">
            <summary>
            <para>Allows an object to intercept <seealso cref="T:Eco.Shared.Serialization.BSONObject"/>s being sent.</para>
            <para>
            See <seealso cref="M:Eco.Shared.Networking.NetObject.AddNetworkInteceptor(Eco.Shared.Networking.INetworkInterceptor)"/> and <seealso cref="M:Eco.Shared.Networking.NetObject.RemoveNetworkInterceptor(Eco.Shared.Networking.INetworkInterceptor)"/> 
            for adding/removing <seealso cref="T:Eco.Shared.Networking.INetworkInterceptor"/> instances.
            </para>
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetObject.SendEventNow(Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject,Eco.Shared.Networking.INetClient)">
            <summary>Sends event immediately if possible ignoring previously queued messages. As side effect it makes encoding in current thread instead of network thread.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.INetworkEventHandler.SendEvent(Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject,Eco.Shared.Networking.INetClient,Eco.Shared.Networking.INetObject)">
            <summary>Sends network event to destination target with respect to order of previously queued events.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.INetworkEventHandler.SendEventNow(Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject,Eco.Shared.Networking.INetClient)">
            <summary>Sends network event immediately if possible ignoring previously queued events. If not possible then fallback to <see cref="M:Eco.Shared.Networking.INetworkEventHandler.SendEvent(Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject,Eco.Shared.Networking.INetClient,Eco.Shared.Networking.INetObject)"/> behavior. It also makes all encoding and serialization in current thread.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetObjectManager.CollectObjectStats">
            <summary> Collect stats about existing network objects in <see cref="T:Eco.Shared.Networking.NetObjectManager"/>. May be used for statistic and leaks detection. </summary>
        </member>
        <member name="P:Eco.Shared.Networking.NetworkClient.RemoteEndPoint">
            <summary> Actual remote end-point for the <see cref="F:Eco.Shared.Networking.NetworkClient.peer"/>. </summary>
        </member>
        <member name="P:Eco.Shared.Networking.NetworkClient.ServerEndPoint">
            <summary> Server's original end-point (may differ from <see cref="P:Eco.Shared.Networking.NetworkClient.RemoteEndPoint"/> if connected with relay). </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetworkClient.TryConnectDirectly(Eco.Shared.Networking.ExtendedServerInfo)">
            <summary>Tries to connect directly to <paramref name="server"/> using external and internal endpoints (if available).</summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetworkClient.BuildDelivery">
            <summary>
            Build delivery packets list in thread unsafe context to be delivered with thread-safe <see cref="M:Eco.Shared.Networking.NetworkClient.Deliver(System.Collections.Generic.List{Eco.Shared.Pools.PooledMemoryStream})"/>.
            </summary>
            <returns>list of packets to delivery.</returns>
        </member>
        <member name="M:Eco.Shared.Networking.NetworkClient.Deliver(System.Collections.Generic.List{Eco.Shared.Pools.PooledMemoryStream})">
            <summary>
            Thread-safe deliver method for list of packets.
            WARNING! It consumes packets list! You can't use the list after pass it to Deliver method.
            </summary>
            <param name="packets">list of packets to deliver.</param>
        </member>
        <member name="M:Eco.Shared.Networking.NetworkClient.EnqueueReceivedPacket(Eco.Shared.Networking.ReceivedNetworkPacket)">
            <summary>Enqueues received packet to the queue based on network event.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetworkClient.TryConnectWithNextConnectionMethod">
            <summary>Tries next connection method (if available). The order is following: DirectConnect, NATPunchConnect, RelayConnect.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetworkClient.TryConnectWithNATPunch(Eco.Shared.Networking.NetworkClient.ConnectionAttempt)">
            <summary>Tries to connect with NAT Punch Through. This method used when client can't connect to server directly due to lack of external IP.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetworkClient.TryConnectWithRelay(Eco.Shared.Networking.NetworkClient.ConnectionAttempt)">
            <summary>Tries to connect using Relay (proxy for client-server traffic when all other methods fails).</summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetworkClient.Dispose">
            <summary>
            Disposes of the <see cref='T:System.ComponentModel.Component'/>.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetMessage.EncodePacket(System.IO.MemoryStream,Eco.Shared.Networking.NetworkEvent,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encodes network packet either as compressed (see <see cref="M:Eco.Shared.Networking.NetMessage.EncodeCompressedPacket(System.IO.MemoryStream,Eco.Shared.Networking.NetworkEvent,System.Byte[],System.Int32,System.Int32)"/>) or as non-compressed (if it is short enough &lt;=512).
            It has following structure (for uncompressed packet):
            [network event:1 byte]
            [length in bytes:int, zig zag bytes] - see <see cref="M:Eco.Shared.Utils.MemoryStreamExtensions.EncodeZigZag(System.IO.MemoryStream,System.Int32)"/>
            [message bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetMessage.EncodeCompressedPacket(System.IO.MemoryStream,Eco.Shared.Networking.NetworkEvent,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encodes network packet as compressed.
            It has following structure:
            [0x80 - compressed flag | network event:1 byte]
            [compressed length in bytes:int, 4 bytes]
            [compressed bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetMessage.EncodePacket(System.IO.MemoryStream,Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject)">
            <summary> Encodes <paramref name="payload"/> as network packet for <paramref name="netEvent"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetMessage.SendPacket(Eco.Shared.Networking.Udp.IUdpClient,Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject)">
            <summary> Sends <paramref name="netEvent"/> with <paramref name="payload"/> through the <paramref name="peer"/> (to the server). </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetMessage.BroadcastPacket(Eco.Shared.Networking.Udp.IUdpServer,Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject)">
            <summary> Broadcasts <paramref name="netEvent"/> with <paramref name="payload"/> to all connected clients. </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetMessage.SendPacket(Eco.Shared.Networking.Udp.IUdpPeer,Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject,System.Object)">
            <summary> Encodes <paramref name="payload"/> and sends <paramref name="netEvent"/> with it's data to <paramref name="connection"/> (may be obtained from <see cref="E:Eco.Shared.Networking.Udp.IUdpPeer.Connected"/>). </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetMessage.SendPacket(Eco.Shared.Networking.Udp.IUdpPeer,Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject,System.Collections.Generic.IEnumerable{System.Object})">
            <summary> Encodes <paramref name="payload"/> and sends <paramref name="netEvent"/> with it's data to all <paramref name="connections"/> (may be obtained from <see cref="E:Eco.Shared.Networking.Udp.IUdpPeer.Connected"/>). </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetMessage.DoWithDisconnectReason``1(System.String,``0,System.Boolean,System.Action{``0,Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject})">
            <summary> Invokes <paramref name="action"/> with pre-constructed disconnect message object. </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetworkUtils.TryResolve(System.String,System.Net.IPAddress@)">
            <summary>
            Resolves IP address or host name to IPAddress object.
            If '*' used then it will auto-discovery remote address using https://www.ipify.org/.
            </summary>
        </member>
        <member name="F:Eco.Shared.Networking.RelayClient.RelayServerAddresses">
            <value>Remote address list for official relay servers.</value>
        </member>
        <member name="F:Eco.Shared.Networking.RelayClient.DefaultRelayServerPort">
            <value>Default Relay Server port.</value>
        </member>
        <member name="F:Eco.Shared.Networking.RelayClient.RelayServerProtocolVersion">
            <value>Current message serialization version, bump when message format changes.</value>
        </member>
        <member name="M:Eco.Shared.Networking.RelayClient.TryProcessRelayIntroduce(System.Net.IPEndPoint,Eco.Shared.Utils.Binary.ByteSpanReader@,System.Guid@,System.Net.IPEndPoint@)">
            <summary>
            Processes relay introduce message:
             [remote port:2 bytes][server id:guid].
            </summary>
            <param name="senderEndpoint">remote endpoint from which message received.</param>
            <param name="reader">reference to message data reader.</param>
            <param name="serverId">expected server id.</param>
            <param name="connectionEndPoint">output parameter for connection end point.</param>
        </member>
        <member name="T:Eco.Shared.Networking.RPCInvocation">
            <summary>
            Contains information about <see cref="T:Eco.Shared.Networking.RPCMethod"/> invocation including method itself, target and prepared args.
            Used as prepared call for <see cref="T:Eco.Shared.Networking.RPCManager"/> internally and also may be used externally if you need to do some kind of postprocessing/security checks on invocation.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.RPCInvocation.#ctor(Eco.Shared.Networking.RPCMethod,System.Object,System.Int32)">
            <summary>Creates <see cref="T:Eco.Shared.Networking.RPCInvocation"/> from method and target with null args. These args may be then set to required values with <see cref="P:Eco.Shared.Networking.RPCInvocation.Args"/> span accessor.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.RPCInvocation.Invoke">
            <summary>Performs the call.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.RPCInvocation.Dispose">
            <summary>Returns rented args array back to cache (for reusing arrays and reducing memory allocations).</summary>
        </member>
        <member name="M:Eco.Shared.Networking.RPCManager.CreateRPCPayload(Eco.Shared.Networking.INetClient,Eco.Shared.Networking.INetObject,System.String,System.Object[])">
            <summary>Creates RPC payload to be used with <see cref="M:Eco.Shared.Networking.NetObject.SendEvent(Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject,Eco.Shared.Networking.INetClient,Eco.Shared.Networking.INetObject)"/> with <see cref="F:Eco.Shared.Networking.NetworkEvent.RPC"/> event.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.RPCManager.TryCreateInvocation``1(Eco.Shared.Networking.INetClient,System.Object,System.String,System.Collections.Generic.IList{``0},System.Func{``0,System.Type,System.Object},Eco.Shared.Networking.RPCInvocation@)">
            <summary>
            Tries to create <see cref="T:Eco.Shared.Networking.RPCInvocation"/> for <paramref name="methodName"/> on <paramref name="target"/>. Method name either method ID (int) for distinguishing overrides or method name.
            If <paramref name="methodName"/> then it tries to find matching method by arguments.
            <paramref name="packedArgs"/> may be either list of <see cref="T:Eco.Shared.Serialization.BSONValue"/> or <see cref="T:System.Object"/>. Packed arg will be unpacked with <paramref name="unpackArg"/> function which accepts argument value and target type as parameters.
            Returns <c>false</c> if matching method not found. Throws exception if invalid args passed.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.RPCManager.GetAutoParameter(Eco.Shared.Networking.RPCMethod,Eco.Shared.Networking.INetClient)">
            <summary>Returns auto-parameter which exposed from <paramref name="client"/>: client itself, world observer or object which may be evaluated from observer (implementing <see cref="T:Eco.Shared.Networking.IObserverConversionTarget"/>).</summary>
        </member>
        <member name="M:Eco.Shared.Networking.RPCManager.PrepareInvocation``1(Eco.Shared.Networking.INetClient,System.Collections.Generic.IList{``0},System.Func{``0,System.Type,System.Object},Eco.Shared.Networking.RPCMethod,System.Object)">
            <summary>
            Unpacks list of <paramref name="packedArgs"/> to array of <paramref name="method"/> arguments using <paramref name="unpackArg"/> function.
            <paramref name="packedArgs"/> may be either list of <see cref="T:Eco.Shared.Serialization.BSONValue"/> or <see cref="T:System.Object"/>. Packed arg will be unpacked with <paramref name="unpackArg"/> function which accepts argument value and target type as parameters.
            Then unpacked args together with <paramref name="method"/> and <paramref name="target"/> used to create an <see cref="T:Eco.Shared.Networking.RPCInvocation"/>.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.RPCManager.FromObjArg(System.Object,System.Type)">
            <summary>Converts <paramref name="arg"/> to <paramref name="targetType"/>. For now just returns arg, but this logic may be improved with smart casts.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.RPCMethodFlags">
            <summary>Important flags for <see cref="T:Eco.Shared.Networking.RPCMethod"/>.</summary>
        </member>
        <member name="P:Eco.Shared.Networking.ServerInfo.External">
            <value>
            Set by master server if this server is available directly by external IP address.
            </value>
        </member>
        <member name="P:Eco.Shared.Networking.ServerInfo.RelayAddress">
            <value>
            Optional relay address, may be set by server to inform clients how to connect to this server if connect in usual way (direct/NAT Punch Through) doesn't work.
            </value>
        </member>
        <member name="P:Eco.Shared.Networking.ServerInfo.Access">
            <summary> Access mode of server: "public", "hidden", or "private". </summary>
        </member>
        <member name="P:Eco.Shared.Networking.ServerInfo.JoinUrl">
            <summary> Used by the built in web server to allow connecting to the server via the website. Contains the full uri protocol connection string for this server </summary>
        </member>
        <member name="T:Eco.Shared.Networking.Udp.DisconnectReason">
            <summary> Enum for different disconnect reasons which may be produced by <see cref="T:Eco.Shared.Networking.Udp.IUdpPeer"/>. </summary>
        </member>
        <member name="T:Eco.Shared.Networking.Udp.IUdpClient">
            <summary>
            Interface for Upd client.
            It contains client specific methods and properties (like <see cref="P:Eco.Shared.Networking.Udp.IUdpClient.ConnectionStatus"/> or <see cref="M:Eco.Shared.Networking.Udp.IUdpClient.Disconnect"/>).
            </summary>
        </member>
        <member name="T:Eco.Shared.Networking.Udp.IUdpLibrary">
            <summary>
            Interface for UDP libraries. Use this to create network lib peers.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUdpLibrary.CreateClient(System.String,System.UInt32,System.UInt32)">
            <summary>
            Create UPD client for app with <c>appIdentifier</c>.
            </summary>
            <param name="appIdentifier">app identifier.</param>
            <param name="protocolVersion">version of binary protocol used between client and server.</param>
            <param name="connectTimeoutMs">connection timeout (time before Disconnect event received with <see cref="F:Eco.Shared.Networking.Udp.DisconnectReason.Timeout"/>).</param>
            <returns><see cref="T:Eco.Shared.Networking.Udp.IUdpClient"/> implementation instance for this lib.</returns>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUdpLibrary.CreateServer(System.String,System.UInt32,System.Net.IPEndPoint,System.Int32)">
            <summary>
            Create UPD server for app with <c>appIdentifier</c>.
            </summary>
            <param name="appIdentifier">App identifier.</param>
            <param name="protocolVersion">version of binary protocol used between client and server.</param>
            <param name="requestedEndPoint">Request endpoint for the server. You can use <c>IPEndPoint.Any</c> for address or <c>0</c>
            for port if you want to have automatically assigned values.</param>
            <param name="maxConnections">Maximum number of connections. <c>0</c> - for maximum possible.</param>
            <returns><see cref="T:Eco.Shared.Networking.Udp.IUdpServer"/> implementation instance for this lib.</returns>
        </member>
        <member name="T:Eco.Shared.Networking.Udp.IUdpPeer">
            <summary>
            Base interface for all UPD peers (either client or server).
            Contains common UPD transport methods: like Connect to specific peer, Send to peer or Receive message.
            </summary>
        </member>
        <member name="T:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer">
            <summary>
            Interface for unconnected UPD peers.
            Contains UPD Peer Api for unconnected messages only.
            </summary>
        </member>
        <member name="E:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.UnconnectedDataMessageReceived">
            <summary>
            Event called when unconnected data message received.
            </summary>
        </member>
        <member name="E:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.ErrorMessageReceived">
            <summary>
            Event called when an error message received.
            </summary>
        </member>
        <member name="E:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.WarningMessageReceived">
            <summary>
            Event called when a warning message received.
            </summary>
        </member>
        <member name="E:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.DebugMessageReceived">
            <summary>
            Event called when a debug message received.
            </summary>
        </member>
        <member name="P:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.MaximumUnconnectedMessageLength">
            <summary>
            MTU - maximum transmission unit size. Maximum size of UPD packet.
            </summary>
        </member>
        <member name="P:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.Port">
            <summary>
            Gets local port.
            </summary>
        </member>
        <member name="P:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.IsRunning">
            <summary>
            Gets running state of the peer.
            </summary>
        </member>
        <member name="P:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.LocalEndPoint">
            <summary>
            Local IP End Point for the peer.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.SendRaw(System.Net.IPEndPoint,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sends raw data with socket to destination peer.
            It releases buffer after a send operation, so it is safe to reuse the <c>messageData</c> buffer.
            </summary>
            <param name="remoteEndPoint">destination end point.</param>
            <param name="messageData">message data to send.</param>
            <param name="offset">offset in message data.</param>
            <param name="length">length of message.</param>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.SendUnconnectedMessage(System.Net.IPEndPoint,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sends unconnected message with network lib to destination peer.
            It releases buffer after a send operation, so it is safe to reuse the <c>messageData</c> buffer.
            </summary>
            <param name="remoteEndPoint">destination end point.</param>
            <param name="messageData">message data to send.</param>
            <param name="offset">offset in message data.</param>
            <param name="length">length of message.</param>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.Start">
            <summary>
            Starts peer. Makes initialization, creates socket and optionally starts background message processing thread.
            You need to call <see cref="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.Service(System.Int32)"/> or <see cref="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.ServiceOne(System.Int32)"/> to have network messages processed and trigger message events.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.Shutdown">
            <summary>
            Shutdowns peers. Releases resources and stops background threads (if any).
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.Service(System.Int32)">
            <summary>
            Services network messages - sending, receiving, connecting etc. You should call this method regular.
            /// Typical usage is following:
            <code>
            while (peer.IsRunning)
               peer.Service(10);
            </code>
            You can service single network event with <see cref="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.ServiceOne(System.Int32)"/>.
            </summary>
            <param name="timeoutMs">Maximum timeout between events. It will return if timeout exceed.</param>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.ServiceOne(System.Int32)">
            <summary>
            Same as <see cref="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.Service(System.Int32)"/>, but only service single network event.
            </summary>
            <param name="timeoutMs">Maximum timeout until event. It will return <c>false</c> if the event won't happen.</param>
            <returns><c>true</c> if the event serviced, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.SyncTimer(System.Double)">
            <summary>
            Synchronize timers. Ensures local timer and network timer will use same time base.
            </summary>
            <param name="currentTimeInSeconds">current time on your timer.</param>
        </member>
        <member name="T:Eco.Shared.Networking.Udp.SimpleUnconnectedUdpPeer">
            <summary> Simplest implementation of Unconnected UDP peer (used by master server) which doesn't use any third-party library, but just async sockets from .NET Core. </summary>
        </member>
        <member name="F:Eco.Shared.Networking.Udp.SimpleUnconnectedUdpPeer.ENetMtu">
            <summary> ENet Network Library MTU, we should have unconnected messages &lt;= MTU to be received by ENet. </summary>
        </member>
        <member name="T:Eco.Shared.Numerics.Vector3Ex">
            <summary>Extension functions for <see cref="T:System.Numerics.Vector3"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Numerics.Vector3Ex.WrappedDistanceSq(System.Numerics.Vector3,System.Numerics.Vector3)">
            <summary>Calculates wrapped squared distance (using <see cref="P:Eco.Shared.Voxel.World.WrappedVoxelSize"/> for wrapped space).</summary>
        </member>
        <member name="M:Eco.Shared.Numerics.Vector3Ex.WithY(System.Numerics.Vector3,System.Single)">
            <summary>Returns new <see cref="T:System.Numerics.Vector3"/> with <see cref="F:System.Numerics.Vector3.Y"/> component replaced with <paramref name="y"/> value.</summary>
        </member>
        <member name="M:Eco.Shared.Pathing.AITarget.Clear">
            <summary>Stop moving along any routes, and clear targets.</summary>
        </member>
        <member name="P:Eco.Shared.Pathing.AITarget.TargetPosition">
            <summary> Returns either the target object position (if available) and updates <see cref="F:Eco.Shared.Pathing.AITarget.targetPos"/> to last known position or returns <see cref="F:Eco.Shared.Pathing.AITarget.targetPos"/> with fallback to default value otherwise. </summary>
        </member>
        <member name="M:Eco.Shared.Pathing.AITarget.TryGetTargetObject(Eco.Shared.Networking.INetObjectPosition@)">
            <summary> Returns <paramref name="targetObj"/> if it is set and available in <see cref="T:Eco.Shared.Networking.NetObjectManager"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Pathing.AITarget.SetPosition(Eco.Shared.Math.Vector3)">
            <summary> Clear the route and set the position as passed. </summary>
        </member>
        <member name="M:Eco.Shared.Pathing.AITarget.SetLook(Eco.Shared.Networking.INetObjectPosition)">
            <summary> Sets look to <paramref name="followingTarget"/>. If <paramref name="followingTarget"/> is null then resets look target. </summary>
        </member>
        <member name="M:Eco.Shared.Pathing.AITarget.SetLook(Eco.Shared.Math.Vector3i)">
            <summary> Sets look to fixed <paramref name="pos"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Pathing.RouteFollower.SetRoute(Eco.Shared.Math.Route,System.Double)">
            <summary> Set the route, when we start, our speed, an an optional target to watch.</summary>
        </member>
        <member name="M:Eco.Shared.Pathing.RouteFollower.Position(System.Single)">
            <summary> Take the expected position at given time.</summary>
            <param name="lookAhead">Offset distance is adding to a calculated position.</param>
        </member>
        <member name="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.GetUnsafeListSnapshot">
            <summary>
            Returns unsafe list snapshot which may be directly accessed with <see cref="T:System.Collections.Generic.List`1"/> API.
            This list only safe to use before any modification operation like <see cref="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.Clear"/>, <see cref="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.AddRange(System.Collections.Generic.ICollection{`0})"/> etc.
            Also you should guarantee this list won't exceed current <see cref="P:System.Collections.Generic.List`1.Capacity"/> otherwise it may lead to unexpected behavior (including exceptions).
            </summary>
            <returns>Current snapshot reference. It may be null if Capacity == 0.</returns>
        </member>
        <member name="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.RentSnapshotAndClear">
            <summary>
            Returns current list snapshot and clear poolable list wrapper.
            </summary>
            <returns>Current snapshot. It may be null if Capacity == 0.</returns>
        </member>
        <member name="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.ReturnSnapshot(System.Collections.Generic.List{`0})">
            <summary>
            Return previously rented snapshot (see <see cref="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.RentSnapshotAndClear"/>).
            This method is thread-safe. Usual case you rent list in thread-unsafe content and then return it in another thread.
            </summary>
        </member>
        <member name="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.GetUnsafeListSnapshot(System.Int32)">
            <summary>
            Same as <see cref="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.GetUnsafeListSnapshot"/>, but ensures required capacity.
            </summary>
            <param name="minimalCapacity">minimal required capacity for snapshot.</param>
            <returns>Current snapshot reference. It may be null if Capacity == 0.</returns>
        </member>
        <member name="T:Eco.Shared.Pools.FixedSizePool`1">
            <summary>Implementation of <see cref="T:Eco.Shared.Pools.ThreadSafeFixedSizePool`1"/> with extended functionality. Obsolete, should be replaced with <see cref="T:Eco.Shared.Pools.PoolService`1"/> when all functionality will be supported.</summary>
        </member>
        <member name="M:Eco.Shared.Pools.FixedSizePool`1.Get">
            <summary>
            Returns a object from the pool or null if no objects in the pool.
            </summary>
            <returns>object from the pool or a new object.</returns>
        </member>
        <member name="M:Eco.Shared.Pools.FixedSizePool`1.TryAdd(`0)">
            <summary>Tries to add object to the pool (if enough capacity in the pool).</summary>
        </member>
        <member name="T:Eco.Shared.Pools.IObjectPool`1">
            <summary> Minimal Pool interface. If you wanna to have more advanced pool management you can use <see cref="T:Eco.Shared.Pools.PoolService`1"/>. </summary>
        </member>
        <member name="P:Eco.Shared.Pools.IObjectPool`1.Count">
            <summary> Current number of elements in pool. </summary>
        </member>
        <member name="M:Eco.Shared.Pools.IObjectPool`1.Get">
            <summary> Returns object from pool (if any) or <c>null</c> if pool is empty. It doesn't create new instance. </summary>
        </member>
        <member name="M:Eco.Shared.Pools.IObjectPool`1.TryAdd(`0)">
            <summary> Tries to add <paramref name="obj"/> to pool. If succeed then it returns <c>true</c>, otherwise (if pool is full or object is incompatible with pool) it will return <c>false</c>. You can handle return value for final object cleanup. </summary>
        </member>
        <member name="M:Eco.Shared.Pools.ListPool`1.Return(System.Collections.Generic.List{`0})">
            <summary>
            Use this with caution! If you will return list which was exceeded requested capacity then you can give an exception.
            </summary>
            <param name="list">list which was rented from pool.</param>
        </member>
        <member name="T:Eco.Shared.Pools.ObjectPoolExtensions">
            <summary>Extension methods for <see cref="T:Eco.Shared.Pools.IObjectPool`1"/> instances.</summary>
        </member>
        <member name="M:Eco.Shared.Pools.ObjectPoolExtensions.AsService``1(Eco.Shared.Pools.IObjectPool{``0},System.Action{``0})">
            <summary>
            Wraps <paramref name="pool"/> with <see cref="T:Eco.Shared.Pools.PoolService`1"/> with default constructor for new pool elements and optional <paramref name="onReturn"/> cleanup method.
            With this factory method <code><![CDATA[new PoolService<MyClass>(new MyPool<MyClass>(), () => new MyClass(), onReturn)]]></code> can be rewritten as <code><![CDATA[new MyPool<MyClass>().AsService(onReturn)]]></code>.
            </summary>
        </member>
        <member name="M:Eco.Shared.Pools.ObjectPoolExtensions.AsService``1(Eco.Shared.Pools.IObjectPool{``0},System.Func{``0},System.Action{``0})">
            <summary>
            Wraps <paramref name="pool"/> with <see cref="T:Eco.Shared.Pools.PoolService`1"/> with <paramref name="factory"/> for new pool elements and optional <paramref name="onReturn"/> cleanup method.
            With this factory method <code><![CDATA[new PoolService<MyClass>(new MyPool<MyClass>(), () => new MyClass("abc"))]]></code> can be rewritten as <code><![CDATA[new MyPool<MyClass>().AsService(() => new MyClass("abc"))]]></code>.
            </summary>
        </member>
        <member name="T:Eco.Shared.Pools.PooledMemoryStream">
            <summary>
            PooledMemoryStream (based on https://github.com/itn3000/PooledStream).
            It uses .NET Standard <see cref="T:System.Buffers.ArrayPool`1"/> for buffer allocations.
            Also it has <see cref="M:Eco.Shared.Pools.PooledMemoryStream.Truncate"/> which returns buffer to <see cref="T:System.Buffers.ArrayPool`1"/> and resets length, position and capacity to zero.
            It makes the stream reusable without holding extra memory for buffer.
            </summary>
        </member>
        <member name="F:Eco.Shared.Pools.PooledMemoryStream.Shared">
            <summary>Shared pool of <see cref="T:Eco.Shared.Pools.PooledMemoryStream"/> for zero-allocations <see cref="T:System.IO.MemoryStream"/> instances.</summary>
        </member>
        <member name="M:Eco.Shared.Pools.PooledMemoryStream.GetBuffer">
            <summary>
            This buffer is only valid until next Write or Reset operation.
            </summary>
            <returns>current buffer.</returns>
        </member>
        <member name="T:Eco.Shared.Pools.PoolService`1">
            <summary>
            <see cref="T:Eco.Shared.Pools.IObjectPool`1"/> manager which simplifies pool usage, adding methods for automatic objects creation and cleaning up when returned to pool.
            When <see cref="T:Eco.Shared.Pools.PoolService`1"/> created you should provide <see cref="F:Eco.Shared.Pools.PoolService`1.factory"/> method for new object instantiation (if pool is empty) and optionally
            <see cref="F:Eco.Shared.Pools.PoolService`1.onReturn"/> method which will be called on an object when it returned (added) to pool.
            </summary>
        </member>
        <member name="M:Eco.Shared.Pools.PoolService`1.Rent">
            <summary> Rents object from pool or creates new instance using <see cref="F:Eco.Shared.Pools.PoolService`1.factory"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Pools.PoolService`1.Return(`0)">
            <summary>
            Returns (add) <paramref name="value"/> to the pool. If <see cref="F:Eco.Shared.Pools.PoolService`1.onReturn"/> method was provided then it will be called on <paramref name="value"/> <b>before</b> adding to pool.
            Also it may fail to add <paramref name="value"/> to <see cref="F:Eco.Shared.Pools.PoolService`1.pool"/> (in example if <see cref="F:Eco.Shared.Pools.PoolService`1.pool"/> is fixed size and already full).
            In this case <see cref="F:Eco.Shared.Pools.PoolService`1.onReturn"/> will be called anyway, but method return <c>false</c>. It returns <c>true</c> if object was actually added to pool, you can check return value for final object cleanup.
            </summary>
        </member>
        <member name="T:Eco.Shared.Pools.ThreadSafeFixedSizePool`1">
             <summary>
             Fixed Size Pool used to avoid any extra-GC allocations, unless requesting more items from pool than are available.
             It uses circular buffer where
             `tail` points to first element which will be retrieved from pool on request (read position)
             `head` points to next write position which will be used for returning element to pool (write position)
             when `head` == `tail` then buffer is empty
             when `head` == `tail - 1` then buffer is full
             we're using `poolSize + 1` for capacity to maintain full buffer scenario, because otherwise we can have two situations when write position == read position (empty and full).
            
             Performance:
             ~2x faster in concurrent environment than basic Stack based pool implementation with lock
             ~10% faster in single-thread environment than basic Stack based pool implementation with lock.
             </summary>
             <typeparam name="T"></typeparam>
        </member>
        <member name="P:Eco.Shared.Pools.ThreadSafeFixedSizePool`1.MaxSize">
            <summary>Max number of elements in the pool.</summary>
        </member>
        <member name="M:Eco.Shared.Pools.ThreadSafeFixedSizePool`1.Get">
            <summary>
            Returns a object from the pool or null if no objects in the pool.
            </summary>
            <returns>object from the pool or a new object.</returns>
        </member>
        <member name="M:Eco.Shared.Pools.ThreadSafeFixedSizePool`1.TryAdd(`0)">
            <summary>
            Tries to add object to the pool (if enough capacity in the pool).
            </summary>
            <param name="obj"></param>
        </member>
        <member name="T:Eco.Shared.Pools.ThreadSafePool`1">
            <summary>
            Simple thread-safe <see cref="T:System.Collections.Generic.Stack`1"/> based pool implementation. It implements <see cref="T:Eco.Shared.Pools.IObjectPool`1"/> interface and has unlimited pool size.
            For optimal performance you should prefer thread-safe lock free <see cref="T:Eco.Shared.Pools.FixedSizePool`1"/>, but it has fixed pool size and can't be shrink or extended.
            </summary>
        </member>
        <member name="T:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1">
            <summary>
            Thread-unsafe lock free <see cref="T:System.Collections.Generic.Stack`1"/> based pool implementation. It implements <see cref="T:Eco.Shared.Pools.IObjectPool`1"/> interface and has fixed pool size.
            You should prefer it to use over thread-safe pool implementations where you're sure it won't be used from multiple threads (in example in Unity components).
            </summary>
        </member>
        <member name="P:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.MaxSize">
            <summary>
            Max number of elements in pool.
            It actually may be less than actual number of elements if <see cref="P:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.MaxSize"/> was reduced when <see cref="P:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.Count"/> &gt; <see cref="P:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.MaxSize"/>.
            In this case it will not add objects with <see cref="M:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.TryAdd(`0)"/> until <see cref="P:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.Count"/> go below <see cref="P:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.MaxSize"/>.
            </summary>
        </member>
        <member name="T:Eco.Shared.Pools.ThreadUnsafePool`1">
            <summary>
            Thread-unsafe lock free <see cref="T:System.Collections.Generic.Stack`1"/> based pool implementation. It implements <see cref="T:Eco.Shared.Pools.IObjectPool`1"/> interface and has unlimited pool size.
            You should prefer it to use over thread-safe pool implementations where you're sure it won't be used from multiple threads (in example in Unity components).
            </summary>
        </member>
        <member name="T:Eco.Shared.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Eco.Shared.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Eco.Shared.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BsonManipulator.ObjectTypeHandler(Eco.Shared.Serialization.BSONValue)">
            <summary> Unpacks object from <see cref="T:Eco.Shared.Serialization.BSONValue"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BsonManipulator.MakeGenericDictionarySerializer(System.Type)">
            <summary> Makes generic dictionary lightweight (no reflection) delegate which just converts first argument from non-generic to generic dictionary and passes all other arguments. </summary>
            todo: move to reflection utils
        </member>
        <member name="T:Eco.Shared.Serialization.BSONArray">
            <summary>Array of <see cref="T:Eco.Shared.Serialization.BSONValue"/> items. Used in binary serialization while data transfer data between client and server.</summary>
        </member>
        <member name="F:Eco.Shared.Serialization.BSONObject.refs">
            <value> References count. </value>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryIncrementRef">
            <summary>
            Every time when you create a ref for shared BSONObject you have to increment ref.
            In this case it will be recycled only when last ref will be recycled.
            </summary>
            <returns><c>true</c> if ref was increased, <c>false</c> if ref can't be increased because of all existing refs was already recycled and this object is invalid.</returns>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryGetStringValue(System.String,System.String@)">
            <summary> Returns value for <paramref name="key"/> converted to <see cref="T:System.String"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryGetGuidValue(System.String,System.Guid@)">
            <summary> Returns value for <paramref name="key"/> converted to <see cref="T:System.Guid"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryGetInt32Value(System.String,System.Int32@)">
            <summary> Returns value for <paramref name="key"/> converted to <see cref="T:System.Int32"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryGetInt64Value(System.String,System.Int64@)">
            <summary> Returns value for <paramref name="key"/> converted to <see cref="T:System.Int64"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryGetFloatValue(System.String,System.Single@)">
            <summary> Returns value for <paramref name="key"/> converted to <see cref="T:System.Single"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryGetDoubleValue(System.String,System.Double@)">
            <summary> Returns value for <paramref name="key"/> converted to <see cref="T:System.Double"/>. </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.BSONSimpleValue">
            <summary>Represents simple value (like float, double, int, string etc).</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONSimpleValue.TryPerformRecycle">
            <summary>Releases all resources (nullify refs for GC and return pooled objects).</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONSimpleValue.DisablePooling``1(``0[]@)">
            <summary>Disables pooling for <paramref name="array"/> and ensures the array has correct size, because pooled array may be greater than actual array.</summary>
        </member>
        <member name="T:Eco.Shared.Serialization.BSONValue">
            <summary>Base class for <see cref="T:Eco.Shared.Serialization.BSONSimpleValue"/>, <see cref="T:Eco.Shared.Serialization.BSONArray"/> and <see cref="T:Eco.Shared.Serialization.BSONObject"/>.</summary>
        </member>
        <member name="P:Eco.Shared.Serialization.BSONValue.BinaryValue">
            <summary>Returns array of byte values. When possible use <see cref="P:Eco.Shared.Serialization.BSONValue.ByteSpanValue"/> instead to reduce allocations with pooling. When array accessed then we can't control references on it anymore and can't return it back to pool.</summary>
        </member>
        <member name="P:Eco.Shared.Serialization.BSONValue.ByteSpanValue">
            <summary>Returns byte <see cref="T:System.ReadOnlySpan`1"/>, should always be preferred over <see cref="P:Eco.Shared.Serialization.BSONValue.BinaryValue"/> because latter disables pooling for the value.</summary>
        </member>
        <member name="P:Eco.Shared.Serialization.BSONValue.UShortArrayValue">
            <summary>Returns array of ushort values. When possible use <see cref="P:Eco.Shared.Serialization.BSONValue.UShortSpanValue"/> instead to reduce allocations with pooling. When array accessed then we can't control references on it anymore and can't return it back to pool.</summary>
        </member>
        <member name="P:Eco.Shared.Serialization.BSONValue.UShortSpanValue">
            <summary>Returns ushort <see cref="T:System.ReadOnlySpan`1"/>, should always be preferred over <see cref="P:Eco.Shared.Serialization.BSONValue.UShortArrayValue"/> because latter disables pooling for the value.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONValue.NewViewRef(System.Int32)">
            <summary>Creates new <see cref="F:Eco.Shared.Serialization.BSONValueType.ViewRef"/> value.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONValue.NewTypeId(System.Int32)">
            <summary>Creates new <see cref="F:Eco.Shared.Serialization.BSONValueType.ViewTypeId"/> value.</summary>
        </member>
        <member name="T:Eco.Shared.Serialization.BSONValueFactory`1">
            <summary>Reusable <see cref="T:Eco.Shared.Serialization.BSONValue"/> values factory.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONValueFactory`1.New(Eco.Shared.Serialization.BSONValueType)">
            <summary>Either makes new <see cref="T:Eco.Shared.Serialization.BSONValue`1"/> with <see cref="F:Eco.Shared.Serialization.BSONValueFactory`1.newInstance"/> or uses recycled value from <see cref="F:Eco.Shared.Serialization.BSONValueFactory`1.recycledBsons"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONValueFactory`1.Recycle(`0)">
            <summary>Recycles <paramref name="value"/> making it available for re-usage.</summary>
        </member>
        <member name="T:Eco.Shared.Serialization.BSONValueType">
            <summary>Value type of <see cref="T:Eco.Shared.Serialization.BSONValue"/>. <see cref="T:Eco.Shared.Serialization.BSONValue"/> may be used to store different value types and with that enum they may be distinguished.</summary>
        </member>
        <member name="T:Eco.Shared.Serialization.SerializedAttribute">
            <summary> This symbol will be serialized to BSON for storage in the world file. </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.ForceSerializeFullObjectAttribute">
            <summary> Used in conjunction with SerializedAttribute to designate that a member needs to be fully saved, not using references. </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.UsesReferenceInHashCode">
            <summary> Used when a class needs references resolved before it can calculate its hashcode. </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.SerializedDerivedAttribute">
            <summary> Will be serialized to BSON for storage in the world file, and applies to all derived classes too. </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.ThreadSafeAttribute">
            <summary>
            When serializing some types, such as enumerables, the enumeration must not change - to enforce this, some designate "threadsafe" objects use this attribute, such as the immutable collections.
            When using this attribute manually, proper locking and other checks must be used the ensure thread safety - in general, use the ThreadSafe collections, but if you are SURE that your container
            is thread safe, go ahead and add this attribute.
            </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.SerializesTypeAttribute">
            <summary> Specify that this class serializes specific object types that might not otherwise be determined through reflection. </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.JsonUseAttribute">
            <summary>
            Overrides default strategy for ExpandableObjectContractResolver, it will use this attribute even if read-only and serializeReadOnlyProperties == false.
            </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.SharedBSONObject">
            <summary>
            Use this object if you have to share bson object.
            I.e. Player.animationData stored as shared object and then delivered to all clients.
            It keeps tracking of all object references and only recycle object when all references recycled.
            </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.SimpleBSON.LoadCompressed(System.ReadOnlySpan{System.Byte})">
            <summary>Loads <see cref="T:Eco.Shared.Serialization.BSONObject"/> from LZ4 compressed <paramref name="data"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.SimpleBSON.DumpTo(System.IO.MemoryStream,Eco.Shared.Serialization.BSONArray)">
            <summary> Dumps BSON array to memory stream. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.SimpleBSON.RentOrCreateArray``1(Eco.Shared.Serialization.BSONSimpleValue,System.Int32,``0[]@)">
            <summary>Rents array from shared pool when it makes sense for it's size and configures <paramref name="bson"/> accordingly (set arraySize and poolingEnabled flag).</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.SimpleBSON.DecodeLocString(System.IO.MemoryStream)">
            <summary> Decodes LocString from binary data. <see cref="M:Eco.Shared.Serialization.SimpleBSON.EncodeLocString(System.IO.MemoryStream,Eco.Shared.Localization.LocString)"/> about binary format details. </summary>
        </member>
        <member name="T:Eco.Shared.Services.ElectionComment">
            <summary>A custom tailored comment for use in elections web interface (ElectionController). Gets stored in Election.</summary>
        </member>
        <member name="T:Eco.Shared.Services.ExcludeFromChatAttribute">
            <summary>Don't show this category in chat tab picker</summary>
        </member>
        <member name="T:Eco.Shared.Services.LockedInChinaAttribute">
            <summary> attribute for making properties readonly when ChinaLockedMode </summary>
            used mainly for testing, allowing to use props otherwise hidden 
        </member>
        <member name="T:Eco.Shared.Services.VisibleForQAOnlyAttribute">
            <summary> attribute for making plugin properties visible when QA enabled </summary>
            used mainly for testing, allowing to display/interect with props otherwise hidden 
            e.g.: expose ChinaLockedMode prop for QA
        </member>
        <member name="M:Eco.Shared.Services.QualityAssurance.IsQAModeActive">
            <summary>Is QA mode enabled/disabled</summary>
        </member>
        <member name="M:Eco.Shared.Services.QualityAssurance.EnableAll(System.Boolean)">
            <summary>Enables all QA options</summary>
        </member>
        <member name="M:Eco.Shared.Services.QualityAssurance.DisableAll(System.Boolean)">
            <summary>Disables all QA options</summary>
        </member>
        <member name="M:Eco.Shared.Services.QualityAssurance.Enable(System.Boolean,System.Boolean)">
            <summary>Enables/Disables all QA options</summary>
            <param name="includeAuth">Include Authentication options <see cref="T:Eco.Shared.Authentication.DevAuthentication"/></param>
        </member>
        <member name="T:Eco.Shared.States.ExpressionEmote">
            <summary> Stores the various player (facial) expression emote states. </summary>
        </member>
        <member name="T:Eco.Shared.States.AnimationEmote">
            <summary> Stores the various player (body) emote states. </summary>
        </member>
        <member name="T:Eco.Shared.States.ModularVehicleToolState">
            <summary> Stores current vehicle tool state, depending on animation/delays/etc </summary>
        </member>
        <member name="T:Eco.Shared.Streams.FastBufferedWriteStream">
            <summary>Fast optimized alternative to <see cref="T:System.IO.BufferedStream"/> with write-only non-seekable support which allows to minimize number of checks and calculations, because of limitations.</summary>
        </member>
        <member name="T:Eco.Shared.Streams.FastReusableBufferedWriteStream">
            <summary>Extends <see cref="T:Eco.Shared.Streams.FastBufferedWriteStream"/> with re-usability logic. It allows to call <see cref="M:Eco.Shared.Streams.FastReusableBufferedWriteStream.Reset(System.IO.Stream)"/> with new backing stream instead of new buffered stream instance creation. Initially initialized with <see cref="F:System.IO.Stream.Null"/> backing stream.</summary>
        </member>
        <member name="M:Eco.Shared.Streams.FastReusableBufferedWriteStream.Reset(System.IO.Stream)">
            <summary>Use this method to Reset to another backing Stream. It won't Flush to previous stream so you should call <see cref="M:Eco.Shared.Streams.FastBufferedWriteStream.Flush"/> explicitly if needed.
            <see cref="P:Eco.Shared.Streams.FastBufferedWriteStream.Position"/> and <see cref="P:Eco.Shared.Streams.FastBufferedWriteStream.Length"/> set to 0 after call to the method.</summary>
        </member>
        <member name="T:Eco.Shared.Streams.SubStream">
            <summary>
            Wrapper around existing stream which allows to use portion of stream without copying it to another stream.
            </summary>
        </member>
        <member name="P:Eco.Shared.Streams.SubStream.CanSeek">
            <summary>
             Not supported for now, but may be implemented.
            </summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AddSection(Eco.Shared.Localization.LocString,Eco.Shared.Text.InfoBuilder)">
            <summary>
            Add a section.
            </summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AddSectionLoc(System.FormattableString,Eco.Shared.Text.InfoBuilder)">
            <summary>See <see cref="M:Eco.Shared.Text.InfoBuilder.AddSection(Eco.Shared.Localization.LocString,Eco.Shared.Text.InfoBuilder)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AddSectionLocStr(System.String,Eco.Shared.Text.InfoBuilder)">
            <summary>See <see cref="M:Eco.Shared.Text.InfoBuilder.AddSection(Eco.Shared.Localization.LocString,Eco.Shared.Text.InfoBuilder)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AddDashSectionLocStr(System.String,Eco.Shared.Text.InfoBuilder)">
            <summary>Adds '- ' to section tittle. See <see cref="M:Eco.Shared.Text.InfoBuilder.AddSection(Eco.Shared.Localization.LocString,Eco.Shared.Text.InfoBuilder)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AppendLine">
            <summary> Appends new line to <see cref="T:Eco.Shared.Text.InfoBuilder"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AppendLine(Eco.Shared.Localization.LocString)">
            <summary> Appends <see cref="T:Eco.Shared.Localization.LocString"/> with new line to <see cref="T:Eco.Shared.Text.InfoBuilder"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AppendLineLoc(System.FormattableString)">
            <summary>See <see cref="M:Eco.Shared.Text.InfoBuilder.AppendLine(Eco.Shared.Localization.LocString)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AppendDashLineLoc(System.FormattableString)">
            <summary>Adds '- ' to line. See <see cref="M:Eco.Shared.Text.InfoBuilder.AppendLine(Eco.Shared.Localization.LocString)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AppendLineLocStr(System.String)">
            <summary>See <see cref="M:Eco.Shared.Text.InfoBuilder.AppendLine(Eco.Shared.Localization.LocString)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AppendDashLineLocStr(System.String)">
            <summary> Adds '- ' to line, See <see cref="M:Eco.Shared.Text.InfoBuilder.AppendLine(Eco.Shared.Localization.LocString)"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Threshold.IThreshold`1">
            <summary>
            Threshold value interface. May be used to update value with threshold checking to avoid spamming value change events.
            </summary>
        </member>
        <member name="M:Eco.Shared.Threshold.IThreshold`1.TryPass(`0)">
            <summary>
            Try pass threshold with specified <paramref name="delta"/>. It will aggregate delta for multiple calls until the threshold reached then total delta value will reset.
            </summary>
            <param name="delta">delta between last value and new value.</param>
            <returns><c>true</c> if threshold passed with this (and all previous deltas), <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Eco.Shared.Threshold.IThreshold`1.UpdateValue(`0@,`0)">
            <summary> Updates <paramref name="value"/> to <paramref name="newValue"/>. It returns result of (see <see cref="M:Eco.Shared.Threshold.IThreshold`1.TryPass(`0)"/>) for delta between <paramref name="value"/> and <paramref name="newValue"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Threshold.IThreshold`1.ClampValue(`0@,`0,`0,`0)">
            <summary> It updates value as <see cref="M:Eco.Shared.Threshold.IThreshold`1.UpdateValue(`0@,`0)"/>, but also clamps it to specified range and if the value changed and <paramref name="newValue"/> on bounds then returns <c>true</c>. </summary>
        </member>
        <member name="T:Eco.Shared.Time.TimeLimit">
            <summary>Represents time limit which may be checked for expiration and overtime.</summary>
        </member>
        <member name="M:Eco.Shared.Time.TimeLimit.#ctor(System.Int64)">
            <summary>Creates <see cref="T:Eco.Shared.Time.TimeLimit"/> from <see cref="T:System.Diagnostics.Stopwatch"/> ticks (note they may be not same as <see cref="P:System.TimeSpan.Ticks"/>).</summary>
        </member>
        <member name="M:Eco.Shared.Time.TimeLimit.SubLimitFromTicks(System.Int64,System.Int64@)">
            <summary> Creates new limit with upper bound set to current limit. </summary>
            <param name="ticks">new limit ticks.</param>
            <param name="truncatedTicks">number of ticks truncated to match current limit.</param>
            <returns>new TimeLimit object.</returns>
        </member>
        <member name="T:Eco.Shared.Tools.DetectingPerformanceCounter">
            <summary><see cref="T:Eco.Shared.Tools.PerformanceCounter"/> which detects values which has duration over expected and emits static event for them.</summary>
            <inheritdoc/>
        </member>
        <member name="E:Eco.Shared.Tools.DetectingPerformanceCounter.PerformanceIssueDetected">
            <summary>Event which reported every time when outstanding value detected. Stack trace is optional and only provided when <see cref="F:Eco.Shared.Tools.DetectingPerformanceCounter.GrabStacktrace"/> is <c>true</c>.</summary>
        </member>
        <member name="T:Eco.Shared.Tools.PerformanceCounter">
            <summary>
            A PerformanceCounter is a collection of values with performance data for a single topic.
            Values will be grouped together under the PerformanceCounter name, but can optionally have text associated
            with them individually too.
            </summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounter.#ctor(System.String,System.Int32)">
            <summary>Create a PerformanceCounter with the maximum number of historical values stored.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounter.AddValue(System.String)">
            <summary> Add a value with an optional name. Call Dispose to end duration time, or use a using block.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounter.AddValue(System.TimeSpan,System.String)">
            <summary> Add a value with an optional name with known duration.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounter.AddMarker">
            <summary> Add an event marker, which is a durationless event.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounter.Add(System.TimeSpan,System.String)">
            <summary>
            "Adds" new performance counter value.
            It may be added as pre-calculated value (then it should have <paramref name="initialDuration"/>) or as value start point.
            In this case returned value should be disposed to record elapsed duration.
            You can also provide optional name for the report (may be useful if you share one counter for multiple similar metrics like RPC calls for different functions).
            </summary>
            <remarks>
            This method not actually adds new value every time, but instead allocates index in pre-created array of values for optimal performance and memory allocations.
            This array of values works as cyclic buffer. Once filled it will start again from first index. Iterating through the array you will always have last <see cref="F:Eco.Shared.Tools.PerformanceCounter.MaxValues"/>.
            <p><see cref="F:Eco.Shared.Tools.PerformanceCounter.Head"/> always set to next write position. It uses CAS for atomic <see cref="F:Eco.Shared.Tools.PerformanceCounter.Head"/> updates:<ul>
            <li>get current head as value index;</li>
            <li>calculate new head as value index + 1 (or 0 if it is greater or equal than <see cref="F:Eco.Shared.Tools.PerformanceCounter.MaxValues"/>);</li>
            <li>try set <see cref="F:Eco.Shared.Tools.PerformanceCounter.Head"/> to new head or repeat steps if <see cref="F:Eco.Shared.Tools.PerformanceCounter.Head"/> changed during these operations.</li>
            </ul></p>
            <p>Once <see cref="F:Eco.Shared.Tools.PerformanceCounter.Head"/> updated it checks if value index extends current value range (from 0 till <see cref="F:Eco.Shared.Tools.PerformanceCounter.MaxValues"/>). If value index greater or equal than <see cref="F:Eco.Shared.Tools.PerformanceCounter.Length"/>
            then it sets <see cref="F:Eco.Shared.Tools.PerformanceCounter.Length"/> to value index + 1.</p>
            </remarks>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounter.MinMaxAverage">
            <summary>Get the min, max, and average for the history of values.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounter.TryGetLastValue(System.Double@)">
            <summary>Attempts to retrieve the last value stored.</summary>
            <param name="value">Value stored if it exists. Otherwise 0</param>
            <returns><c>true</c> if a value was retrieved. Otherwise <c>false</c>.</returns>
        </member>
        <member name="T:Eco.Shared.Tools.PerformanceCounterExtensions">
            <summary> Helper extension methods for <see cref="T:Eco.Shared.Tools.PerformanceCounter"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounterExtensions.AddValueIfActive(Eco.Shared.Tools.PerformanceCounter,System.String)">
            <summary> Adds new value only if <see cref="P:Eco.Shared.Tools.PerformanceManager.Active"/> is <c>true</c>. Returns <c>default</c> value otherwise which won't record any metric on <see cref="M:System.IDisposable.Dispose"/>"/>. </summary>
        </member>
        <member name="T:Eco.Shared.Tools.PerformanceCounterValue">
            <summary>
            A single value for a performance counter.
            </summary>
        </member>
        <member name="T:Eco.Shared.Tools.PerformanceCounterValueRef">
            <summary> A reference to a single performance counter. </summary>
        </member>
        <member name="T:Eco.Shared.Tools.PerformanceIssue">
            <summary>Structure containing information about performance issue detected by <see cref="T:Eco.Shared.Tools.DetectingPerformanceCounter"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Tools.PerformanceManager">
            <summary> Class for managing performance counters (<see cref="T:Eco.Shared.Tools.PerformanceCounter"/>) and producing performance reports. </summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceManager.AddPerformanceCounter(Eco.Shared.Tools.PerformanceCounter)">
            <summary>Adds new performance counter. If performance counter with same name already exists then throws <see cref="T:System.InvalidOperationException"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceManager.SaveReport(Eco.Shared.Tools.PerformanceReportFormat)">
            <summary>Saves report to PerformanceManagerReport.txt or PerformanceManagerReport.json (for Trace format).</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceManager.GetReport(Eco.Shared.Tools.PerformanceReportFormat)">
            <summary>Returns report as string. Content depends on <paramref name="format"/>. Read details about format in <see cref="T:Eco.Shared.Tools.PerformanceReportFormat"/> documentation.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceManager.WriteReport(System.IO.TextWriter,Eco.Shared.Tools.PerformanceReportFormat)">
            <summary>Writes report to <paramref name="writer"/>. Content depends on <paramref name="format"/>. Read details about format in <see cref="T:Eco.Shared.Tools.PerformanceReportFormat"/> documentation.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceManager.WriteReportFullFormat(System.IO.TextWriter)">
            <summary>Writes report in full format with all counter values.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceManager.WriteReportShortFormat(System.IO.TextWriter)">
            <summary>Writes report in short format. Only summary statistic (minimum, maximum and average values).</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceManager.WriteReportTraceFormat(System.IO.TextWriter)">
            <summary>Writes report in trace format. Contains all data from counters in JSON format.</summary>
        </member>
        <member name="T:Eco.Shared.Tools.PerformanceReportFormat">
            <summary>Enum of performance report formats.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Array2D`1.ReadFromStream(System.IO.MemoryStream)">
            <summary>Creates <see cref="T:Eco.Shared.Utils.Array2D`1"/> from <paramref name="stream"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.BidirectionalMap`2.TryGetValue(`0,`1@)">
            <summary> Tries to get <paramref name="val"/> by the <paramref name="key"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.BidirectionalMap`2.TryGetByValue(`1,`0@)">
            <summary> Tries to get <paramref name="key"/> by the <paramref name="val"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.BinaryWriterExtensions.ReplaceZigZag(System.IO.BinaryWriter,System.Int32,System.Int32,System.Int32)">
            <summary>
            Replaces previously encoded <paramref name="oldValue"/> with <paramref name="newValue"/> at <paramref name="position"/>. To perform this operation <paramref name="writer"/> backing stream should be <see cref="T:System.IO.MemoryStream"/>.
            Length of encoded number may be different, in this case data after encoded number will be shifted left or right.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.BinaryWriterExtensions.EncodeZigZag(System.IO.BinaryWriter,System.UInt32)">
            <summary>
            Encodes <paramref name="value"/> to <paramref name="writer"/> using zig-zag encoding which minimizes number of bytes to represent the number.<br/>
            1. If the number below 128 then it just serialize it as single byte.<br/>
            2. Otherwise it will set the flag 0x80 for first byte, divide the number by 128 and repeat from step 1.<br/>
            In best case we have 1 byte (0-127).
            In worst case we have 5 bytes (the number &gt;268 435 456).
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.BinaryWriterExtensions.GetZigZagLength(System.IO.BinaryWriter,System.Int32)">
            <inheritdoc cref="M:Eco.Shared.Utils.Binary.BinaryWriterExtensions.GetZigZagLength(System.Int32)"/>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.BinaryWriterExtensions.GetZigZagLength(System.Int32)">
            <summary>Returns number of bytes required to encode the <paramref name="value"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.Binary.BinaryUtils">
            <summary> Utility methods to work with binary number representation. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.BinaryUtils.CountOfSetBits(System.Int32)">
            <summary> Counts set bits in a number. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.BinaryUtils.CountOfSetBits(System.UInt64)">
            <summary> Counts set bits in a number. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.Binary.BitReader">
            <summary>
            This class provides functionally to read bit-wide values, tracking <c>bitOffset</c> (in opposite to byte-wide values for regular <see cref="T:System.IO.MemoryStream"/> or byte array).
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.BitReader.BitReadBoolean(System.Byte[],System.Int32@)">
            <summary>
            Reads boolean from byte array using <c>bitPosition</c>. Boolean represented as single bit.
            </summary>
            <param name="buffer">byte array.</param>
            <param name="bitPosition">position in array in bits.</param>
            <returns>boolean value. <c>true</c> - if bit was 1, <c>false</c> - otherwise.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.BitReader.BitReadByte(System.Byte[],System.Int32@)">
            <summary>
            Reads a byte value from byte array using <c>bitPosition</c>. It may have offset within a byte.
            </summary>
            <param name="buffer">byte array.</param>
            <param name="bitPosition">position in array in bits.</param>
            <returns>byte value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.BitReader.BitReadUInt16(System.Byte[],System.Int32@)">
            <summary>
            Reads a ushort value from byte array using <c>bitPosition</c>. It may have offset within a byte.
            </summary>
            <param name="buffer">byte array.</param>
            <param name="bitPosition">position in array in bits.</param>
            <returns>ushort value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.BitReader.BitReadBytes(System.Byte[],System.Int32,System.Int32@)">
            <summary>
            Reads a byte array from a source byte array using <c>bitPosition</c>. It may have offset within a byte.
            </summary>
            <param name="buffer">source byte array.</param>
            <param name="length">number of bytes to read.</param>
            <param name="bitPosition">position in array in bits.</param>
            <returns>result byte array.</returns>
        </member>
        <member name="T:Eco.Shared.Utils.Binary.BitWriter">
            <summary>
            This class provides functionally to write bit-wide values, tracking bitOffset (in opposite to byte-wide values for regular MemoryStream).
            </summary>
        </member>
        <member name="T:Eco.Shared.Utils.Binary.ByteArrayReader">
            <summary>
            Utility class to read structured data from byte array.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadByte(System.Byte[],System.Int32@)">
            <summary>
            Read a byte from byte array using provided offset.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded byte value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadUInt32ZigZag(System.Byte[],System.Int32@)">
            <summary>
            Read a unsigned int from data array zig zag encoded.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded unsigned int value.</returns>
            <exception cref="T:System.Exception">if value can't be decoded from byte array.</exception>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadInt16(System.Byte[],System.Int32@)">
            <summary>
            Read a short value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded short value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadInt32(System.Byte[],System.Int32@)">
            <summary>
            Read a int value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded int value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadInt64(System.Byte[],System.Int32@)">
            <summary>
            Read a long value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded long value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadUInt16(System.Byte[],System.Int32@)">
            <summary>
            Read a ushort value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded ushort value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadUInt32(System.Byte[],System.Int32@)">
            <summary>
            Read a uint value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded uint value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadDouble(System.Byte[],System.Int32@)">
            <summary>
            Read a double value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded double value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadVector3(System.Byte[],System.Int32@)">
            <summary>
            Read a vector3 value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded float value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadSingle(System.Byte[],System.Int32@)">
            <summary>
            Read a float value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded float value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadString(System.Byte[],System.Int32@)">
            <summary>
            [str len:zig zag uint][str:utf-8 encoded byte array]
            Reads a string from byte array using provided <c>offset</c>.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded string.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadBoolean(System.Byte[],System.Int32@)">
            <summary>
            [0 - false/1 - true:byte]
            Reads a boolean value from byte array using provided <c>offset</c>.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded boolean value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadGuid(System.Byte[],System.Int32@)">
            <summary>
            [guid:byte[16]]
            Reads a Guid from byte array using provided <c>offset</c>.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded Guid.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadIPEndPoint(System.Byte[],System.Int32@)">
            <summary>
            [address length:byte][address bytes:byte array][port:ushort]
            Reads a IP end point from byte array using provided <c>offset</c>.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded IP endpoint.</returns>
        </member>
        <member name="T:Eco.Shared.Utils.Binary.ByteSpanReader">
            <summary>
            Wraps <see cref="T:System.ReadOnlySpan`1"/> as source for binary data.
            When Read* operation used then it changes internal state and so you need to avoid copy this struct if you need to keep reading position.
            But similar if you copy it before Read operation(s) then you can use original copy for read position reset.
            </summary>
        </member>
        <member name="P:Eco.Shared.Utils.Binary.ByteSpanReader.BytesLeft">
            <summary>Returns how much bytes left for read.</summary>
        </member>
        <member name="P:Eco.Shared.Utils.Binary.ByteSpanReader.UnreadSpan">
            <summary>Returns unread span. Changes after every read operation.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadByte">
            <summary>Read next byte from the reader and advance read position by 1.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadUInt32ZigZag">
            <summary>Read an unsigned int from the reader zig zag encoded and advance read position by 1-5 bytes (depending on how large is number).</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadInt16">
            <summary>Read a short value from the reader and advance read position by 2. Always uses LittleEndian.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadInt32">
            <summary>Read an int value from the reader and advance read position by 4. Always uses LittleEndian.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadInt64">
            <summary>Read a long value from the reader and advance read position by 8. Always uses LittleEndian.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadUInt16">
            <summary>Read a unsigned short value from the reader and advance read position by 2. Always uses LittleEndian.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadUInt32">
            <summary>Read a unsigned int value from the reader and advance read position by 4. Always uses LittleEndian.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadDouble">
            <summary>Read a double value from the reader and advance read position by 8. Always uses LittleEndian.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadVector3">
            <summary>Read a <see cref="T:Eco.Shared.Math.Vector3"/> from the reader and advance read position by 12 (3 x float).</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadSingle">
            <summary>Read a double value from the reader and advance read position by 4. Always uses LittleEndian.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadString">
            <summary>
            [str len:zig zag uint][str:utf-8 encoded byte array]
            Reads a string from the reader and advance read position by string length and encoded length size.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadBoolean">
            <summary>
            [0 - false/1 - true:byte]
            Reads a boolean value from the reader and advance read position by 1.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadGuid">
            <summary>
            [guid:byte[16]]
            Reads a Guid from the reader  and advance read position by 16.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadIPEndPoint">
            <summary>
            [address length:byte][address bytes:byte array][port:ushort]
            Reads an IP end point from the reader and advances position (depending on size of encoded endpoint).
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadBytesTo(System.Span{System.Byte})">
            <summary>Reads <paramref name="destination"/> length bytes to <paramref name="destination"/>. Fails if not enough bytes to read.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadBytesTo(System.IO.Stream,System.Int32)">
            <summary>Reads <paramref name="count"/> bytes to <paramref name="output"/>. Fails if not enough bytes to read.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.Skip(System.Int32)">
            <summary>Skips <paramref name="count"/> bytes.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.CommandLine">
             <summary>
             Class for getting arguments from command line. Arguments are not case sensitive.
            
             Excpected syntax of parameters:
             * -arg
             * -arg="value"
             * -arg.subarg="value"
             </summary>
        </member>
        <member name="M:Eco.Shared.Utils.CommandLine.GetValuelessArg(System.String)">
            <summary> Gets whether an argument is set or not. Not case sensitive. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.CommandLine.GetValueArg(System.String)">
            <summary> Gets the value for a given argument is set, null otherwise. Not case sensitive. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.CompressionUtils.Decompress(System.Byte[])">
            <summary>Decompresses <paramref name="compressed"/> data to uncompressed byte array.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.CompressionUtils.Decompress``1(System.ReadOnlySpan{System.Byte},System.Func{System.IO.MemoryStream,``0})">
            <summary>Decompresses <paramref name="data"/> and then converts it to <typeparamref name="TResult"/> using provided <paramref name="converter"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.CompressionUtils.Decompress``2(System.ReadOnlySpan{System.Byte},``0,System.Func{System.IO.MemoryStream,``0,``1})">
            <summary>Decompresses <paramref name="data"/> and then converts it to <typeparamref name="TResult"/> using provided <paramref name="converter"/>. Supports custom context.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.AddNonNull``1(System.Collections.Generic.ISet{``0},``0)">
            <summary>Add to the hashset if it's not null.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.AddNonNullKey``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>Add to the dictionary if the key is not null.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.RemoveFirst``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>Removes first item matching the <paramref name="matcher"/>. Returns <c>true</c> if item was removed.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.AddOrReplace``1(System.Collections.Generic.IList{``0},``0,System.Predicate{``0})">
            <summary>Replaces first element matching the <paramref name="matcher"/> with <paramref name="item"/> or adds new <paramref name="item"/> if no one matched.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.FirstOfTypeOrDefault``2(System.Collections.Generic.List{``0})">
            <summary> Returns first item of type <typeparamref name="T"/> or default value if not found. It is a list specific implementation to avoid GC-allocations. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.Median``1(System.Collections.Generic.IList{``0},System.Boolean)">
            <summary> Returns median value for <paramref name="list"/>. If <paramref name="sorted"/> is <c>false</c> then it makes sorted copy of list to find the median otherwise it just returns medium element. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.NullIndices``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns an enumerable of each index that has a null value in the passed list.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ArrayExtensions.CurveOrder``1(``0[])">
            <summary>Pass forward sorted array for large middle numbers for example {1,2,3,4,5} would be {1,3,5,4,2}, or reverse sorted array for large side numbers for example {5,4,3,2,1} would be {5,3,1,2,4}, this is useful for aligning trees based on depth, this is a special iterator that jumps through enumerable check this explanation: https://stackoverflow.com/a/3796619</summary>
            <example>One of the cases this is used on is the tech tree visualizer where nodes with higher total rank go in the top and bottom for a better aethestic and line drawing:
            <code>listToOrder.OrderByDescending(tree => GetTotalRank(tree)).ToArray().CurveOrder();</code>
            </example>
        </member>
        <member name="M:Eco.Shared.Utils.DictionaryExtensions.TryRemove``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1@)">
            <summary> Replicates <see cref="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemove(`0,`1@)"/> for regular dictionary (handy way to get and remove value with one call). It isn't atomic like concurrent dictionary version though. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.DictionaryExtensions.AddOrUpdate``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1,System.Func{``1,``1,``1})">
            <summary>Add a new element to a dictionary, or update an existing one if the key already exists.
            <paramref name="updateFunc"/> is a function that accepts the existing value and passed value, and returns the new value to store.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.DictionaryExtensions.AllValues``2(System.Collections.Generic.Dictionary{``0,``1},System.Predicate{``1})">
            <summary>
            Checks if all values in <paramref name="dict"/> matches <paramref name="predicate"/>.
            We are using explicit <see cref="T:System.Collections.Generic.Dictionary`2"/> here and don't use LINQ to avoid garbage creation for enumerator.
            We are using this method in Unity, so it is critical to not have extra GC-allocations.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.DictionaryExtensions.Update``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
            <summary>Updates <paramref name="dictionary"/> with all entries from <paramref name="entries"/>. Not existing entries will be created and matching existing entries overwritten.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.QueueExtensions.DequeueIntoList``1(System.Collections.Generic.Queue{``0},System.Int32)">
            <summary>Deque a given number of elements into a list.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.QueueExtensions.AddRange``1(System.Collections.Generic.Queue{``0},System.Collections.Generic.List{``0})">
            <summary>
            Optimized non-alloc version of <see cref="M:Eco.Shared.Utils.QueueExtensions.AddRange``1(System.Collections.Generic.Queue{``0},System.Collections.Generic.IEnumerable{``0})"/>.
            Because <see cref="M:System.Collections.Generic.List`1.GetEnumerator"/> returns struct <see cref="T:System.Collections.Generic.List`1.Enumerator"/>, but <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/> returns <see cref="T:System.Collections.Generic.IEnumerator`1"/> as boxed version of <see cref="T:System.Collections.Generic.List`1.Enumerator"/>.
            </summary>
            <param name="queue">destination queue.</param>
            <param name="list">list to add.</param>
            <typeparam name="T">item type.</typeparam>
        </member>
        <member name="M:Eco.Shared.Utils.CollectionExtensions.ContainsAny``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary> Checks if <paramref name="source"/> collection contains any value from <paramref name="values"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.CollectionExtensions.AddNotNull``1(System.Collections.Generic.ICollection{``0},``0)">
            <summary>Adds element to <paramref name="collection"/> only if it isn't null. Returns <c>true</c> if element was added.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ArrayUtil.ValuesAtX``1(``0[0:,0:],System.Int32)">
            <summary>Returns the columns of the given row index</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ArrayUtil.ValuesAtY``1(``0[0:,0:],System.Int32)">
            <summary>Returns the rows of the given column index</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ArrayUtil.SetValuesAtX``1(``0[0:,0:],System.Int32,``0)">
            <summary>Assigns the given value to the whole row</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ArrayUtil.SetValuesAtY``1(``0[0:,0:],System.Int32,``0)">
            <summary>Assigns the given value to the whole column</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ArrayUtil.MakeNew``1(System.Int32)">
            <summary> Make an array and fill it with 'new'd entries. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListUtil.TakeAndCalculateForRest``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{``0,System.Int32})">
            <summary>Take First numToTake of items in IEnumerable and apply function doForRest on the elements left in IEnumerable.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListUtil.TakeSelectAndCalcRest``2(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{``0,``1},System.Func{``0,System.Int32})">
            <summary>Take first <paramref name="numToTake"/> of items in IEnumerable, transform it with Func <paramref name="doWithTaken"/> and apply Func <paramref name="doForRest"/> on the elements left in IEnumerable.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.SetExtensions.First``1(System.Collections.Generic.HashSet{``0})">
            <summary> No alloc version of Enumerable.First() for HashSet. </summary>
            <exception cref="T:System.InvalidOperationException">If no elements in HashSet.</exception>
        </member>
        <member name="M:Eco.Shared.Utils.SetExtensions.MapGroupingKey``3(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{``0,``2}},System.Func{``0,``1})">
            <summary> Maps <see cref="T:System.Linq.IGrouping`2"/> key to new value (in example id may be resolved to name). </summary>
        </member>
        <member name="M:Eco.Shared.Utils.SetExtensions.IgnoreRepeats``1(System.Collections.Generic.IEnumerable{``0})">
            <summary> Returns the passed enumerable omitting any entries repeated in the sequence. Only checks sequential repeats, not list-wide repeats (like 'Distinct()' would).</summary>
        </member>
        <member name="M:Eco.Shared.Utils.SetExtensions.EnumerableElementAt(System.Collections.IEnumerable,System.Int32)">
            <summary>Get the element at the given index, or null. Note that this is O(N), and should only be used when generic version of IEnumerable isnt available.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.SetExtensions.EnumerableIndexOf(System.Collections.IEnumerable,System.Object)">
            <summary>Return the index of the given value in a non-generic enumerable. Note that this is O(N), and should only be used when generic version of IEnumerable isnt available.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.DelegateWrapper`1">
            <summary>
            Intended to be used as base class for delegate wrapper which implements some interface.
            It implements equality operations and holds delegate references.
            It helps to avoid creating similar classes only differing by interface method implementation.
            </summary>
            <example>
            This sample shows how it may be used with <see cref="T:System.IComparable`1"/> interface.
            <code>
            class IntComparableWrapper : DelegateWrapper&lt;Func&lt;int, int&gt;&gt;, IComparable&lt;int&gt;
            {
               public IntComparableWrapper(Func&lt;int, int&gt; func) : base(func) { }
               int CompareTo(int value) => this.Delegate(value);
            }
            </code>
            </example>
        </member>
        <member name="T:Eco.Shared.Utils.DisposableUtils.DisposableActionEnumerator`1">
            Provides an enumerator which will execute an action when it is disposed (such as after a foreach loop)
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.TryGetFirst``1(System.Collections.Generic.IEnumerable{``0},``0@)">
            <summary>Tries to get first element from enumerable (if exists).</summary>
            <returns><c>true</c> if <paramref name="enumerable"/> is not empty and <paramref name="element"/> contains the first element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.TryGetFirst``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},``0@)">
            <summary> Gets the first value matching <paramref name="predicate"/> into an out var, returning true if found. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.TryGetSingle``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},``0@)">
            <summary> Gets the single value matching <paramref name="predicate"/> into an out var, returning true if found only one value. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.TryGetFirstFromEnumerator``1(System.Collections.Generic.IEnumerator{``0},System.Func{``0,System.Boolean},``0@)">
            <summary>Internal helper for <see cref="M:Eco.Shared.Utils.EnumerableExtensions.TryGetFirst``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},``0@)"/> and <see cref="M:Eco.Shared.Utils.EnumerableExtensions.TryGetSingle``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},``0@)"/>. Tries to find first item matching <paramref name="predicate"/>.</summary>
        </member>
        <member name="F:Eco.Shared.Utils.EnumerableExtensions.CastMethods">
            <summary>Cache for <see cref="M:Eco.Shared.Utils.EnumerableExtensions.Cast(System.Collections.IEnumerable,System.Type)"/> method.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.AnyNotNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary> Checks if collection contains at least 1 not null element </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.ConcatNullSafe``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary> Same as <see cref="M:Eco.Shared.Utils.EnumerableExtensions.ConcatNullSafe``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>, but returns <c>null</c> if both are <c>null</c> and <paramref name="nullAllowed"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.ConcatNullSafe``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Concat two enumerable if possible (both not null). If any enum is null then it will be omitted from concatenation and only non-null enumerable elements will be returned.
            If both null then it will return empty enumerable.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.MinObj``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})">
            <summary>Returns first item with minimal value of <paramref name="distanceFunc"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.TryGetMinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},``0@)">
            <summary>Tries to get minimal element from <paramref name="enumerable"/> if it has elements. Returns <c>false</c> otherwise.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.MinRange``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary> Returns up to <paramref name="n"/> minimal elements from <paramref name="enumerable"/>. From smallest to larger. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.Any``1(System.Collections.Generic.List{``0},System.Func{``0,System.Boolean})">
            <summary> Specialized version for <see cref="T:System.Collections.Generic.List`1"/>. No allocations. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.FirstOfTypeOrDefault``1(System.Collections.IList)">
            <summary> Returns first value in list of type <typeparamref name="T"/> or default value. No allocations. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.ForEach``3(System.Collections.Generic.Dictionary{``0,``1},``2,System.Action{System.Collections.Generic.KeyValuePair{``0,``1},``2})">
            <summary>
            Calls action for each entry with the context for a dictionary.
            </summary>
            <param name="dict">dictionary.</param>
            <param name="context">context.</param>
            <param name="action">action.</param>
            <typeparam name="TKey">key type.</typeparam>
            <typeparam name="TValue">value type.</typeparam>
            <typeparam name="TContext">context type.</typeparam>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.ForEach``3(System.Collections.Generic.IDictionary{``0,``1},``2,System.Action{System.Collections.Generic.KeyValuePair{``0,``1},``2})">
            <summary>
            Calls action for each entry with the context for a dictionary preferring no-alloc enumerator version (avoiding boxing).
            </summary>
            <param name="dict">dictionary.</param>
            <param name="context">context.</param>
            <param name="action">action.</param>
            <typeparam name="TKey">key type.</typeparam>
            <typeparam name="TValue">value type.</typeparam>
            <typeparam name="TContext">context type.</typeparam>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.ForEach``2(System.Collections.Generic.List{``0},``1,System.Action{``0,``1})">
            <summary>
            Calls action for each element with the context for a list.
            </summary>
            <param name="list">list.</param>
            <param name="context">context.</param>
            <param name="action">action.</param>
            <typeparam name="T">item type.</typeparam>
            <typeparam name="TContext">context type.</typeparam>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.ForEach``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,``1})">
            <summary>
            Calls action for each element with context preferring no-alloc enumerator version (avoiding boxing).
            </summary>
            <param name="enumerable">enumerable.</param>
            <param name="context">context.</param>
            <param name="action">action.</param>
            <typeparam name="T">item type.</typeparam>
            <typeparam name="TContext">context type.</typeparam>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.Median``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary> Returns median value for <paramref name="enumerable"/>. If <paramref name="sorted"/> is <c>false</c> then it makes sorted copy of enumerable to find the median otherwise it just returns medium element. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.ToDictionaryWithDistinctKeys``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary> Same as ToDictionary, but only adds entry with first distinct key. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.AsCollection``1(System.Collections.Generic.IEnumerable{``0})">
            <summary> Represents enumerable as <see cref="T:System.Collections.Generic.ICollection`1"/> avoiding copy creation if not necessary. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.AsReadOnlyList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary> Represents enumerable as <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> avoiding copy creation if not necessary. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.Cast(System.Collections.IEnumerable,System.Type)">
            <summary>Casts <paramref name="enumerable"/> to <see cref="T:System.Collections.Generic.IEnumerable`1"/>. Is useful when you need to cast to specific runtime type, but can't use generic type arguments.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.FallbackIfEmpty``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Collections.Generic.IEnumerable{``0}})">
            <summary>Fallback to another enumerable provided by <paramref name="fallbackProvider"/> if <paramref name="enumerable"/> is empty.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.NullableExcept``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Improved version of <see cref="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>, but with nullable <paramref name="except"/> support. If it is <c>null</c> then <paramref name="source"/> returned unmodified.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.EnumUtils">
            <summary>Utility classes for interacting with Enum instances.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumUtils.HasAnyFlag``1(``0,System.Enum)">
            <summary>Checks if a flag exists, from an or'd together flag.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumUtils.SequentialEntries``1">
            <summary>Returns a <seealso cref="T:System.Collections.Generic.IEnumerable`1"/> instancing containing the distinct etnries of an Enum object ordered by value.</summary>
            <typeparam name="T">Enum type to retrieve the values from</typeparam>
            <returns><seealso cref="T:System.Collections.Generic.IEnumerable`1"/> instance containing the distinct values ordered by value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.EnumUtils.GetEnumDescriptions``1">
            <summary> Gets All descriptions From Enum Type of Enum Values if they have LocDescriptionAttibure else returns null</summary>
            <typeparam name="T"> Enum Type to Get descriptions from</typeparam>
        </member>
        <member name="M:Eco.Shared.Utils.EnumUtils.GetEnumDescriptions(System.Type)">
            <summary> Gets All descriptions From Object of type Type of Enum Values if they have LocDescriptionAttibure else returns null</summary>
            <param name="type">Tyep Object to get descriptions from</param>
        </member>
        <member name="M:Eco.Shared.Utils.EnumUtils.HasAttribute``1(System.Enum,System.Boolean)">
            <summary>Checks if enum value has an attribute</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ExceptionUtils.TryFindExceptionOfType``1(System.Exception,``0@)">
            <summary>Recursively tries to find exception of type <typeparamref name="T"/> for the <paramref name="exception"/>. It may be <paramref name="exception"/> itself or one of it's inner exceptions.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ExceptionUtils.TryFindExceptionOfType``1(System.AggregateException,``0@)">
            <summary>Recursively tries to find exception of type <typeparamref name="T"/> in <paramref name="exception"/> inner exceptions.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.ExpressionUtils">
            <summary>Utility and helper methods for <see cref="T:System.Linq.Expressions.Expression"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ExpressionUtils.IndexedProperty(System.Linq.Expressions.Expression,System.String)">
            <summary>Creates indexed property expression (e.g. instance[index]).</summary>
        </member>
        <member name="T:Eco.Shared.Utils.FastMath">
            <summary>
            Fast but not so precise math, it uses approximation for expensive functions (like pow). It may vary in 5-10% of original value, but it may be OK for some scenarios.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.FastMath.FastAndDirtyPow(System.Double,System.Double)">
            <summary>
            Calculates fast and dirty power of value. In worst cases it may have error up-to 25% (for big power value), but usually within 5%-12%.
            It is faster than regular pow in 23 times for Java (didn't test for C#).
            More details here https://martin.ankerl.com/2007/10/04/optimized-pow-approximation-for-java-and-c-c/.
            </summary>
            <param name="value"></param>
            <param name="pow"></param>
            <returns></returns>
        </member>
        <member name="M:Eco.Shared.Utils.GeneralUtils.IsDefault``1(``0)">
            <summary>Tests if a given value is the default.  Used for structs. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.GlobalRandom">
            <remarks>
            Exposed implementation of Global Random from MoreLinq to be publicly available.
            <see cref="T:System.Random"/> is not thread-safe so the following
            implementation uses thread-local <see cref="T:System.Random"/>
            instances to create the illusion of a global
            <see cref="T:System.Random"/> implementation. For some background,
            see <a href="https://blogs.msdn.microsoft.com/pfxteam/2009/02/19/getting-random-numbers-in-a-thread-safe-way/">Getting
            random numbers in a thread-safe way</a>
            </remarks>
        </member>
        <member name="T:Eco.Shared.Utils.Grouping`2">
            <summary> Simple implementation of <see cref="T:System.Linq.IGrouping`2"/> which allows us to make grouping remapping (like resolving key to string or filtering elements). </summary>
        </member>
        <member name="T:Eco.Shared.Utils.IBidirectionalMap`2">
            <summary>Interface for bi-directional maps which allow to access key by value in addition to usual by key lookup.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.IBidirectionalMap`2.TryGetByValue(`1,`0@)">
            <summary>Lookups key by value.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.IBidirectionalMap`2.ContainsValue(`1)">
            <summary>Checks if value is in map.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.IBidirectionalMap`2.GetOrAdd(`0,System.Func{`1})">
            <summary>Gets value by key or adds new mapping if not exits. Value will be created with <paramref name="valueFactory"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.IBidirectionalMap`2.GetOrAdd(`0,`1)">
            <summary>Gets value by key or adds new mapping if not exits.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.ImmutableCountdown">
            <summary> An immutable timer that is sycned with the client and doesn't require ticks. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ImmutableCountdown.Create(System.Double,System.Double,System.Boolean)">
            <summary> Creates <see cref="T:Eco.Shared.Utils.ImmutableCountdown"/> either paused or running with <paramref name="duration"/> and <paramref name="timeLeft"/>. <paramref name="timeLeft"/> should be less or equal to duration. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.InterlockedUtils.TrySubNonNegative(System.Int32@,System.Int32)">
            <summary>
            Tries to subtract value from location. It only happen if location won't become negative (value &lt;= location).
            </summary>
            <param name="location">location to modify.</param>
            <param name="value">value to subtract.</param>
            <returns>true - if location >= value, location -= value; false - otherwise, location won't be modified.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.InterlockedUtils.SubMinNonNegative(System.Int32@,System.Int32)">
            <summary>
            Atomic operation to subtract `value` from `location`, or if value > location then subtract location (make it 0). It returns actual subtracted value.
            Basic formula: value > location ? location = 0, return old_location_value : location -= value, return value.
            </summary>
            <param name="location">location to change.</param>
            <param name="value">value to subtract.</param>
            <returns>subtracted value: min(location, value).</returns>
        </member>
        <member name="M:Eco.Shared.Utils.InterlockedUtils.SubMinNonNegative(System.Single@,System.Single)">
            <summary>
            Atomic operation to subtract `value` from `location`, or if value > location then subtract location (make it 0). It returns actual subtracted value.
            Basic formula: value > location ? location = 0, return old_location_value : location -= value, return value.
            </summary>
            <param name="location">location to change.</param>
            <param name="value">value to subtract.</param>
            <returns>subtracted value: min(location, value).</returns>
        </member>
        <member name="T:Eco.Shared.Utils.LockUtils.ExitReadLockOnDispose">
            <summary>
            Disposable structure which guarantees that <see cref="F:Eco.Shared.Utils.LockUtils.ExitReadLockOnDispose.rwLock"/> will exit read lock when <see cref="M:Eco.Shared.Utils.LockUtils.ExitReadLockOnDispose.Dispose"/> called. Handy when you wanna to use it with `using` pattern.
            We are not using something like <see cref="M:Eco.Shared.Utils.DisposableUtils.FromAction(System.Action)"/> because it creates new delegate every time what is bad both for performance and memory allocations.
            </summary>
        </member>
        <member name="T:Eco.Shared.Utils.LockUtils.ExitWriteLockOnDispose">
            <summary>
            Disposable structure which guarantees that <see cref="F:Eco.Shared.Utils.LockUtils.ExitWriteLockOnDispose.rwLock"/> will exit write lock when <see cref="M:Eco.Shared.Utils.LockUtils.ExitWriteLockOnDispose.Dispose"/> called. Handy when you wanna to use it with `using` pattern.
            We are not using something like <see cref="M:Eco.Shared.Utils.DisposableUtils.FromAction(System.Action)"/> because it creates new delegate every time what is bad both for performance and memory allocations.
            </summary>
        </member>
        <member name="T:Eco.Shared.Utils.LockUtils.ExitUpgradeableReadLockOnDispose">
            <summary>
            Disposable structure which guarantees that <see cref="F:Eco.Shared.Utils.LockUtils.ExitUpgradeableReadLockOnDispose.rwLock"/> will exit upgradeable read lock when <see cref="M:Eco.Shared.Utils.LockUtils.ExitUpgradeableReadLockOnDispose.Dispose"/> called. Handy when you wanna to use it with `using` pattern.
            We are not using something like <see cref="M:Eco.Shared.Utils.DisposableUtils.FromAction(System.Action)"/> because it creates new delegate every time what is bad both for performance and memory allocations.
            </summary>
        </member>
        <member name="T:Eco.Shared.Utils.MathParser.BinaryNode">
            <summary> Represents math expressions as binary trees. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathParser.BinaryNode.TryResolveInternal(System.Collections.Generic.Stack{System.Single},System.Collections.Generic.Dictionary{System.String,System.Single})">
            <summary> Resolve current node only. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.MathParser.ConstantValueNode">
            <summary> Binary node that repesents an operand with defined value. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.MathParser.OperatorNode">
            <summary> Binary node that represents an operation between two operands. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.MathParser.MathParser">
            <summary> Parses and evaluates math expressions. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathParser.MathParser.ReplaceVariable(System.String,System.String,System.Single)">
            <summary> Replaces text representations of the variable with the provided value. 
            Note that it looks for exact matches and if 'Example' is passed, it won't touch 'Also Example', though the second one contains provided representation. </summary>
            <param name="expression"> A string that contains text representations of the variable. </param>
            <param name="variableName"> Text representation that will be replaced. </param>
            <param name="value"> This will replace text representation of the variable in the provided expression. </param>
            <returns> Modified expression, where text representations of the varible are replaced with the provided value. </returns>
        </member>
        <member name="M:Eco.Shared.Utils.MathParser.MathParser.GetVariables(System.String)">
            <summary>  Extracts variables from the provided string (ignores constant values like 3.14 or 72). </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathParser.MathParser.CompareNames(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>  Compares two provided collections and returns missmatches and declared duplicates. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathParser.MathParser.DescribeValues(System.String,System.Collections.Generic.Dictionary{System.String,System.ValueTuple{System.Single,Eco.Shared.Localization.LocString}})">
            <summary> Replaces text representations of variables with their values. Each value will show its name and description in a foldout when hovered. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathParser.MathParser.BuildTree(System.String)">
            <summary> Converts provided expression into a binary tree and returns its root node (null if failed to parse). </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathParser.MathParser.OnelineAndTrim(System.String)">
            <summary> Replaces newline characters with spaces and trims the result. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathParser.MathParser.CreateNode(System.String,Eco.Shared.Utils.MathParser.BinaryNode,Eco.Shared.Utils.MathParser.BinaryNode)">
            <summary> Parses data and creates either operator node or operand node (either constant or variable). </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.DivideAndFloor(System.Int32,System.Int32)">
            <summary>Unlike a regular division, this will round *down*, instead of towards zero (IE, negative numbers round up when there is a remainder)</summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.LerpToTarget(System.Single,System.Single,System.Single)">
            <summary>Sum source with delta to approach target, without passing it, and respecting absolute value.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.NormalizeAngleDeg(Eco.Shared.Math.Vector3,Eco.Shared.Math.Vector3,System.Single)">
            <summary> Find a normalized (-1 : 1) angle between two directions. Cuts angle higher than max angle </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.IsInCenter(Eco.Shared.Math.Vector3,Eco.Shared.Math.Vector3,Eco.Shared.Math.Vector3,Eco.Shared.Math.Vector3,System.Single)">
            <summary>
            Determine whether the point is in the center of a block
            </summary>
            <param name="size">Size of a block</param>
            <param name="normal">Normal vector of a hit point</param>
            <param name="scaledHit">Position of a hit point scaled to a size</param>
            <param name="centerSize">Size of center on a block (default is 65% of a half)</param>
            <param name="thinSize">Size of thin block</param>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.ClampDirectionAngleDeg(Eco.Shared.Math.Vector2,Eco.Shared.Math.Vector2,System.Single)">
            <summary> Returns a max possible angle between two vectors </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.ClampDirectionToOffsetDeg(Eco.Shared.Math.Vector2@,Eco.Shared.Math.Vector2@,Eco.Shared.Math.Vector2,Eco.Shared.Math.Vector2,Eco.Shared.Math.Vector2,System.Int32,System.Single,System.Single,System.Int32,System.Int32)">
            <summary> Function is finding new target and opposite directions in a curved way (lerping each step) </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.CeilToNearestMultiple(System.Int32,System.Int32)">
            <summary>Ceiling that (3,15) return 15. (-3, 15) will return 0.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.FloorToNearestMultiple(System.Int32,System.Int32)">
            <summary>Floor that (3, 15) return 0. (-3, 15) return -15</summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.CeilToNearestMultiple(Eco.Shared.Math.Vector2i,System.Int32)">
            <summary>Applies <see cref="M:Eco.Shared.Utils.MathUtil.CeilToNearestMultiple(System.Int32,System.Int32)"/> to each <see cref="T:Eco.Shared.Math.Vector2i"/> component.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.FloorToNearestMultiple(Eco.Shared.Math.Vector2i,System.Int32)">
            <summary>Applies <see cref="M:Eco.Shared.Utils.MathUtil.FloorToNearestMultiple(System.Int32,System.Int32)"/> to each <see cref="T:Eco.Shared.Math.Vector2i"/> component.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.SoftCapMap(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary> Maps a value that can go to infinity to a softcapped value.</summary>
            <param name="val">The value to map</param>
            <param name="outMin">The value returned when val is 'inMin'</param>
            <param name="outSoftCap">The value returned when val is 'inSoftCap', interpolating linearly from outMin</param>
            <param name="outHardCap">The value that will be asyptotically approached but never reached.</param>
            <param name="inMin">When val is this, 'outMin' is returned.</param>
            <param name="inSoftCap">When val is this, 'outSoftCap' is returned.</param>
            <param name="inHardCap">Represents how far past the cap the value must climb before it is reduced by diminshingReturnPercent.</param>
            <param name="diminshingReturnPercent">Reduce by diminshingReturnPercent as it goes past inSoftCap</param>
            <returns></returns>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.WeightedAverage(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Calculates average value between <paramref name="x"/> nad <paramref name="y"/> using value weights.
            Formula is following: <c>(x * xWeight + y * yWeight) / (xWeight + yWeight)</c>.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.TotalAverageVector3i(Eco.Shared.Math.Vector3i,System.Int32,Eco.Shared.Math.Vector3i,System.Int32)">
            <summary>Combine calculate average total from 2 source value of Vector3i</summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemberUtils.IsSettable(System.Reflection.MemberInfo)">
            <summary> Returns true if this member is a field, or a property with a setter. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.Byte)">
            <summary>
            byte<br/>
            [1 byte]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadByte(System.IO.MemoryStream)">
            <summary>
            bool<br/>
            [1 byte]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.Boolean)">
            <summary>
            bool<br/>
            [1 byte]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadBool(System.IO.MemoryStream)">
            <summary>
            bool<br/>
            [1 byte]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.Int16)">
            <summary>
            short<br/>
            [2 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadShort(System.IO.MemoryStream)">
            <summary>
            short<br/>
            [2 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.UInt16)">
            <summary>
            ushort<br/>
            [2 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadUShort(System.IO.MemoryStream)">
            <summary>
            ushort<br/>
            [2 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.WriteArray``1(System.IO.MemoryStream,System.ReadOnlySpan{``0})">
            <summary>
            short span encoded as array<br/>
            [length as zigzag int][ushort array]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.WriteArray(System.IO.MemoryStream,System.UInt16[])">
            <summary>
            short array<br/>
            [length as zigzag int][ushort array]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadArray``1(System.IO.MemoryStream,``0[],System.Int32)">
            <summary>
            Reads <paramref name="count"/> <typeparamref name="T"/> values to <paramref name="array"/>.
            It makes binary copy of stream data to array and won't correctly work if any kind of compression (like zig zag) was used.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadUShortArray(System.IO.MemoryStream)">
            <summary>
            Decodes ushort array.
            [count:int sig zag][ushort[count]]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.Int32)">
            <summary>
            zig zag int<br/>
            [1-5 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadInt(System.IO.MemoryStream)">
            <summary>
            zig zag int<br/>
            [1-5 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.WriteNoZigZag(System.IO.MemoryStream,System.Int32)">
            <summary>
            non zig zag int<br/>
            [4 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.UInt32)">
            <summary>
            zig zag uint<br/>
            [1-5 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.WriteNoZigZag(System.IO.MemoryStream,System.UInt32)">
            <summary>
            non zig zag uint<br/>
            [4 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.Int64)">
            <summary>
            zig zag long<br/>
            [1-10 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.WriteNoZigZag(System.IO.MemoryStream,System.Int64)">
            <summary>
            non zig zag long<br/>
            [8 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadLong(System.IO.MemoryStream)">
            <summary>
            zig zag long<br/>
            [1-10 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.Single)">
            <summary>
            float<br/>
            [4 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadFloat(System.IO.MemoryStream)">
            <summary>
            float<br/>
            [4 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.Double)">
            <summary>
            double<br/>
            [8 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadDouble(System.IO.MemoryStream)">
            <summary>
            double<br/>
            [8 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.Guid)">
            <summary>
            <see cref="T:System.Guid"/><br/>
            [16 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadGuid(System.IO.MemoryStream)">
            <summary>
            <see cref="T:System.Guid"/><br/>
            [16 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.Net.IPEndPoint)">
            <summary>
            Encodes <see cref="T:System.Net.IPEndPoint"/> to <paramref name="stream"/>.<br/>
            [address bytes length:1 byte][address bytes:4-16 bytes][port:2 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.String,System.Boolean)">
            <summary>
            Encodes <see cref="T:System.String"/> <paramref name="value"/> to <paramref name="stream"/>. Depending on <paramref name="signedZigZag"/> will either use <see cref="M:Eco.Shared.Utils.MemoryStreamExtensions.EncodeZigZag(System.IO.MemoryStream,System.Int32)"/> for <c>true</c> or <see cref="M:Eco.Shared.Utils.MemoryStreamExtensions.EncodeZigZag(System.IO.MemoryStream,System.UInt32)"/> for <c>false</c> when encoding string length.<br/>
            [length: signed/unsigned int zigzag][utf8 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.String)">
            <summary>
            Encodes <see cref="T:System.String"/> <paramref name="value"/> to <paramref name="stream"/>.<br/>
            [length: unsigned int zigzag][utf8 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadString(System.IO.MemoryStream)">
            <summary>
            Decodes <see cref="T:System.String"/> from <paramref name="stream"/>.<br/>
            [length: unsigned int zigzag][utf8 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadString(System.IO.MemoryStream,System.Boolean)">
            <summary>
            Decodes <see cref="T:System.String"/> from <paramref name="stream"/>. Depending on <paramref name="signedZigZag"/> will either use <see cref="M:Eco.Shared.Utils.MemoryStreamExtensions.DecodeIntZigZag(System.IO.MemoryStream)"/> for <c>true</c> or <see cref="M:Eco.Shared.Utils.MemoryStreamExtensions.DecodeUIntZigZag(System.IO.MemoryStream)"/> for <c>false</c> when decoding string length.<br/>
            [length: signed/unsigned int zigzag][utf8 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.WriteSpan(System.IO.MemoryStream,System.Int32)">
            <summary>
            Returns <see cref="T:System.Span`1"/> which may be used for direct write access to <see cref="T:System.IO.MemoryStream"/> buffer (obtained with <see cref="M:System.IO.MemoryStream.GetBuffer"/>) and advances stream position for <paramref name="length"/>.
            This span should be used immediately before any other Stream write operation, because otherwise buffer may be re-allocated and Span reference become invalid.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadSpan(System.IO.MemoryStream,System.Int32)">
            <summary>
            Returns <see cref="T:System.ReadOnlySpan`1"/> for next <paramref name="length"/> bytes of <paramref name="memoryStream"/> and advances read position.
            This span should be used immediately before any other Stream write operation, because otherwise buffer may be re-allocated and Span reference become invalid.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadSpanToEnd(System.IO.MemoryStream)">
            <summary>Returns <see cref="T:System.ReadOnlySpan`1"/> for <paramref name="memoryStream"/> buffer starting from current position and advances stream position to the end.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.GetBufferSpan(System.IO.MemoryStream)">
            <summary>Returns <see cref="T:System.IO.Stream"/> byte content as <see cref="T:System.Span`1"/>. It is alternative to <see cref="M:System.IO.MemoryStream.ToArray"/>, but without byte array allocation.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Shift(System.IO.MemoryStream,System.Int32,System.Int32)">
            <summary>
            Shifts <paramref name="stream"/> content at given <paramref name="shiftPosition"/> by <paramref name="shift"/>. Stream position and length adjusted if required.
            Useful when you need to insert or remove byte content from stream.
            </summary>
        </member>
        <member name="T:Eco.Shared.Utils.NullableExtensions">
            <summary> Extension methods for <see cref="T:System.Nullable`1"/> </summary>
        </member>
        <member name="M:Eco.Shared.Utils.NullableExtensions.TryGetValue``1(System.Nullable{``0},``0@)">
            <summary> Checks if <paramref name="nullable"/> has value and returns it as <paramref name="value"/> if has. Returns result of this check. It is thread-safe as it makes copy of <see cref="T:System.Nullable`1"/> struct. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.PathUtils">
            <summary>Home for <see cref="T:System.IO.Path"/> utility functions.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.PathUtils.SanitizeFileName(System.String)">
            <summary>Replaces all invalid file name characters with '_' and removes trailing '.' if exists.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.PathUtils.IsSubPath(System.String,System.String)">
            <summary>Checks if a string path is within a root directory.</summary>
            <param name="root">Root directory to check for</param>
            <param name="path">Path to check.</param>
            <returns><c>true</c> if the path value of <paramref name="path"/> is contained within <paramref name="root"/>>. Otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.ProfanityFilter.Invoke(Eco.Shared.Networking.INetClient,Eco.Shared.Networking.RPCInvocation@)">
            <summary>Invokes <paramref name="invocation"/> with profanity filter.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.RandomCandidateChooser`1">
             <summary>
             Random Candidate Chooser from unknown size number of candidates.
             As soon as first candidate tested it will be auto-winner, but also it will randomly select next winner index and reset candidate counter.
             As soon as we have candidate with selected winner index it will replace previous winner and we select next winner index.
             It uses some adjustments to make replacement more often for low number of elements and less often as number of elements growth.
            
             This algorithm is adaptation of https://en.wikipedia.org/wiki/Reservoir_sampling for k = 1.
             </summary>
        </member>
        <member name="F:Eco.Shared.Utils.RandomCandidateChooser`1.weight">
            <summary> Next candidate weight. With lower value new candidate has lower chances to replace last Winner. </summary>
        </member>
        <member name="F:Eco.Shared.Utils.RandomCandidateChooser`1.nextWinnerIndex">
            <summary> Next winner index (zero-based). </summary>
        </member>
        <member name="F:Eco.Shared.Utils.RandomCandidateChooser`1.nextCandidateIndex">
            <summary> Next candidate (who will be tested) index. If it matches winner index then the candidate wins. Increased after each <see cref="M:Eco.Shared.Utils.RandomCandidateChooser`1.TestCandidate(`0)"/>.  </summary>
        </member>
        <member name="P:Eco.Shared.Utils.RandomCandidateChooser`1.Winner">
            <summary> Current winner. Should be selected by <see cref="M:Eco.Shared.Utils.RandomCandidateChooser`1.TestCandidate(`0)"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.RandomCandidateChooser`1.TestCandidate(`0)">
            <summary> Test the <paramref name="candidate"/> if it is the next winner. Updates <see cref="P:Eco.Shared.Utils.RandomCandidateChooser`1.Winner"/> if test succeed. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.RandomExtensions.Random(System.Random,Eco.Shared.Math.Vector2i)">
            <summary> Returns new <see cref="T:Eco.Shared.Math.Vector2i"/> with <c>x</c> greater or equal to <c>0</c> and less than <c>max.x</c>. Same for <c>y</c>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.RandomExtensions.Shuffle``1(System.Random,``0[])">
            <summary> Shuffles <paramref name="array"/> elements in-place in random order using <paramref name="random"/> generator. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.RandomUtil.Shuffle``1(``0[])">
            <summary> Shortcut for <see cref="M:Eco.Shared.Utils.RandomExtensions.Shuffle``1(System.Random,``0[])"/> with <see cref="P:Eco.Shared.Utils.RandomUtil.Global"/> randomizer. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.DerivedTypes(System.Type,System.Reflection.Assembly,System.Boolean)">
            <summary> Returns all derived types for <paramref name="baseType"/> optionally in specific <paramref name="assembly"/> and optionally (if <paramref name="includeSelf"/> set) returning the type itself. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.DerivedTypes(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Type,System.Boolean)">
            <summary> Returns all derived types for <paramref name="baseType"/> in <paramref name="assemblies"/> optionally (if <paramref name="includeSelf"/> set) returning the type itself. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.ConcreteTypesWithInteface(System.Type,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary> Returns all types that implements interface <paramref name="interfaceType"/>  </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.DerivedTypes(System.Reflection.Assembly,System.Type,System.Boolean)">
            <summary> Returns all derived types for <paramref name="baseType"/> in <paramref name="assembly"/> optionally (if <paramref name="includeSelf"/> set) returning the type itself. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.GenericTypeImplementations(System.Type,System.Reflection.Assembly)">
            <summary>Returns all compile time implementations of <paramref name="genericTypeDefinition"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.IsInheritFromGenericTypeDefinition(System.Type,System.Type)">
            <summary> Checks if any base class is generic type from generic type definition. </summary>
            <sample><code>EconomyManager.IsInheritFromGenericTypeDefinition(typeof(Singleton&lt;&gt;)) // true</code></sample>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.TryCallStatic``1(System.Type,System.String,System.Object[])">
            <summary>Call a static function of the given name, triggering an error if it doesnt exist.  T = return type</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.GetExtensionMethods(System.Type)">
            <summary>Returns all extensions methods for <paramref name="type"/> including those which assignable from <paramref name="type"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.AllMembers(System.Type,System.Boolean)">
            <summary> Gets all properties, methods, and extension methods.  Operates either on instance members or static members based on passed bool. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.MembersWithAttribute``1(System.Type,System.Boolean)">
            <summary> Returns all public instance and static members that have the passed attribute, including from parent classes. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.HasAttributeIncludingInterfaces``1(System.Reflection.PropertyInfo)">
            <summary>Checks if <paramref name="property"/> has attribute <typeparamref name="T"/> or any of interfaces declaring same property has the attribute.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.TryGetPropertyByName``1(System.Object,System.String,``0@)">
            <summary>Try to get a property using reflection for the given name, and assign it to val, returning true if found.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.InNamespace(System.Type,System.String)">
            <summary> Checks if <paramref name="type"/> in <paramref name="namespace"/> (same or nested). </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.IsBackingField(System.Reflection.FieldInfo)">
            <summary> Checks if <paramref name="fieldInfo"/> is backing field (for auto-property). </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.CanAccess(System.Reflection.Assembly,System.Reflection.FieldInfo)">
            <summary>
            Checks if <paramref name="field"/> may be accessed (without reflection) from <paramref name="assembly"/>.
            It is possible in 3 cases:
            - field is "public";
            - field declared in the assembly;
            - field declared as "protected" or "protected internal" and field's owning type is in the assembly;
            <remarks>It currently doesn't support intermediate types through inheritance, i.e. in A (Assembly 1) : B (Assembly 2) : C (Assembly 3) if you check for Assembly 2 for A.field
            which is declared as protected in C then it will return false. Adding this check will make logic more complex and doesn't have practical usage for now.</remarks>
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.CanAccess(System.Reflection.Assembly,System.Reflection.MethodInfo)">
            <summary>
            Checks if <paramref name="method"/> may be accessed (without reflection) from <paramref name="assembly"/>.
            It is possible in 3 cases:
            - <paramref name="method"/> is "public";
            - <paramref name="method"/> declared in the <paramref name="assembly"/>;
            - <paramref name="method"/> declared as "protected" or "protected internal" and <paramref name="method"/>'s owning type is in the <paramref name="assembly"/>;
            <remarks>It currently doesn't support intermediate types through inheritance, i.e. in A (Assembly 1) : B (Assembly 2) : C (Assembly 3) if you check for Assembly 2 for A.Method
            which is declared as protected in C then it will return false. Adding this check will make logic more complex and doesn't have practical usage for now.</remarks>
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.ZipByProperty``1(System.Object,System.Object,System.Object,System.Func{``0,``0,``0})">
            <summary> Goes over each assignable member of type T in the given object, gets the value in both 'object' and 'other', and calls the func to transform
            them into the final value.
            </summary>
            <typeparam name="T">The parameter type of properties we're looking at.</typeparam>
            <param name="target">The given object.</param>
            <param name="leftObj">The object providing the left value in the transformFunc</param>
            <param name="rightObj">The object providing the right value in the transformFunc</param>
            <param name="transformFunc">The function that accepts the property from both left and right, and returns the value of the new one. </param>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.BlendProperties(System.ICloneable,System.ICloneable,System.Single)">
            <summary> Clones source, then assigns all int and float values a lerped-value relative to 'target' </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.TryGetMatchingMethodWithInheritance(System.Reflection.MethodInfo,System.Func{System.Reflection.MethodInfo,System.Boolean},System.Reflection.MethodInfo@)">
            <summary>Searches matching method starting from <paramref name="methodInfo"/> and then fallback to base class and interfaces. I.e. may be used to find base method in non-generic type.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.TryGetMatchingInterfaceMethod(System.Reflection.MethodInfo,System.Func{System.Reflection.MethodInfo,System.Boolean},System.Reflection.MethodInfo@)">
            <summary>Tries to get first interface declaring <paramref name="methodInfo"/> matching <paramref name="predicate"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Text.SignedNum(System.Single,System.Boolean)">
            <summary> Returns styled number with forded sign ('+' - for positive, '-' - for negative, no sign for zero). If <paramref name="invertHighlight"/> set then it will use negative highlight for positive value. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Text.CurrencySignedNum(System.Single,System.Boolean)">
            <summary> Returns styled number with forded sing and $ symbol ('+$' for positive, '-$' for negative, no sing for zero). If <paramref name="invertHighlight"/> set then it will use negative highlight for positive value. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Text.IsZeroAfterRounding(System.Single,System.Int32)">
            <summary> Check if number is different than 0 after formatting </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Text.StyledIntUnsigned(System.Single)">
            <summary> Styles originally negative numbers in red (negative style) while removing the negative sign from the output.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Text.Font(System.String,System.String)">
            <summary>Creates a font tag for use with TextMeshPro on the Client. http://digitalnativestudios.com/textmeshpro/docs/rich-text/#font </summary>
            <returns>TextMeshPro compatible font tag.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Text.Font(System.String,System.String,System.String)">
            <inheritdoc cref="M:Eco.Shared.Utils.Text.Font(System.String,System.String)"/>
        </member>
        <member name="M:Eco.Shared.Utils.Text.Truncate(System.String,System.Int32)">
            <summary> Cuts visible part of the content after provided width and replaces it with a hoverable link to see the origin. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Text.Columns(System.Int32,System.ValueTuple{System.String,System.Int32}[])">
            <summary> Aligns strings within blocks with specified widths. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Text.NegativeOrDefault(System.String,System.Boolean)">
            <summary>Coloring text with default or negative color by condition</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Text.NegativeOrPositive(System.String,System.Boolean)">
            <summary>Coloring text with positive or negative color by condition</summary>
        </member>
        <member name="T:Eco.Shared.Utils.Singleton`1.Temp">
            <summary>
            Structure which used for temporary replaced singletons (for test purposes). It saves previous singleton object (usually null) and when disposed restores it.
            It may be preferred over <see cref="M:Eco.Shared.Utils.Singleton`1.WithTempSingleton``1(System.Action)"/>, because you may create this object in [SetUp] method and destroy in [TearDown] method
            allowing all tests to run with this temp singleton without explicitly wrapping them in WithTempSingleton call.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchExtensions.FractionalMilliseconds(System.Diagnostics.Stopwatch)">
            <summary>Returns milliseconds as fractional.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.StopwatchUtils">
            <summary> <see cref="T:System.Diagnostics.Stopwatch"/> utilities for high performance time measures. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchUtils.TicksFromMilliseconds(System.Int64)">
            <summary> Returns number of <see cref="P:System.Diagnostics.Stopwatch.ElapsedTicks"/> for <paramref name="milliseconds"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchUtils.TicksFromMilliseconds(System.Double)">
            <summary> Returns number of <see cref="P:System.Diagnostics.Stopwatch.ElapsedTicks"/> for <paramref name="milliseconds"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchUtils.TicksFromSeconds(System.Double)">
            <summary> Returns number of <see cref="P:System.Diagnostics.Stopwatch.ElapsedTicks"/> for <paramref name="seconds"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchUtils.TicksFromTimeSpan(System.TimeSpan)">
            <summary> Returns number of <see cref="P:System.Diagnostics.Stopwatch.ElapsedTicks"/> for <paramref name="timeSpan"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchUtils.MillisecondsFromTicks(System.Int64)">
            <summary> Returns number of milliseconds for <see cref="P:System.Diagnostics.Stopwatch.ElapsedTicks"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchUtils.SecondsFromTicks(System.Int64)">
            <summary> Returns number of seconds for <see cref="P:System.Diagnostics.Stopwatch.ElapsedTicks"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchUtils.TimeSpanFromTicks(System.Int64)">
            <summary> Returns <see cref="T:System.TimeSpan"/> for raw <see cref="T:System.Diagnostics.Stopwatch"/> ticks. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StreamExtensions.CopyOptimizedTo(System.IO.Stream,System.IO.Stream)">
            <summary>
            Optimized version of Stream.CopyTo trying to avoid memory allocations.
            </summary>
            <param name="source">source stream.</param>
            <param name="destination">destination stream.</param>
            <returns>number of bytes transferred.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.StreamExtensions.CopyOptimizedTo(System.IO.Stream,System.IO.Stream,System.Int64)">
            <summary>
            Optimized version of Stream.CopyTo trying to avoid memory allocations.
            </summary>
            <param name="source">source stream.</param>
            <param name="destination">destination stream.</param>
            <param name="bytesToCopy">number of bytes to copy.</param>
            <returns>number of bytes transferred.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.JoinSafe(Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString,System.String,System.String)">
            <summary>Join a string to another with a separator, if both are set.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.StartWithWords(System.String,System.String)">
            <summary>Check if a string is in the beginning of this string, whole words included. Partial overlap will return false. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.StripTagsNoParse(System.String)">
            <summary>Same as <see cref="M:Eco.Shared.Utils.StringExtensions.StripTags(System.String)"/>, but does not strip tags that are inside 'noparse' tag.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.Strip(System.String,System.Char)">
            <summary>Strips character <paramref name="ch"/> from <paramref name="input"/> string.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.DescribeAmountLoc(System.Collections.Generic.IEnumerable{Eco.Shared.Localization.LocString},System.String)">
            <summary>  Version of <see cref="M:Eco.Shared.Utils.StringExtensions.DescribeAmount(System.Collections.Generic.IEnumerable{Eco.Shared.Localization.LocString},Eco.Shared.Localization.LocString)"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.DescribeAmount(System.Collections.Generic.IEnumerable{Eco.Shared.Localization.LocString},Eco.Shared.Localization.LocString)">
            <summary> Combines a set of lines into a foldout list. The link will be in format "description: linesCount". </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.CommaList(System.Collections.Generic.IEnumerable{Eco.Shared.Localization.LocString},Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString)">
            <summary>
            Creates comma separated list from <paramref name="phrases"/>.
            If input is empty then it will return <paramref name="noneText"/>.
            Otherwise it will return comma separated list prefixed with <paramref name="prefix"/> and suffixed with <paramref name="suffix"/>.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.TrimEndString(System.String,System.String)">
            <summary> Trim the end if it matches a string. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.IsSet(System.String)">
            <summary> Checks if string is not null and is not empty. Inverse of <see cref="M:System.String.IsNullOrEmpty(System.String)"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.AppendToBuilder(Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocStringBuilder@)">
            <summary> Avoid creating new builder if not needed </summary>
        </member>
        <member name="T:Eco.Shared.Utils.TableUtils">
            <summary> Contains utility functions that can help style table content. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.TableUtils.GetTitleRowLoc(System.String)">
            <summary> Returns an Header that is ready to added to a table as a row. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.TableUtils.GetDescriptionRowLoc(System.String)">
            <summary> Returns an Header that is ready to added to a table as a row. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.TableUtils.MakeEmptyLineTable(System.Int32)">
            <summary> Returns an empty table with howmany empty lines we want. Can be used for styling purposes. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.TableUtils.GetStyledRow(System.Int32,System.Collections.Generic.List{Eco.Shared.Localization.LocString},System.Int32)">
            <summary> Pass a row and get it back styled with optional amount of empty lines before and after it. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.TagParser">
            <summary>Parses XML-like text using custom tag processors from config. Tag processor is a <see cref="T:Eco.Shared.Utils.TagParser.CustomTagProcessor"/> delegate.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.TagParser.CustomTagProcessor">
            <summary>Processing callback for custom tags.</summary>
            <param name="paramNamesToValues">Parameters of the tag and their values (see sample below). This dictionary will be used as parentAttrs for child tags. See how ProcessFoldoutMatch on client side looks for parameters that were added by its children.</param>
            <param name="content">&lt;someTag parameter="value"&gt;content&lt;/someTag&gt;</param>
            <param name="parentAttrs">paramNamesToValues of the parent tag. See how ProcessFoldoutTitle on the client side passes data to its parent foldout tag.</param>
            <param name="foldouts">Optional foldouts mapping provided in <see cref="M:Eco.Shared.Utils.TagParser.Parse(System.String,System.Collections.Generic.Dictionary{System.String,System.ValueTuple{System.String,System.String}})"/> call. May be null.</param>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.Parse(System.String,System.Collections.Generic.Dictionary{System.String,System.ValueTuple{System.String,System.String}})">
            <summary>Parses <paramref name="text"/> using registered custom processors and fixing any unclosed tags (defined to be auto-closed).</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.ReleaseContext(Eco.Shared.Utils.TagParserState)">
            <summary>Returns content of <paramref name="state"/>'s Output and adds it back to the pool.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.ReleaseBuilder(System.Text.StringBuilder)">
            <summary>Returns content of <paramref name="builder"/> and adds it back to the pool.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.TryParseClosingTag(System.ReadOnlySpan{System.Char},System.String@)">
            <summary>Tries parse <paramref name="tag"/> as closing and outputs it's <paramref name="name"/> if succeed.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.ParseAttributes(System.ReadOnlySpan{System.Char})">
            <summary>Parses parameters for the <paramref name="tag"/> as dictionary.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.HandleTag(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char}@,Eco.Shared.Utils.TagParserState)">
            <summary>Handles <paramref name="tag"/> either as unknown tag or registered custom tag. For custom tags it will output <see cref="T:Eco.Shared.Utils.TagParser.CustomTagProcessor"/> result, for unknown tags it will add them as is to <paramref name="state"/> Output.</summary>
            <param name="tag">Contains tag to process.</param>
            <param name="unparsed">Contains unparsed value right after the <paramref name="tag"/>.</param>
            <param name="state">Contains current parser state including Output, OpenTags, last unhandled tag etc.</param>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.CaptureContent(System.ReadOnlySpan{System.Char}@,Eco.Shared.Utils.TagParserState)">
            <summary>Same as <see cref="M:Eco.Shared.Utils.TagParser.ParseContent(System.ReadOnlySpan{System.Char}@,Eco.Shared.Utils.TagParserState)"/>, but captures parsed content to string and returns. It temporary overrides state's Output, original Output stays unmodified.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.ParseContent(System.ReadOnlySpan{System.Char}@,Eco.Shared.Utils.TagParserState)">
            <summary>Parses <paramref name="unparsed"/> content. Handles tags with <see cref="M:Eco.Shared.Utils.TagParser.HandleTag(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char}@,Eco.Shared.Utils.TagParserState)"/> for every open tag, returns if found close tag and output it to state's UnhandledCloseTag and adds everything else to state's Output.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.TryFindNextTag(System.ReadOnlySpan{System.Char},System.Int32@,System.Int32@)">
            <summary>Scans <paramref name="unparsed"/> content until first tag entry and outputs it's position in <paramref name="tagStart"/> and <paramref name="tagEnd"/> parameters if succeed. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.TagParserConfig">
            <summary> Config for <see cref="T:Eco.Shared.Utils.TagParser"/> which allows to add custom parsers and configure autocloseable tags. </summary>
        </member>
        <member name="F:Eco.Shared.Utils.TagParserConfig.TagNamesToCustomProcessors">
            <summary> Tag parser looks for a custom processor for every tag it finds. The tag and its content will be left as is if there is no custom processor for it.
            Otherwise, everything will be replaced with the result returned by the processor. </summary>
        </member>
        <member name="F:Eco.Shared.Utils.TagParserConfig.AutoCloseTags">
            <summary> Set of tags which should be automatically closed if no matching close tag was found. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.TagParserState">
            <summary><see cref="T:Eco.Shared.Utils.TagParser"/> state object used during call to <see cref="M:Eco.Shared.Utils.TagParser.Parse(System.String,System.Collections.Generic.Dictionary{System.String,System.ValueTuple{System.String,System.String}})"/>.</summary>
        </member>
        <member name="F:Eco.Shared.Utils.TagParserState.OpenTags">
            <summary>Tracks for all open tags when processing nested tags.</summary>
        </member>
        <member name="F:Eco.Shared.Utils.TagParserState.ParentAttributes">
            <summary>Contains parent tag attributes dictionary (only if parent tag has custom tag processor). May be <c>null</c>.</summary>
        </member>
        <member name="F:Eco.Shared.Utils.TagParserState.Output">
            <summary>Current Output for parsed content.</summary>
        </member>
        <member name="F:Eco.Shared.Utils.TagParserState.UnhandledCloseTag">
            <summary>Last unhandled close tag. Set when close tag doesn't match opened tag. Tag will be auto-closed in this case and closed tag reused by parent tag.</summary>
        </member>
        <member name="F:Eco.Shared.Utils.TagParserState.Foldouts">
            <summary>Optional foldouts mapping between foldout id and it's Title and Content.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TagParserState.Clear">
            <summary>Clears state and prepares it for next parse.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TextUtil.JoinLocStr(System.String,System.Nullable{Eco.Shared.Localization.LocString}[])">
            <summary>Joins an arbitrary number of localized strings together with the joiner, if not null.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TextUtil.CheckRPCLength(Eco.Shared.Networking.INetClient,Eco.Shared.Networking.RPCInvocation)">
            <summary> Method to check the size of the strings that pass through the RPC, if they have a Range attribute we limit the size to this, if not then we check that MaxTextSize is not reached </summary>
        </member>
        <member name="M:Eco.Shared.Utils.TextUtil.GetObjectRange(System.String,System.Reflection.PropertyInfo,Eco.Shared.Localization.LocString@)">
            <summary>Get the variables needed to analize the attribute of the object.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TextUtil.CheckLength(Eco.Shared.Math.EcoTextLimit,System.String,Eco.Shared.Localization.LocString@,System.Boolean)">
            <summary>Check that the incoming string is under the allowed limits of text sizes, in case it is not return False and and return a message with the description of why it failed.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.TimedTaskProgressLogging">
            <summary> Utility functions to log TimedTask start and progress to the console, and parse and format the same messages for when running the server through the client</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TimedTaskProgressLogging.LogTask(System.String)">
            <summary> Log task start to console with padding </summary>
        </member>
        <member name="M:Eco.Shared.Utils.TimedTaskProgressLogging.LogProgress(System.String,System.Int32,System.Int32)">
            <summary> Log task progress to console with cursor offset. Resets cursor position after writting. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.TimedTaskProgressLogging.LogTaskAndProgress(System.String,System.String)">
            <summary> Log task and progress to console. Used when same line reporting is not available </summary>
        </member>
        <member name="M:Eco.Shared.Utils.TimedTaskProgressLogging.ParseAndFormatLogParts(System.String)">
            <summary> Parse the name and progress of a task console message and format it for client UI display. Used by the client when running the server through the client. </summary>
        </member>
        <member name="T:Eco.Shared.Validation.PropertyValidationUtils">
            <summary>Utilities to work with ValidationAttribute. Could be used on client.</summary>
        </member>
        <member name="M:Eco.Shared.Validation.PropertyValidationUtils.ClampRangeFloatValues(System.Object)">
            <summary>Tries to fix all values to fit it's RangeAttribute's restrictions.</summary>
            <param name="propertyContainer">Iterates through propertyContainer properties with RangeAttribute set.</param>
            <returns>Returns true if object has invalid values and was modified</returns>
        </member>
        <member name="M:Eco.Shared.Validation.PropertyValidationUtils.ClampRangeFloatValue(System.Object,System.String)">
            <summary>Tests if object's property contains float RangeAttribute and tries to fix that. Produces error message if invalid object was found.</summary>
            <param name="propertyContainer">Object with given property</param>
            <param name="propertyName">Propery name to test</param>
            <returns>Returns true if object has invalid values and was modified</returns>
        </member>
        <member name="M:Eco.Shared.Validation.PropertyValidationUtils.GetPropertyFloatRange(System.Object,System.String)">
            <summary>Get object's given property float range restrictions. If it has not RangeAttribute of valid float values returns whole float range.</summary>
            <param name="propertyContainer">Object with given property</param>
            <param name="propertyName">Property name to test</param>
            <returns>Returns effective float range</returns>
        </member>
        <member name="T:Eco.Shared.View.EventSubscription">
            <summary>Subscription for <see cref="T:Eco.Shared.View.ISubscribableEvent"/>.</summary>
        </member>
        <member name="T:Eco.Shared.View.IObservable">
            <summary>Interface for objects which may be subscribed (observed) for property changes.</summary>
        </member>
        <member name="T:Eco.Shared.View.IPropertySubscription">
            <summary>Interface for property change subscriptions. Holds information about observable subject, invocation target and method. May be invoked to notify subscription.</summary>
        </member>
        <member name="T:Eco.Shared.View.ISubscription">
            <summary>Interface for all subscription classes. May be either <see cref="T:Eco.Shared.View.Subscriptions"/> for subscriptions group or <see cref="T:Eco.Shared.View.IPropertySubscription"/>.</summary>
        </member>
        <member name="T:Eco.Shared.View.ISubscriptions">
            <summary>
            This is a replacement for IAnonymousSubscriber.
            This simplifies Subscription management, because you can use it with extension methods for easy subscription management.
            </summary>
        </member>
        <member name="T:Eco.Shared.View.NoOpPropertySubscription">
            <summary>
            No operation <see cref="T:Eco.Shared.View.PropertySubscription"/>. Will do nothing on callback.
            May be used as replacement for removed subscription during subscription list processing. I.e. we have list [sub1, sub2] and sub2 removed in sub1 callback.
            If we just remove it then list iteration will fail with <see cref="T:System.IndexOutOfRangeException"/> when accessing index 1 of removed sub2.
            To avoid this we can just replace removed subscription with <see cref="T:Eco.Shared.View.NoOpPropertySubscription"/> until list processing finish and then remove all no-op subscriptions from the list.
            </summary>
        </member>
        <member name="T:Eco.Shared.View.ObservableExtensions">
            <summary>Extension methods for <see cref="T:System.IObservable`1"/>.</summary>
        </member>
        <member name="T:Eco.Shared.View.PropertySubscription">
            <summary>Default property subscription implementation which works with provided subject, property name and callback.</summary>
        </member>
        <member name="T:Eco.Shared.View.PropertySubscriptionBase">
            <summary>Base class for all property subscriptions.</summary>
        </member>
        <member name="T:Eco.Shared.View.SentinelSubscriptions">
            <summary>Wrapper for <see cref="P:Eco.Shared.View.SentinelSubscriptions.Subscriptions"/> which ensures no access to released subscriptions.</summary>
        </member>
        <member name="T:Eco.Shared.View.ISubscribableEvent">
            <summary>Interface for subscribable events (i.e. <see cref="T:Eco.Shared.View.SubscribableEvent`1"/>). Declared as interface so all classes may work with common interface no matter which type of wrapped event.</summary>
        </member>
        <member name="T:Eco.Shared.View.SubscribableEvent`1">
            <summary>Typed <see cref="T:Eco.Shared.View.ISubscribableEvent"/>. Not thread-safe. Simple wrapper around <typeparamref name="T"/> delegate. Can be used with <see cref="T:Eco.Shared.View.EventSubscription"/>.</summary>
        </member>
        <member name="M:Eco.Shared.View.SubscribableEvent`1.Add(`0)">
            <summary>Adds new handler for <see cref="F:Eco.Shared.View.SubscribableEvent`1.Event"/>.</summary>
        </member>
        <member name="M:Eco.Shared.View.SubscribableEvent`1.Remove(`0)">
            <summary>Removes previously added handler from <see cref="F:Eco.Shared.View.SubscribableEvent`1.Event"/>.</summary>
        </member>
        <member name="T:Eco.Shared.View.SubscribableEventExtensions">
            <summary>"Syntax sugar" for <see cref="T:Eco.Shared.View.SubscribableEvent`1"/>.</summary>
        </member>
        <member name="T:Eco.Shared.View.Subscriptions">
            <summary>
            Simple subscriptions collection which may be used for holding subset of subscriptions for class.
            It also may be used as ISubscription to keep sub-collection of subscriptions and unsubscribed together with main collection.
            </summary>
        </member>
        <member name="T:Eco.Shared.View.SubscriptionsExtensions">
            <summary>Extension methods for <see cref="T:Eco.Shared.View.ISubscriptions"/>.</summary>
        </member>
        <member name="F:Eco.Shared.View.SubscriptionsExtensions.CreatePropertySubscription">
            <summary>Function which creates IPropertySubscription, for server it will create ImmutablePropertySubscription instead of PropertySubscription, because it is thread-safe</summary>
        </member>
        <member name="M:Eco.Shared.View.SubscriptionsExtensions.UnsubscribeAll(Eco.Shared.View.ISubscriptions,System.Boolean)">
            <summary>
            Unsubscribes all previously added subscriptions and cleans subscription collection.
            </summary>
            <param name="ss">this ref.</param>
            <param name="release">by default Subscriptions list will be just cleared and then may be reused without recreation of list, but if Subscriptions won't be used anymore they may be released and returned to pool.</param>
        </member>
        <member name="M:Eco.Shared.View.SubscriptionsExtensions.UnsubscribeAllForSubject(Eco.Shared.View.ISubscriptions,Eco.Shared.View.IObservable)">
            <summary>
            Unsubscribe all subscriptions for given subject.
            </summary>
            <param name="ss">this ref.</param>
            <param name="subject">subject to unsubscribe.</param>
        </member>
        <member name="M:Eco.Shared.View.SubscriptionsExtensions.MakeNestedSubscriptions(Eco.Shared.View.ISubscriptions)">
            <summary> Makes nested subscriptions collection working as subset of <paramref name="ss"/>. It will be unsubscribed when <see cref="M:Eco.Shared.View.SubscriptionsExtensions.UnsubscribeAll(Eco.Shared.View.ISubscriptions,System.Boolean)"/> called on <paramref name="ss"/>, but may when <see cref="M:Eco.Shared.View.SubscriptionsExtensions.UnsubscribeAll(Eco.Shared.View.ISubscriptions,System.Boolean)"/> called on this it will only clear nested subscriptions. </summary>
        </member>
        <member name="M:Eco.Shared.View.SubscriptionsExtensions.DestroyNestedSubscriptions(Eco.Shared.View.ISubscriptions,Eco.Shared.View.ISubscriptions)">
            <summary>
            Destroys nested subscriptions previously created with <see cref="M:Eco.Shared.View.SubscriptionsExtensions.MakeNestedSubscriptions(Eco.Shared.View.ISubscriptions)"/>.
            It will unsubscribe all subscriptions in <paramref name="nested"/> and remove from <paramref name="subs"/>.
            Destroyed nested subscriptions can't be used, because they will be recycled and continue using it will lead to unpredictable behavior.
            </summary>
        </member>
        <member name="M:Eco.Shared.View.SubscriptionsExtensions.TrySubscribe(Eco.Shared.View.ISubscriptions,Eco.Shared.View.IPropertySubscription)">
            <summary> Tries to add <paramref name="subscription"/> to <paramref name="ss"/>. Internally it subscribes on <see cref="P:Eco.Shared.View.IPropertySubscription.Subject"/>. If subscription already was added to same property with same callback then it will return <c>false</c> and won't add subscription. </summary>
        </member>
        <member name="F:Eco.Shared.View.View.NoOpSubscription">
            <summary> When a property callback removed during notifying the property. It will replace removed callback to avoid invoke on invalid subscription. </summary>
        </member>
        <member name="F:Eco.Shared.View.View.notifyTarget">
            <summary> Current notification target for <see cref="M:Eco.Shared.View.View.NotifyChanged(System.String)"/>. It may be used in methods like <see cref="M:Eco.Shared.View.View.Unsubscribe(Eco.Shared.View.IPropertySubscription)"/> which modifies the callbacks collection to prevent concurrent modifications. </summary>
        </member>
        <member name="M:Eco.Shared.View.View.HasData(Eco.Shared.View.View.ViewData)">
            <summary> Checks if view is holding <paramref name="data"/>. </summary>
        </member>
        <member name="M:Eco.Shared.View.View.MarkPropSubscribed(System.String)">
            <summary> Mark the prop as received, so we can verify access only occurs when its received.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.GetSubscriptions">
            <summary>Returns all registered property subscriptions. Don't use it for notify, just for inspection!</summary>
        </member>
        <member name="M:Eco.Shared.View.View.Unsubscribe(Eco.Shared.View.IPropertySubscription)">
            <summary> Removes <paramref name="subscription"/> from <see cref="F:Eco.Shared.View.View.changedCallbacks"/>. </summary>
        </member>
        <member name="M:Eco.Shared.View.View.RemovePropertyCallbacksIfEmpty(System.String,System.Collections.Generic.List{Eco.Shared.View.IPropertySubscription})">
            <summary>Checks if <paramref name="propertyCallbacks"/> collection is empty for <paramref name="propertyName"/> and removes it from registered property callbacks in this case.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.NotifyAll">
            <summary> Notifies all changed callbacks for all properties. Primarily intended for debugging. </summary>
        </member>
        <member name="M:Eco.Shared.View.View.DescribeSubscriptions(System.Text.StringBuilder,System.String)">
            <summary>Returns count of property subscriptions. Mostly for debugging purposes.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.TryGetValue``1(System.String,``0@,System.Int32)">
            <summary>Get a dynamic value by property name, querying both reflection and the list of dynamic properties sent by the server.  Returns 
            false if the property doesnt exist in either, or if referencing a list, the list index doesn't exist.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.RPC(System.String,System.Object[])">
            <summary>Makes RPC call on the View.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.RPC(System.String,System.Action,System.Object[])">
            <summary>Makes RPC call on the View with callback with no return value. <paramref name="response"/> callback doesn't wait while views changed with RPC synced back to the client, so you may have old View values when callback invoke. If you need to have synced values then use <see cref="M:Eco.Shared.View.View.SyncedRPC(System.String,System.Action,System.Object[])"/> instead.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.ThrottledRPC(System.String,System.Object[])">
            <summary>Makes RPC call on the View with ensurence that it won't be sent again if server still didn't confirmed previous request. </summary> 
        </member>
        <member name="M:Eco.Shared.View.View.SyncedRPC(System.String,System.Action,System.Object[])">
            <summary>
            Makes RPC call on the View with callback with no return value. Callback will be synced with view updates initiated by RPC. I.e. if it changes a property then that property will be synced back to the client before callback invoked.
            Should be used when RPC callback expects view changes to be synced on the client. I.e. after SetProperty you want to make some calculations based on value of that property.
            <example><code>
            view.RPC("SetDateOfBirth", () => age = DateTime.Today - view.DateOfBirth, date);
            </code></example>
            When non-synced <c>RPC</c> used there no guarantee that DateOfBirth will have new value just set with RPC, because it synced asynchronously to RPC. It may still have old value (actually in most cases it will have previous value).
            </summary>
        </member>
        <member name="M:Eco.Shared.View.View.RPC``1(System.String,System.Action{``0},System.Object[])">
            <summary>Makes RPC call on the View with callback having return value. <paramref name="response"/> callback doesn't wait while views changed with RPC synced back to the client, so you may have old View values when callback invoke. If you need to have synced values then use <see cref="M:Eco.Shared.View.View.SyncedRPC``1(System.String,System.Action{``0},System.Object[])"/> instead.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.SyncedRPC``1(System.String,System.Action{``0},System.Object[])">
            <summary>
            Makes RPC call on the View with callback having return value. Callback will be synced with view updates initiated by RPC. I.e. if it changes a property then that property will be synced back to the client before callback invoked.
            See <see cref="M:Eco.Shared.View.View.SyncedRPC(System.String,System.Action,System.Object[])"/> for more details and examples.
            </summary>
        </member>
        <member name="M:Eco.Shared.View.View.ManualRPC``1(System.String,System.Action{``0},System.Int32,System.Object[])">
            <summary>Makes RPC call on view with provided <paramref name="viewId"/>.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.CreateViewRPCPayload(System.Object[])">
            <summary>Creates ViewRPC payload from <paramref name="args"/> to be provided for ViewRPC call. </summary>
        </member>
        <member name="M:Eco.Shared.View.View.ViewData.TryGetDynamicValue(System.String,System.Object@)">
            <summary>Get a dynamic value matching the given name, returning false if the property isnt found.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.SetFieldViewData``1(``0@,Eco.Shared.View.View)">
            <summary> Sets <paramref name="field"/>'s <see cref="T:Eco.Shared.View.View.ViewData"/> from <paramref name="view"/>. We need this method because of accessibility restrictions. </summary>
        </member>
        <member name="M:Eco.Shared.View.View.GetOrRecoverView(Eco.Shared.View.View.ViewData)">
            <summary> Exposes access to <see cref="M:Eco.Shared.View.ViewManager.GetOrRecoverView(Eco.Shared.View.View.ViewData)"/> from <see cref="T:Eco.Shared.View.View"/> derived classes. </summary>
        </member>
        <member name="M:Eco.Shared.View.View.Recover">
            <summary>
            Recovers <see cref="T:Eco.Shared.View.View"/> from <see cref="F:Eco.Shared.View.View.Data"/>.
            When original <see cref="T:Eco.Shared.View.View"/> was destroyed, but then a reference to it received from the server then it may need to perform some logic to correctly restore <see cref="T:Eco.Shared.View.View"/> from backup <see cref="F:Eco.Shared.View.View.Data"/>.
            </summary>
        </member>
        <member name="P:Eco.Shared.View.View.DebugName">
            <summary> Returns View name which may be used for debugging. </summary>
        </member>
        <member name="T:Eco.Shared.View.ViewManager">
            <summary> Manages Views on client. Read more details about View System in ViewSystem.md. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.UnpackageViewInternal(Eco.Shared.Serialization.BSONValue)">
            <summary>Unpackaged <see cref="T:Eco.Shared.View.View"/> from BSON with value type <see cref="F:Eco.Shared.Serialization.BSONValueType.View"/> or <see cref="F:Eco.Shared.Serialization.BSONValueType.ViewRef"/>.</summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.GetOrRecoverView(Eco.Shared.View.View.ViewData)">
            <summary> Gets or recover <see cref="T:Eco.Shared.View.View"/> for <see cref="T:Eco.Shared.View.View.ViewData"/>. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.GetView(System.Int32)">
            <summary>Returns the view with the given ID if we have it, otherwise null.</summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.TryGetView(System.Int32,Eco.Shared.View.View@)">
            <summary>Try get <see cref="T:Eco.Shared.View.View"/> by id. It may not return view if it wasn't received or already released (has no active ref).</summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.GetOrCreateView(Eco.Shared.Serialization.BSONObject)">
            <summary>Get or create <see cref="T:Eco.Shared.View.View"/> from <paramref name="bson"/>.</summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.CollectViewStats">
            <summary> Collect stats about existing views in <see cref="T:Eco.Shared.View.ViewManager"/>. May be used for statistic and leaks detection. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.CollectInvalidSubscriptions">
            <summary>Collects all invalid subscriptions. Invalid subscription is a <see cref="T:Eco.Shared.View.IPropertySubscription"/> which has <c>null</c> or destroyed target for an instance method (it is always <c>null</c> for static methods).</summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.TraceViewRefs(System.Int32)">
            <summary> Traces existing views for references to view with specified <paramref name="viewId"/>. It helps to debug why some view was added to the client and why it wasn't GC. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.SampleViewTraces(System.String,System.Int32,System.Int32)">
            <summary> Returns <see cref="T:Eco.Shared.Text.InfoBuilder"/> with traces for <paramref name="n"/> views of <paramref name="viewType"/> type (see <see cref="M:Eco.Shared.View.ViewManager.TraceViewRefs(System.Int32)"/>). Optionally it can skip firt <paramref name="skipN"/> elements. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.TraceViewRefs(Eco.Shared.View.View.ViewData)">
            <summary> Traces existing views for references to <paramref name="targetData"/>. It helps to debug why some view was added to the client and why it wasn't GC. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.TraceViewRefs(Eco.Shared.View.View.ViewData,System.Text.StringBuilder,System.Collections.Generic.HashSet{Eco.Shared.View.View.ViewData})">
            <summary> Internal recursive implementation of <see cref="M:Eco.Shared.View.ViewManager.TraceViewRefs(System.Int32)"/>. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.IsReferencingViewData(System.Object,Eco.Shared.View.View.ViewData)">
            <summary> Checks if <paramref name="value"/> either is <see cref="T:Eco.Shared.View.View"/> containing <paramref name="viewData"/> or collection one of each elements is such view. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.NotifyAllViews">
            <summary> Notifies all views about all subscribed properties changes. NOT INTENDED FOR PRODUCTION USAGE. ONLY FOR DEBUGGING! </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.ViewNotify(Eco.Shared.Serialization.BSONObject,Eco.Shared.View.View,System.Collections.Generic.List{Eco.Shared.View.ViewManager.ViewNotification})">
            <summary> Updates view property and adds property change notification to notifications list (if not null). </summary>
        </member>
        <member name="T:Eco.Shared.View.ApplyOnViewAttribute">
            <summary> Tag interfaces with this to make them add themselves when autogenning views. Useful for interfaces that are shared among server/client in shared code. </summary>
        </member>
        <member name="T:Eco.Shared.View.WeakPropertySubscription">
            <summary>// Weak reference wrapper class for delegate storage without user defined removal.</summary>
        </member>
        <member name="T:Eco.Shared.Voxel.BlockID">
            <summary>
            Standard block IDs. These shared between client and server and should be read-only to be compatible with Burst.
            Client uses these block IDs as default for fully enclosed chunks or for missing chunks.
            </summary>
        </member>
        <member name="T:Eco.Shared.Voxel.HashChunkContainer`1">
             <summary>
             This is an alternative class to the OctreeChunkContainer, rather than storing chunks in a tree we store them in a hash table. 
             This will use slightly more memory, but gives a faster speed lookup for single chunks, and similar speed for ranges.
            
             Note: In order to get chunk level locking, rather than lock the whole container during each update, the Count may not always be correct and should only be treaded as a guide.
             e.g. Don't use Count to create a new array, create a List instead, that way if count is wrong it wont matter as the list will auto expand itself.
             </summary>
        </member>
        <member name="T:Eco.Shared.Voxel.IChunkGrid">
            <summary>Interface for all Chunk Grid implementations (both on server side and client-side). Chunk Grid is 3D grid of <see cref="T:Eco.Shared.Voxel.IChunk"/> objects.</summary>
        </member>
        <member name="M:Eco.Shared.Voxel.IChunkGrid.Clear(System.Guid)">
            <summary>Removes all chunks from grid.</summary>
        </member>
        <member name="M:Eco.Shared.Voxel.ChunkGridExtensions.Clear(Eco.Shared.Voxel.IChunkGrid)">
            <summary>Shortcut for <see cref="M:Eco.Shared.Voxel.IChunkGrid.Clear(System.Guid)"/> with new <see cref="T:System.Guid"/> generated.</summary>
            <param name="chunkGrid"></param>
        </member>
        <member name="T:Eco.Shared.Voxel.Octree`1">
            <summary>
            Implements a cubic Octree.
            </summary>
            <remarks>
            An octree implemented over cubes indexed by integer values.  The tree will automatically grow to accommodate
            any added entries.  Optionally thread-safe.  Where ranges are used, they are interpreted as [min,max).
            </remarks>
            <typeparam name="T">The type of data to store in the tree.</typeparam>
        </member>
        <member name="M:Eco.Shared.Voxel.OctreeNode`1.Set(Eco.Shared.Math.Vector3i,`0)">
            <summary>
            Set the value at the specified position.
            </summary>
            <returns>True if a new value was added, false if a value was replaced.</returns>
        </member>
        <member name="P:Eco.Shared.Voxel.PlotPos.RawXY">
            <summary>Convert the plot pos to a regular Vector2i, without doing any kind of coordinate transformation from plot space to world space.</summary>
        </member>
        <member name="P:Eco.Shared.Voxel.PlotPos.RawX_Z">
            <summary>Convert the plot pos to a regular Vector3i, with y=0, without doing any kind of coordinate transformation from plot space to world space.</summary>
        </member>
        <member name="T:Eco.Shared.Voxel.PlotUtil">
            <summary> Functions for translating to/from property plot coordinates. </summary>
        </member>
        <member name="F:Eco.Shared.Voxel.PlotUtil.WorldPlotDims">
            <summary> Returns many plots exist in the x and z dimensions of the world. </summary>
        </member>
        <member name="M:Eco.Shared.Voxel.PlotUtil.ToPlotPos(Eco.Shared.Math.Vector2i)">
            <summary>Converts a position in world space to a position in plot space. Performs the wrap.</summary>
        </member>
        <member name="M:Eco.Shared.Voxel.PlotUtil.RawPlotPos(Eco.Shared.Math.Vector2i)">
            <summary>Converts a Vector2i to a plotpos structure, with no coordinate transformation at all.  Careful with this one.  Asserts its pre-wrapped.</summary>
        </member>
        <member name="M:Eco.Shared.Voxel.PlotUtil.RawPlotPosWrap(Eco.Shared.Math.Vector2i)">
            <summary>Converts the raw value of a vector2i already in plot space to a plot pos, wrapping in the process. Needed to work with things that
            iterate on vector2is past world bounds, like WorldRange.</summary>
        </member>
        <member name="M:Eco.Shared.Voxel.PlotUtil.IntersectingPlotsExc(Eco.Shared.Math.WorldRange)">
            <summary> Get the list of Plot Positions for each plot that this range intersects. </summary>
        </member>
        <member name="T:Eco.Shared.Voxel.World">
            <summary>
            Wrapper class around the static voxel grid that represents the world.
            Essentially this class exists so its easier to do WorldCache.SomeMethod() instead of WorldCache.Obj.SomeMethod().
            Gets ChunkViews from the ChunkGrid.
            Gets Blocks from Chunks from the ChunkGrid.
            </summary>
        </member>
        <member name="M:Eco.Shared.Voxel.World.ToChunkPosition(Eco.Shared.Math.WrappedWorldPosition3i)">
            <summary> Converts <see cref="T:Eco.Shared.Math.WrappedWorldPosition3i"/> to chunk position. </summary>
        </member>
        <member name="M:Eco.Shared.Voxel.World.ToLocalPosition(Eco.Shared.Math.Vector3i)">
            Warning: The coordinates are modulus/wrapping based on the chunk size, not relative to the chunk origin 
        </member>
        <member name="M:Eco.Shared.Voxel.World.ToLocalPosition(System.Int32,System.Int32,System.Int32)">
            Warning: The coordinates are modulus/wrapping based on the chunk size, not relative to the chunk origin 
        </member>
        <member name="M:Eco.Shared.Voxel.World.ToLocalPosition(Eco.Shared.Math.WrappedWorldPosition3i)">
            <summary> Returns local block position within chunk space. All chunks should be aligned to <see cref="F:Eco.Shared.Voxel.Chunk.Size"/>. Using <see cref="T:Eco.Shared.Math.WrappedWorldPosition3i"/> let us skip some check and use most optimized algorithm. </summary>
        </member>
        <member name="T:Microsoft.IO.RecyclableMemoryStream">
             <summary>
             MemoryStream implementation that deals with pooling and managing memory streams which use potentially large
             buffers.
             </summary>
             <remarks>
             This class works in tandem with the RecylableMemoryStreamManager to supply MemoryStream
             objects to callers, while avoiding these specific problems:
             1. LOH allocations - since all large buffers are pooled, they will never incur a Gen2 GC
             2. Memory waste - A standard memory stream doubles its size when it runs out of room. This
             leads to continual memory growth as each stream approaches the maximum allowed size.
             3. Memory copying - Each time a MemoryStream grows, all the bytes are copied into new buffers.
             This implementation only copies the bytes when GetBuffer is called.
             4. Memory fragmentation - By using homogeneous buffer sizes, it ensures that blocks of memory
             can be easily reused.
            
             The stream is implemented on top of a series of uniformly-sized blocks. As the stream's length grows,
             additional blocks are retrieved from the memory manager. It is these blocks that are pooled, not the stream
             object itself.
            
             The biggest wrinkle in this implementation is when GetBuffer() is called. This requires a single
             contiguous buffer. If only a single block is in use, then that block is returned. If multiple blocks
             are in use, we retrieve a larger buffer from the memory manager. These large buffers are also pooled,
             split by size--they are multiples of a chunk size (1 MB by default).
            
             Once a large buffer is assigned to the stream the blocks are NEVER again used for this stream. All operations take place on the
             large buffer. The large buffer can be replaced by a larger buffer from the pool as needed. All blocks and large buffers
             are maintained in the stream until the stream is disposed (unless AggressiveBufferReturn is enabled in the stream manager).
            
             </remarks>
        </member>
        <member name="F:Microsoft.IO.RecyclableMemoryStream.blocks">
            <summary>
            All of these blocks must be the same size.
            </summary>
        </member>
        <member name="F:Microsoft.IO.RecyclableMemoryStream.byteBuffer">
            <summary>
            This buffer exists so that WriteByte can forward all of its calls to Write
            without creating a new byte[] buffer on every call.
            </summary>
        </member>
        <member name="F:Microsoft.IO.RecyclableMemoryStream.dirtyBuffers">
            <summary>
            This list is used to store buffers once they're replaced by something larger.
            This is for the cases where you have users of this class that may hold onto the buffers longer
            than they should and you want to prevent race conditions which could corrupt the data.
            </summary>
        </member>
        <member name="F:Microsoft.IO.RecyclableMemoryStream.largeBuffer">
            <summary>
            This is only set by GetBuffer() if the necessary buffer is larger than a single block size, or on
            construction if the caller immediately requests a single large buffer.
            </summary>
            <remarks>If this field is non-null, it contains the concatenation of the bytes found in the individual
            blocks. Once it is created, this (or a larger) largeBuffer will be used for the life of the stream.
            </remarks>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.Id">
            <summary>
            Unique identifier for this stream across it's entire lifetime.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.Tag">
            <summary>
            A temporary identifier for the current usage of this stream.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.MemoryManager">
            <summary>
            Gets the memory manager being used by this stream.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.AllocationStack">
            <summary>
            Callstack of the constructor. It is only set if MemoryManager.GenerateCallStacks is true,
            which should only be in debugging situations.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.DisposeStack">
            <summary>
            Callstack of the Dispose call. It is only set if MemoryManager.GenerateCallStacks is true,
            which should only be in debugging situations.
            </summary>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.#ctor(Microsoft.IO.RecyclableMemoryStreamManager)">
            <summary>
            Allocate a new RecyclableMemoryStream object.
            </summary>
            <param name="memoryManager">The memory manager.</param>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.#ctor(Microsoft.IO.RecyclableMemoryStreamManager,System.String)">
            <summary>
            Allocate a new RecyclableMemoryStream object.
            </summary>
            <param name="memoryManager">The memory manager.</param>
            <param name="tag">A string identifying this stream for logging and debugging purposes.</param>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.#ctor(Microsoft.IO.RecyclableMemoryStreamManager,System.String,System.Int32)">
            <summary>
            Allocate a new RecyclableMemoryStream object.
            </summary>
            <param name="memoryManager">The memory manager.</param>
            <param name="tag">A string identifying this stream for logging and debugging purposes.</param>
            <param name="requestedSize">The initial requested size to prevent future allocations.</param>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.#ctor(Microsoft.IO.RecyclableMemoryStreamManager,System.String,System.Int32,System.Byte[])">
            <summary>
            Allocate a new RecyclableMemoryStream object.
            </summary>
            <param name="memoryManager">The memory manager.</param>
            <param name="tag">A string identifying this stream for logging and debugging purposes.</param>
            <param name="requestedSize">The initial requested size to prevent future allocations.</param>
            <param name="initialLargeBuffer">An initial buffer to use. This buffer will be owned by the stream and returned to the memory manager upon Dispose.</param>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.Dispose(System.Boolean)">
            <summary>
            Returns the memory used by this stream back to the pool.
            </summary>
            <param name="disposing">Whether we're disposing (true), or being called by the finalizer (false).</param>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.Close">
            <summary>
            Equivalent to Dispose.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.Capacity">
            <summary>
            Gets or sets the capacity.
            </summary>
            <remarks>Capacity is always in multiples of the memory manager's block size, unless
            the large buffer is in use.  Capacity never decreases during a stream's lifetime.
            Explicitly setting the capacity to a lower value than the current value will have no effect.
            This is because the buffers are all pooled by chunks and there's little reason to
            allow stream truncation.
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.Length">
            <summary>
            Gets the number of bytes written to this stream.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.Position">
            <summary>
            Gets the current position in the stream.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.CanRead">
            <summary>
            Whether the stream can currently read.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.CanSeek">
            <summary>
            Whether the stream can currently seek.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.CanTimeout">
            <summary>
            Always false.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.CanWrite">
            <summary>
            Whether the stream can currently write.
            </summary>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.GetBuffer">
            <summary>
            Returns a single buffer containing the contents of the stream.
            The buffer may be longer than the stream length.
            </summary>
            <returns>A byte[] buffer.</returns>
            <remarks>IMPORTANT: Doing a Write() after calling GetBuffer() invalidates the buffer. The old buffer is held onto
            until Dispose is called, but the next time GetBuffer() is called, a new buffer from the pool will be required.</remarks>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.ToArray">
            <summary>
            Returns a new array with a copy of the buffer's contents. You should almost certainly be using GetBuffer combined with the Length to
            access the bytes in this stream. Calling ToArray will destroy the benefits of pooled buffers, but it is included
            for the sake of completeness.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads from the current position into the provided buffer.
            </summary>
            <param name="buffer">Destination buffer.</param>
            <param name="offset">Offset into buffer at which to start placing the read bytes.</param>
            <param name="count">Number of bytes to read.</param>
            <returns>The number of bytes read.</returns>
            <exception cref="T:System.ArgumentNullException">buffer is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is less than 0.</exception>
            <exception cref="T:System.ArgumentException">offset subtracted from the buffer length is less than count.</exception>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.SafeRead(System.Byte[],System.Int32,System.Int32,System.Int32@)">
            <summary>
            Reads from the specified position into the provided buffer.
            </summary>
            <param name="buffer">Destination buffer.</param>
            <param name="offset">Offset into buffer at which to start placing the read bytes.</param>
            <param name="count">Number of bytes to read.</param>
            <param name="streamPosition">Position in the stream to start reading from.</param>
            <returns>The number of bytes read.</returns>
            <exception cref="T:System.ArgumentNullException">buffer is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is less than 0.</exception>
            <exception cref="T:System.ArgumentException">offset subtracted from the buffer length is less than count.</exception>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the buffer to the stream.
            </summary>
            <param name="buffer">Source buffer.</param>
            <param name="offset">Start position.</param>
            <param name="count">Number of bytes to write.</param>
            <exception cref="T:System.ArgumentNullException">buffer is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative.</exception>
            <exception cref="T:System.ArgumentException">buffer.Length - offset is not less than count.</exception>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.ToString">
            <summary>
            Returns a useful string for debugging. This should not normally be called in actual production code.
            </summary>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.WriteByte(System.Byte)">
            <summary>
            Writes a single byte to the current position in the stream.
            </summary>
            <param name="value">byte value to write.</param>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.ReadByte">
            <summary>
            Reads a single byte from the current position in the stream.
            </summary>
            <returns>The byte at the current position, or -1 if the position is at the end of the stream.</returns>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.SafeReadByte(System.Int32@)">
            <summary>
            Reads a single byte from the specified position in the stream.
            </summary>
            <param name="streamPosition">The position in the stream to read from.</param>
            <returns>The byte at the current position, or -1 if the position is at the end of the stream.</returns>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.SetLength(System.Int64)">
            <summary>
            Sets the length of the stream.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">value is negative or larger than MaxStreamLength.</exception>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position to the offset from the seek location.
            </summary>
            <param name="offset">How many bytes to move.</param>
            <param name="loc">From where.</param>
            <returns>The new position.</returns>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset is larger than MaxStreamLength.</exception>
            <exception cref="T:System.ArgumentException">Invalid seek origin.</exception>
            <exception cref="T:System.IO.IOException">Attempt to set negative position.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.WriteTo(System.IO.Stream)">
            <summary>
            Synchronously writes this stream's bytes to the parameter stream.
            </summary>
            <param name="stream">Destination stream.</param>
            <remarks>Important: This does a synchronous write, which may not be desired in some situations.</remarks>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.ReleaseLargeBuffer">
            <summary>
            Release the large buffer (either stores it for eventual release or returns it immediately).
            </summary>
        </member>
        <member name="T:Microsoft.IO.RecyclableMemoryStreamManager">
             <summary>
             Manages pools of RecyclableMemoryStream objects.
             </summary>
             <remarks>
             There are two pools managed in here. The small pool contains same-sized buffers that are handed to streams
             as they write more data.
            
             For scenarios that need to call GetBuffer(), the large pool contains buffers of various sizes, all
             multiples of LargeBufferMultiple (1 MB by default). They are split by size to avoid overly-wasteful buffer
             usage. There should be far fewer 8 MB buffers than 1 MB buffers, for example.
             </remarks>
        </member>
        <member name="F:Microsoft.IO.RecyclableMemoryStreamManager.largePools">
            <summary>
            pools[0] = 1x largeBufferMultiple buffers
            pools[1] = 2x largeBufferMultiple buffers
            etc., up to maximumBufferSize.
            </summary>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.#ctor">
            <summary>
            Initializes the memory manager with the default block/buffer specifications.
            </summary>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes the memory manager with the given block requiredSize.
            </summary>
            <param name="blockSize">Size of each block that is pooled. Must be > 0.</param>
            <param name="largeBufferMultiple">Each large buffer will be a multiple of this value.</param>
            <param name="maximumBufferSize">Buffers larger than this are not pooled.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">blockSize is not a positive number, or largeBufferMultiple is not a positive number, or maximumBufferSize is less than blockSize.</exception>
            <exception cref="T:System.ArgumentException">maximumBufferSize is not a multiple of largeBufferMultiple.</exception>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.BlockSize">
            <summary>
            The size of each block. It must be set at creation and cannot be changed.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.LargeBufferMultiple">
            <summary>
            All buffers are multiples of this number. It must be set at creation and cannot be changed.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.MaximumBufferSize">
            <summary>
            Gets or sets the maximum buffer size.
            </summary>
            <remarks>Any buffer that is returned to the pool that is larger than this will be
            discarded and garbage collected.</remarks>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.SmallPoolFreeSize">
            <summary>
            Number of bytes in small pool not currently in use.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.SmallPoolInUseSize">
            <summary>
            Number of bytes currently in use by stream from the small pool.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.LargePoolFreeSize">
            <summary>
            Number of bytes in large pool not currently in use.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.LargePoolInUseSize">
            <summary>
            Number of bytes currently in use by streams from the large pool.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.SmallBlocksFree">
            <summary>
            How many blocks are in the small pool.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.LargeBuffersFree">
            <summary>
            How many buffers are in the large pool.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.MaximumFreeSmallPoolBytes">
            <summary>
            How many bytes of small free blocks to allow before we start dropping
            those returned to us.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.MaximumFreeLargePoolBytes">
            <summary>
            How many bytes of large free buffers to allow before we start dropping
            those returned to us.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.MaximumStreamCapacity">
            <summary>
            Maximum stream capacity in bytes. Attempts to set a larger capacity will
            result in an exception.
            </summary>
            <remarks>A value of 0 indicates no limit.</remarks>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.GenerateCallStacks">
            <summary>
            Whether to save callstacks for stream allocations. This can help in debugging.
            It should NEVER be turned on generally in production.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.AggressiveBufferReturn">
            <summary>
            Whether dirty buffers can be immediately returned to the buffer pool. E.g. when GetBuffer() is called on
            a stream and creates a single large buffer, if this setting is enabled, the other blocks will be returned
            to the buffer pool immediately.
            Note when enabling this setting that the user is responsible for ensuring that any buffer previously
            retrieved from a stream which is subsequently modified is not used after modification (as it may no longer
            be valid).
            </summary>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.GetBlock">
            <summary>
            Removes and returns a single block from the pool.
            </summary>
            <returns>A byte[] array.</returns>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.GetLargeBuffer(System.Int32,System.String)">
            <summary>
            Returns a buffer of arbitrary size from the large buffer pool. This buffer
            will be at least the requiredSize and always be a multiple of largeBufferMultiple.
            </summary>
            <param name="requiredSize">The minimum length of the buffer.</param>
            <param name="tag">The tag of the stream returning this buffer, for logging if necessary.</param>
            <returns>A buffer of at least the required size.</returns>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.ReturnLargeBuffer(System.Byte[],System.String)">
            <summary>
            Returns the buffer to the large pool.
            </summary>
            <param name="buffer">The buffer to return.</param>
            <param name="tag">The tag of the stream returning this buffer, for logging if necessary.</param>
            <exception cref="T:System.ArgumentNullException">buffer is null.</exception>
            <exception cref="T:System.ArgumentException">buffer.Length is not a multiple of LargeBufferMultiple (it did not originate from this pool).</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.ReturnBlocks(System.Collections.Generic.ICollection{System.Byte[]},System.String)">
            <summary>
            Returns the blocks to the pool.
            </summary>
            <param name="blocks">Collection of blocks to return to the pool.</param>
            <param name="tag">The tag of the stream returning these blocks, for logging if necessary.</param>
            <exception cref="T:System.ArgumentNullException">blocks is null.</exception>
            <exception cref="T:System.ArgumentException">blocks contains buffers that are the wrong size (or null) for this memory manager.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.GetStream">
            <summary>
            Retrieve a new MemoryStream object with no tag and a default initial capacity.
            </summary>
            <returns>A MemoryStream.</returns>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.GetStream(System.String)">
            <summary>
            Retrieve a new MemoryStream object with the given tag and a default initial capacity.
            </summary>
            <param name="tag">A tag which can be used to track the source of the stream.</param>
            <returns>A MemoryStream.</returns>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.GetStream(System.String,System.Int32)">
            <summary>
            Retrieve a new MemoryStream object with the given tag and at least the given capacity.
            </summary>
            <param name="tag">A tag which can be used to track the source of the stream.</param>
            <param name="requiredSize">The minimum desired capacity for the stream.</param>
            <returns>A MemoryStream.</returns>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.GetStream(System.String,System.Int32,System.Boolean)">
            <summary>
            Retrieve a new MemoryStream object with the given tag and at least the given capacity, possibly using
            a single contiguous underlying buffer.
            </summary>
            <remarks>Retrieving a MemoryStream which provides a single contiguous buffer can be useful in situations
            where the initial size is known and it is desirable to avoid copying data between the smaller underlying
            buffers to a single large one. This is most helpful when you know that you will always call GetBuffer
            on the underlying stream.</remarks>
            <param name="tag">A tag which can be used to track the source of the stream.</param>
            <param name="requiredSize">The minimum desired capacity for the stream.</param>
            <param name="asContiguousBuffer">Whether to attempt to use a single contiguous buffer.</param>
            <returns>A MemoryStream.</returns>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.GetStream(System.String,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Retrieve a new MemoryStream object with the given tag and with contents copied from the provided
            buffer. The provided buffer is not wrapped or used after construction.
            </summary>
            <remarks>The new stream's position is set to the beginning of the stream when returned.</remarks>
            <param name="tag">A tag which can be used to track the source of the stream.</param>
            <param name="buffer">The byte buffer to copy data from.</param>
            <param name="offset">The offset from the start of the buffer to copy from.</param>
            <param name="count">The number of bytes to copy from the buffer.</param>
            <returns>A MemoryStream.</returns>
        </member>
    </members>
</doc>
